
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model AccountNotification
 * 
 */
export type AccountNotification = $Result.DefaultSelection<Prisma.$AccountNotificationPayload>
/**
 * Model AccountPassword
 * 
 */
export type AccountPassword = $Result.DefaultSelection<Prisma.$AccountPasswordPayload>
/**
 * Model NetworkHistory
 * 
 */
export type NetworkHistory = $Result.DefaultSelection<Prisma.$NetworkHistoryPayload>
/**
 * Model NetworkBlacklist
 * 
 */
export type NetworkBlacklist = $Result.DefaultSelection<Prisma.$NetworkBlacklistPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model CharacterVersion
 * 
 */
export type CharacterVersion = $Result.DefaultSelection<Prisma.$CharacterVersionPayload>
/**
 * Model CharacterStat
 * 
 */
export type CharacterStat = $Result.DefaultSelection<Prisma.$CharacterStatPayload>
/**
 * Model CharacterQuest
 * 
 */
export type CharacterQuest = $Result.DefaultSelection<Prisma.$CharacterQuestPayload>
/**
 * Model CharacterEquipment
 * 
 */
export type CharacterEquipment = $Result.DefaultSelection<Prisma.$CharacterEquipmentPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ItemWeapon
 * 
 */
export type ItemWeapon = $Result.DefaultSelection<Prisma.$ItemWeaponPayload>
/**
 * Model ItemSpell
 * 
 */
export type ItemSpell = $Result.DefaultSelection<Prisma.$ItemSpellPayload>
/**
 * Model Spell
 * 
 */
export type Spell = $Result.DefaultSelection<Prisma.$SpellPayload>
/**
 * Model Potion
 * 
 */
export type Potion = $Result.DefaultSelection<Prisma.$PotionPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model Ability
 * 
 */
export type Ability = $Result.DefaultSelection<Prisma.$AbilityPayload>
/**
 * Model Quest
 * 
 */
export type Quest = $Result.DefaultSelection<Prisma.$QuestPayload>
/**
 * Model StatModifer
 * 
 */
export type StatModifer = $Result.DefaultSelection<Prisma.$StatModiferPayload>
/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model ArticleVersion
 * 
 */
export type ArticleVersion = $Result.DefaultSelection<Prisma.$ArticleVersionPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model AppliedTag
 * 
 */
export type AppliedTag = $Result.DefaultSelection<Prisma.$AppliedTagPayload>
/**
 * Model Mob
 * 
 */
export type Mob = $Result.DefaultSelection<Prisma.$MobPayload>
/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model ChangeLog
 * 
 */
export type ChangeLog = $Result.DefaultSelection<Prisma.$ChangeLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationType: {
  NEW_ITEM: 'NEW_ITEM',
  NEW_QUEST: 'NEW_QUEST',
  NEW_MOB: 'NEW_MOB',
  NEW_ARTICLE: 'NEW_ARTICLE',
  EDIT_ITEM: 'EDIT_ITEM',
  EDIT_QUEST: 'EDIT_QUEST',
  EDIT_MOB: 'EDIT_MOB',
  EDIT_ARTICLE: 'EDIT_ARTICLE',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const Align: {
  GNE: 'GNE',
  GN: 'GN',
  GE: 'GE',
  NE: 'NE',
  G: 'G',
  N: 'N',
  E: 'E'
};

export type Align = (typeof Align)[keyof typeof Align]


export const WeaponStat: {
  STR: 'STR',
  DEX: 'DEX',
  CON: 'CON'
};

export type WeaponStat = (typeof WeaponStat)[keyof typeof WeaponStat]


export const WeaponType: {
  BLUNT: 'BLUNT',
  PIERCE: 'PIERCE',
  SLASH: 'SLASH'
};

export type WeaponType = (typeof WeaponType)[keyof typeof WeaponType]


export const StatModifierType: {
  ABILITITY: 'ABILITITY',
  ITEM: 'ITEM',
  POTION: 'POTION',
  QUEST: 'QUEST',
  SKILL: 'SKILL',
  SPELL: 'SPELL'
};

export type StatModifierType = (typeof StatModifierType)[keyof typeof StatModifierType]


export const TagType: {
  ARTICLE: 'ARTICLE',
  ITEM: 'ITEM',
  MOB: 'MOB',
  QUEST: 'QUEST'
};

export type TagType = (typeof TagType)[keyof typeof TagType]

}

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type Align = $Enums.Align

export const Align: typeof $Enums.Align

export type WeaponStat = $Enums.WeaponStat

export const WeaponStat: typeof $Enums.WeaponStat

export type WeaponType = $Enums.WeaponType

export const WeaponType: typeof $Enums.WeaponType

export type StatModifierType = $Enums.StatModifierType

export const StatModifierType: typeof $Enums.StatModifierType

export type TagType = $Enums.TagType

export const TagType: typeof $Enums.TagType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.accountNotification`: Exposes CRUD operations for the **AccountNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountNotifications
    * const accountNotifications = await prisma.accountNotification.findMany()
    * ```
    */
  get accountNotification(): Prisma.AccountNotificationDelegate<ExtArgs>;

  /**
   * `prisma.accountPassword`: Exposes CRUD operations for the **AccountPassword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountPasswords
    * const accountPasswords = await prisma.accountPassword.findMany()
    * ```
    */
  get accountPassword(): Prisma.AccountPasswordDelegate<ExtArgs>;

  /**
   * `prisma.networkHistory`: Exposes CRUD operations for the **NetworkHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkHistories
    * const networkHistories = await prisma.networkHistory.findMany()
    * ```
    */
  get networkHistory(): Prisma.NetworkHistoryDelegate<ExtArgs>;

  /**
   * `prisma.networkBlacklist`: Exposes CRUD operations for the **NetworkBlacklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkBlacklists
    * const networkBlacklists = await prisma.networkBlacklist.findMany()
    * ```
    */
  get networkBlacklist(): Prisma.NetworkBlacklistDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs>;

  /**
   * `prisma.characterVersion`: Exposes CRUD operations for the **CharacterVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterVersions
    * const characterVersions = await prisma.characterVersion.findMany()
    * ```
    */
  get characterVersion(): Prisma.CharacterVersionDelegate<ExtArgs>;

  /**
   * `prisma.characterStat`: Exposes CRUD operations for the **CharacterStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterStats
    * const characterStats = await prisma.characterStat.findMany()
    * ```
    */
  get characterStat(): Prisma.CharacterStatDelegate<ExtArgs>;

  /**
   * `prisma.characterQuest`: Exposes CRUD operations for the **CharacterQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterQuests
    * const characterQuests = await prisma.characterQuest.findMany()
    * ```
    */
  get characterQuest(): Prisma.CharacterQuestDelegate<ExtArgs>;

  /**
   * `prisma.characterEquipment`: Exposes CRUD operations for the **CharacterEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterEquipments
    * const characterEquipments = await prisma.characterEquipment.findMany()
    * ```
    */
  get characterEquipment(): Prisma.CharacterEquipmentDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.itemWeapon`: Exposes CRUD operations for the **ItemWeapon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemWeapons
    * const itemWeapons = await prisma.itemWeapon.findMany()
    * ```
    */
  get itemWeapon(): Prisma.ItemWeaponDelegate<ExtArgs>;

  /**
   * `prisma.itemSpell`: Exposes CRUD operations for the **ItemSpell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemSpells
    * const itemSpells = await prisma.itemSpell.findMany()
    * ```
    */
  get itemSpell(): Prisma.ItemSpellDelegate<ExtArgs>;

  /**
   * `prisma.spell`: Exposes CRUD operations for the **Spell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spells
    * const spells = await prisma.spell.findMany()
    * ```
    */
  get spell(): Prisma.SpellDelegate<ExtArgs>;

  /**
   * `prisma.potion`: Exposes CRUD operations for the **Potion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Potions
    * const potions = await prisma.potion.findMany()
    * ```
    */
  get potion(): Prisma.PotionDelegate<ExtArgs>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs>;

  /**
   * `prisma.ability`: Exposes CRUD operations for the **Ability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abilities
    * const abilities = await prisma.ability.findMany()
    * ```
    */
  get ability(): Prisma.AbilityDelegate<ExtArgs>;

  /**
   * `prisma.quest`: Exposes CRUD operations for the **Quest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quest.findMany()
    * ```
    */
  get quest(): Prisma.QuestDelegate<ExtArgs>;

  /**
   * `prisma.statModifer`: Exposes CRUD operations for the **StatModifer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatModifers
    * const statModifers = await prisma.statModifer.findMany()
    * ```
    */
  get statModifer(): Prisma.StatModiferDelegate<ExtArgs>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs>;

  /**
   * `prisma.articleVersion`: Exposes CRUD operations for the **ArticleVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleVersions
    * const articleVersions = await prisma.articleVersion.findMany()
    * ```
    */
  get articleVersion(): Prisma.ArticleVersionDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.appliedTag`: Exposes CRUD operations for the **AppliedTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppliedTags
    * const appliedTags = await prisma.appliedTag.findMany()
    * ```
    */
  get appliedTag(): Prisma.AppliedTagDelegate<ExtArgs>;

  /**
   * `prisma.mob`: Exposes CRUD operations for the **Mob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mobs
    * const mobs = await prisma.mob.findMany()
    * ```
    */
  get mob(): Prisma.MobDelegate<ExtArgs>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs>;

  /**
   * `prisma.changeLog`: Exposes CRUD operations for the **ChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeLogs
    * const changeLogs = await prisma.changeLog.findMany()
    * ```
    */
  get changeLog(): Prisma.ChangeLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    AccountNotification: 'AccountNotification',
    AccountPassword: 'AccountPassword',
    NetworkHistory: 'NetworkHistory',
    NetworkBlacklist: 'NetworkBlacklist',
    Notification: 'Notification',
    Character: 'Character',
    CharacterVersion: 'CharacterVersion',
    CharacterStat: 'CharacterStat',
    CharacterQuest: 'CharacterQuest',
    CharacterEquipment: 'CharacterEquipment',
    Item: 'Item',
    ItemWeapon: 'ItemWeapon',
    ItemSpell: 'ItemSpell',
    Spell: 'Spell',
    Potion: 'Potion',
    Skill: 'Skill',
    Ability: 'Ability',
    Quest: 'Quest',
    StatModifer: 'StatModifer',
    Article: 'Article',
    ArticleVersion: 'ArticleVersion',
    Tag: 'Tag',
    AppliedTag: 'AppliedTag',
    Mob: 'Mob',
    Area: 'Area',
    ChangeLog: 'ChangeLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'account' | 'accountNotification' | 'accountPassword' | 'networkHistory' | 'networkBlacklist' | 'notification' | 'character' | 'characterVersion' | 'characterStat' | 'characterQuest' | 'characterEquipment' | 'item' | 'itemWeapon' | 'itemSpell' | 'spell' | 'potion' | 'skill' | 'ability' | 'quest' | 'statModifer' | 'article' | 'articleVersion' | 'tag' | 'appliedTag' | 'mob' | 'area' | 'changeLog'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      AccountNotification: {
        payload: Prisma.$AccountNotificationPayload<ExtArgs>
        fields: Prisma.AccountNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountNotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountNotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload>
          }
          findFirst: {
            args: Prisma.AccountNotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountNotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload>
          }
          findMany: {
            args: Prisma.AccountNotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload>[]
          }
          create: {
            args: Prisma.AccountNotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload>
          }
          createMany: {
            args: Prisma.AccountNotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountNotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload>
          }
          update: {
            args: Prisma.AccountNotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload>
          }
          deleteMany: {
            args: Prisma.AccountNotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountNotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountNotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountNotificationPayload>
          }
          aggregate: {
            args: Prisma.AccountNotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccountNotification>
          }
          groupBy: {
            args: Prisma.AccountNotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountNotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountNotificationCountAggregateOutputType> | number
          }
        }
      }
      AccountPassword: {
        payload: Prisma.$AccountPasswordPayload<ExtArgs>
        fields: Prisma.AccountPasswordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountPasswordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountPasswordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload>
          }
          findFirst: {
            args: Prisma.AccountPasswordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountPasswordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload>
          }
          findMany: {
            args: Prisma.AccountPasswordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload>[]
          }
          create: {
            args: Prisma.AccountPasswordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload>
          }
          createMany: {
            args: Prisma.AccountPasswordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountPasswordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload>
          }
          update: {
            args: Prisma.AccountPasswordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload>
          }
          deleteMany: {
            args: Prisma.AccountPasswordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountPasswordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountPasswordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPasswordPayload>
          }
          aggregate: {
            args: Prisma.AccountPasswordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccountPassword>
          }
          groupBy: {
            args: Prisma.AccountPasswordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountPasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountPasswordCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountPasswordCountAggregateOutputType> | number
          }
        }
      }
      NetworkHistory: {
        payload: Prisma.$NetworkHistoryPayload<ExtArgs>
        fields: Prisma.NetworkHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload>
          }
          findFirst: {
            args: Prisma.NetworkHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload>
          }
          findMany: {
            args: Prisma.NetworkHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload>[]
          }
          create: {
            args: Prisma.NetworkHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload>
          }
          createMany: {
            args: Prisma.NetworkHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NetworkHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload>
          }
          update: {
            args: Prisma.NetworkHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload>
          }
          deleteMany: {
            args: Prisma.NetworkHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NetworkHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkHistoryPayload>
          }
          aggregate: {
            args: Prisma.NetworkHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNetworkHistory>
          }
          groupBy: {
            args: Prisma.NetworkHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NetworkHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<NetworkHistoryCountAggregateOutputType> | number
          }
        }
      }
      NetworkBlacklist: {
        payload: Prisma.$NetworkBlacklistPayload<ExtArgs>
        fields: Prisma.NetworkBlacklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkBlacklistFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkBlacklistFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload>
          }
          findFirst: {
            args: Prisma.NetworkBlacklistFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkBlacklistFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload>
          }
          findMany: {
            args: Prisma.NetworkBlacklistFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload>[]
          }
          create: {
            args: Prisma.NetworkBlacklistCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload>
          }
          createMany: {
            args: Prisma.NetworkBlacklistCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NetworkBlacklistDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload>
          }
          update: {
            args: Prisma.NetworkBlacklistUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload>
          }
          deleteMany: {
            args: Prisma.NetworkBlacklistDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkBlacklistUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NetworkBlacklistUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NetworkBlacklistPayload>
          }
          aggregate: {
            args: Prisma.NetworkBlacklistAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNetworkBlacklist>
          }
          groupBy: {
            args: Prisma.NetworkBlacklistGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NetworkBlacklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkBlacklistCountArgs<ExtArgs>,
            result: $Utils.Optional<NetworkBlacklistCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      CharacterVersion: {
        payload: Prisma.$CharacterVersionPayload<ExtArgs>
        fields: Prisma.CharacterVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterVersionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterVersionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload>
          }
          findFirst: {
            args: Prisma.CharacterVersionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterVersionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload>
          }
          findMany: {
            args: Prisma.CharacterVersionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload>[]
          }
          create: {
            args: Prisma.CharacterVersionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload>
          }
          createMany: {
            args: Prisma.CharacterVersionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterVersionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload>
          }
          update: {
            args: Prisma.CharacterVersionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload>
          }
          deleteMany: {
            args: Prisma.CharacterVersionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterVersionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterVersionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterVersionPayload>
          }
          aggregate: {
            args: Prisma.CharacterVersionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterVersion>
          }
          groupBy: {
            args: Prisma.CharacterVersionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterVersionCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterVersionCountAggregateOutputType> | number
          }
        }
      }
      CharacterStat: {
        payload: Prisma.$CharacterStatPayload<ExtArgs>
        fields: Prisma.CharacterStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterStatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterStatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload>
          }
          findFirst: {
            args: Prisma.CharacterStatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterStatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload>
          }
          findMany: {
            args: Prisma.CharacterStatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload>[]
          }
          create: {
            args: Prisma.CharacterStatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload>
          }
          createMany: {
            args: Prisma.CharacterStatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterStatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload>
          }
          update: {
            args: Prisma.CharacterStatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload>
          }
          deleteMany: {
            args: Prisma.CharacterStatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterStatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterStatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterStatPayload>
          }
          aggregate: {
            args: Prisma.CharacterStatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterStat>
          }
          groupBy: {
            args: Prisma.CharacterStatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterStatCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterStatCountAggregateOutputType> | number
          }
        }
      }
      CharacterQuest: {
        payload: Prisma.$CharacterQuestPayload<ExtArgs>
        fields: Prisma.CharacterQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterQuestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterQuestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload>
          }
          findFirst: {
            args: Prisma.CharacterQuestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterQuestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload>
          }
          findMany: {
            args: Prisma.CharacterQuestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload>[]
          }
          create: {
            args: Prisma.CharacterQuestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload>
          }
          createMany: {
            args: Prisma.CharacterQuestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterQuestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload>
          }
          update: {
            args: Prisma.CharacterQuestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload>
          }
          deleteMany: {
            args: Prisma.CharacterQuestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterQuestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterQuestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterQuestPayload>
          }
          aggregate: {
            args: Prisma.CharacterQuestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterQuest>
          }
          groupBy: {
            args: Prisma.CharacterQuestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterQuestCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterQuestCountAggregateOutputType> | number
          }
        }
      }
      CharacterEquipment: {
        payload: Prisma.$CharacterEquipmentPayload<ExtArgs>
        fields: Prisma.CharacterEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterEquipmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterEquipmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          findFirst: {
            args: Prisma.CharacterEquipmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterEquipmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          findMany: {
            args: Prisma.CharacterEquipmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>[]
          }
          create: {
            args: Prisma.CharacterEquipmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          createMany: {
            args: Prisma.CharacterEquipmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterEquipmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          update: {
            args: Prisma.CharacterEquipmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.CharacterEquipmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterEquipmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterEquipmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          aggregate: {
            args: Prisma.CharacterEquipmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterEquipment>
          }
          groupBy: {
            args: Prisma.CharacterEquipmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterEquipmentCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterEquipmentCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ItemWeapon: {
        payload: Prisma.$ItemWeaponPayload<ExtArgs>
        fields: Prisma.ItemWeaponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemWeaponFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemWeaponFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload>
          }
          findFirst: {
            args: Prisma.ItemWeaponFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemWeaponFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload>
          }
          findMany: {
            args: Prisma.ItemWeaponFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload>[]
          }
          create: {
            args: Prisma.ItemWeaponCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload>
          }
          createMany: {
            args: Prisma.ItemWeaponCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemWeaponDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload>
          }
          update: {
            args: Prisma.ItemWeaponUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload>
          }
          deleteMany: {
            args: Prisma.ItemWeaponDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemWeaponUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemWeaponUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWeaponPayload>
          }
          aggregate: {
            args: Prisma.ItemWeaponAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemWeapon>
          }
          groupBy: {
            args: Prisma.ItemWeaponGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemWeaponGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemWeaponCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemWeaponCountAggregateOutputType> | number
          }
        }
      }
      ItemSpell: {
        payload: Prisma.$ItemSpellPayload<ExtArgs>
        fields: Prisma.ItemSpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemSpellFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemSpellFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload>
          }
          findFirst: {
            args: Prisma.ItemSpellFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemSpellFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload>
          }
          findMany: {
            args: Prisma.ItemSpellFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload>[]
          }
          create: {
            args: Prisma.ItemSpellCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload>
          }
          createMany: {
            args: Prisma.ItemSpellCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemSpellDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload>
          }
          update: {
            args: Prisma.ItemSpellUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload>
          }
          deleteMany: {
            args: Prisma.ItemSpellDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemSpellUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemSpellUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemSpellPayload>
          }
          aggregate: {
            args: Prisma.ItemSpellAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemSpell>
          }
          groupBy: {
            args: Prisma.ItemSpellGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemSpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemSpellCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemSpellCountAggregateOutputType> | number
          }
        }
      }
      Spell: {
        payload: Prisma.$SpellPayload<ExtArgs>
        fields: Prisma.SpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findFirst: {
            args: Prisma.SpellFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findMany: {
            args: Prisma.SpellFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>[]
          }
          create: {
            args: Prisma.SpellCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          createMany: {
            args: Prisma.SpellCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          update: {
            args: Prisma.SpellUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          deleteMany: {
            args: Prisma.SpellDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          aggregate: {
            args: Prisma.SpellAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpell>
          }
          groupBy: {
            args: Prisma.SpellGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellCountAggregateOutputType> | number
          }
        }
      }
      Potion: {
        payload: Prisma.$PotionPayload<ExtArgs>
        fields: Prisma.PotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PotionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PotionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload>
          }
          findFirst: {
            args: Prisma.PotionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PotionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload>
          }
          findMany: {
            args: Prisma.PotionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload>[]
          }
          create: {
            args: Prisma.PotionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload>
          }
          createMany: {
            args: Prisma.PotionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PotionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload>
          }
          update: {
            args: Prisma.PotionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload>
          }
          deleteMany: {
            args: Prisma.PotionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PotionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PotionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotionPayload>
          }
          aggregate: {
            args: Prisma.PotionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePotion>
          }
          groupBy: {
            args: Prisma.PotionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PotionCountArgs<ExtArgs>,
            result: $Utils.Optional<PotionCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>,
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      Ability: {
        payload: Prisma.$AbilityPayload<ExtArgs>
        fields: Prisma.AbilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbilityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbilityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          findFirst: {
            args: Prisma.AbilityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbilityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          findMany: {
            args: Prisma.AbilityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>[]
          }
          create: {
            args: Prisma.AbilityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          createMany: {
            args: Prisma.AbilityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AbilityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          update: {
            args: Prisma.AbilityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          deleteMany: {
            args: Prisma.AbilityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AbilityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AbilityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          aggregate: {
            args: Prisma.AbilityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAbility>
          }
          groupBy: {
            args: Prisma.AbilityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AbilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbilityCountArgs<ExtArgs>,
            result: $Utils.Optional<AbilityCountAggregateOutputType> | number
          }
        }
      }
      Quest: {
        payload: Prisma.$QuestPayload<ExtArgs>
        fields: Prisma.QuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findFirst: {
            args: Prisma.QuestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findMany: {
            args: Prisma.QuestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          create: {
            args: Prisma.QuestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          createMany: {
            args: Prisma.QuestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.QuestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          update: {
            args: Prisma.QuestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          deleteMany: {
            args: Prisma.QuestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          aggregate: {
            args: Prisma.QuestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuest>
          }
          groupBy: {
            args: Prisma.QuestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestCountArgs<ExtArgs>,
            result: $Utils.Optional<QuestCountAggregateOutputType> | number
          }
        }
      }
      StatModifer: {
        payload: Prisma.$StatModiferPayload<ExtArgs>
        fields: Prisma.StatModiferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatModiferFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatModiferFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload>
          }
          findFirst: {
            args: Prisma.StatModiferFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatModiferFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload>
          }
          findMany: {
            args: Prisma.StatModiferFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload>[]
          }
          create: {
            args: Prisma.StatModiferCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload>
          }
          createMany: {
            args: Prisma.StatModiferCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StatModiferDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload>
          }
          update: {
            args: Prisma.StatModiferUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload>
          }
          deleteMany: {
            args: Prisma.StatModiferDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StatModiferUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StatModiferUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatModiferPayload>
          }
          aggregate: {
            args: Prisma.StatModiferAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStatModifer>
          }
          groupBy: {
            args: Prisma.StatModiferGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StatModiferGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatModiferCountArgs<ExtArgs>,
            result: $Utils.Optional<StatModiferCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>,
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      ArticleVersion: {
        payload: Prisma.$ArticleVersionPayload<ExtArgs>
        fields: Prisma.ArticleVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleVersionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleVersionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          findFirst: {
            args: Prisma.ArticleVersionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleVersionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          findMany: {
            args: Prisma.ArticleVersionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>[]
          }
          create: {
            args: Prisma.ArticleVersionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          createMany: {
            args: Prisma.ArticleVersionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArticleVersionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          update: {
            args: Prisma.ArticleVersionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          deleteMany: {
            args: Prisma.ArticleVersionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleVersionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArticleVersionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          aggregate: {
            args: Prisma.ArticleVersionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArticleVersion>
          }
          groupBy: {
            args: Prisma.ArticleVersionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArticleVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleVersionCountArgs<ExtArgs>,
            result: $Utils.Optional<ArticleVersionCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>,
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      AppliedTag: {
        payload: Prisma.$AppliedTagPayload<ExtArgs>
        fields: Prisma.AppliedTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppliedTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppliedTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload>
          }
          findFirst: {
            args: Prisma.AppliedTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppliedTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload>
          }
          findMany: {
            args: Prisma.AppliedTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload>[]
          }
          create: {
            args: Prisma.AppliedTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload>
          }
          createMany: {
            args: Prisma.AppliedTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AppliedTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload>
          }
          update: {
            args: Prisma.AppliedTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload>
          }
          deleteMany: {
            args: Prisma.AppliedTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AppliedTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AppliedTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppliedTagPayload>
          }
          aggregate: {
            args: Prisma.AppliedTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppliedTag>
          }
          groupBy: {
            args: Prisma.AppliedTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppliedTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppliedTagCountArgs<ExtArgs>,
            result: $Utils.Optional<AppliedTagCountAggregateOutputType> | number
          }
        }
      }
      Mob: {
        payload: Prisma.$MobPayload<ExtArgs>
        fields: Prisma.MobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          findFirst: {
            args: Prisma.MobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          findMany: {
            args: Prisma.MobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>[]
          }
          create: {
            args: Prisma.MobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          createMany: {
            args: Prisma.MobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          update: {
            args: Prisma.MobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          deleteMany: {
            args: Prisma.MobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          aggregate: {
            args: Prisma.MobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMob>
          }
          groupBy: {
            args: Prisma.MobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobCountArgs<ExtArgs>,
            result: $Utils.Optional<MobCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>,
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      ChangeLog: {
        payload: Prisma.$ChangeLogPayload<ExtArgs>
        fields: Prisma.ChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findFirst: {
            args: Prisma.ChangeLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findMany: {
            args: Prisma.ChangeLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          create: {
            args: Prisma.ChangeLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          createMany: {
            args: Prisma.ChangeLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ChangeLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          update: {
            args: Prisma.ChangeLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.ChangeLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChangeLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          aggregate: {
            args: Prisma.ChangeLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChangeLog>
          }
          groupBy: {
            args: Prisma.ChangeLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeLogCountArgs<ExtArgs>,
            result: $Utils.Optional<ChangeLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    AccountNotification: number
    AccountPassword: number
    Character: number
    NetworkHistory: number
    NetworkBlacklist: number
    Notification: number
    CreatedItems: number
    ModifiedItems: number
    CreatedSpells: number
    ModifiedSpells: number
    CreatedPotions: number
    ModifiedPotions: number
    CreatedSkills: number
    ModifiedSkills: number
    CreatedAbilities: number
    ModifiedAbilities: number
    CreatedQuests: number
    ModifiedQuests: number
    Article: number
    ArticleVersion: number
    Tag: number
    Area: number
    ChangeLog: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccountNotification?: boolean | AccountCountOutputTypeCountAccountNotificationArgs
    AccountPassword?: boolean | AccountCountOutputTypeCountAccountPasswordArgs
    Character?: boolean | AccountCountOutputTypeCountCharacterArgs
    NetworkHistory?: boolean | AccountCountOutputTypeCountNetworkHistoryArgs
    NetworkBlacklist?: boolean | AccountCountOutputTypeCountNetworkBlacklistArgs
    Notification?: boolean | AccountCountOutputTypeCountNotificationArgs
    CreatedItems?: boolean | AccountCountOutputTypeCountCreatedItemsArgs
    ModifiedItems?: boolean | AccountCountOutputTypeCountModifiedItemsArgs
    CreatedSpells?: boolean | AccountCountOutputTypeCountCreatedSpellsArgs
    ModifiedSpells?: boolean | AccountCountOutputTypeCountModifiedSpellsArgs
    CreatedPotions?: boolean | AccountCountOutputTypeCountCreatedPotionsArgs
    ModifiedPotions?: boolean | AccountCountOutputTypeCountModifiedPotionsArgs
    CreatedSkills?: boolean | AccountCountOutputTypeCountCreatedSkillsArgs
    ModifiedSkills?: boolean | AccountCountOutputTypeCountModifiedSkillsArgs
    CreatedAbilities?: boolean | AccountCountOutputTypeCountCreatedAbilitiesArgs
    ModifiedAbilities?: boolean | AccountCountOutputTypeCountModifiedAbilitiesArgs
    CreatedQuests?: boolean | AccountCountOutputTypeCountCreatedQuestsArgs
    ModifiedQuests?: boolean | AccountCountOutputTypeCountModifiedQuestsArgs
    Article?: boolean | AccountCountOutputTypeCountArticleArgs
    ArticleVersion?: boolean | AccountCountOutputTypeCountArticleVersionArgs
    Tag?: boolean | AccountCountOutputTypeCountTagArgs
    Area?: boolean | AccountCountOutputTypeCountAreaArgs
    ChangeLog?: boolean | AccountCountOutputTypeCountChangeLogArgs
  }

  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAccountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountNotificationWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAccountPasswordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountPasswordWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountNetworkHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkHistoryWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountNetworkBlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkBlacklistWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCreatedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModifiedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCreatedSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModifiedSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCreatedPotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PotionWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModifiedPotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PotionWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCreatedSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModifiedSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCreatedAbilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbilityWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModifiedAbilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbilityWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCreatedQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountModifiedQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountArticleVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleVersionWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
  }



  /**
   * Count Type NetworkHistoryCountOutputType
   */

  export type NetworkHistoryCountOutputType = {
    NetworkBlacklist: number
  }

  export type NetworkHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NetworkBlacklist?: boolean | NetworkHistoryCountOutputTypeCountNetworkBlacklistArgs
  }

  // Custom InputTypes

  /**
   * NetworkHistoryCountOutputType without action
   */
  export type NetworkHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistoryCountOutputType
     */
    select?: NetworkHistoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NetworkHistoryCountOutputType without action
   */
  export type NetworkHistoryCountOutputTypeCountNetworkBlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkBlacklistWhereInput
  }



  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    CharacterVersion: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CharacterVersion?: boolean | CharacterCountOutputTypeCountCharacterVersionArgs
  }

  // Custom InputTypes

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountCharacterVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterVersionWhereInput
  }



  /**
   * Count Type CharacterVersionCountOutputType
   */

  export type CharacterVersionCountOutputType = {
    CharacterQuest: number
  }

  export type CharacterVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CharacterQuest?: boolean | CharacterVersionCountOutputTypeCountCharacterQuestArgs
  }

  // Custom InputTypes

  /**
   * CharacterVersionCountOutputType without action
   */
  export type CharacterVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersionCountOutputType
     */
    select?: CharacterVersionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CharacterVersionCountOutputType without action
   */
  export type CharacterVersionCountOutputTypeCountCharacterQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterQuestWhereInput
  }



  /**
   * Count Type CharacterEquipmentCountOutputType
   */

  export type CharacterEquipmentCountOutputType = {
    CharacterVersion: number
  }

  export type CharacterEquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CharacterVersion?: boolean | CharacterEquipmentCountOutputTypeCountCharacterVersionArgs
  }

  // Custom InputTypes

  /**
   * CharacterEquipmentCountOutputType without action
   */
  export type CharacterEquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipmentCountOutputType
     */
    select?: CharacterEquipmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CharacterEquipmentCountOutputType without action
   */
  export type CharacterEquipmentCountOutputTypeCountCharacterVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterVersionWhereInput
  }



  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    ItemSpell: number
    AmmoItem: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ItemSpell?: boolean | ItemCountOutputTypeCountItemSpellArgs
    AmmoItem?: boolean | ItemCountOutputTypeCountAmmoItemArgs
  }

  // Custom InputTypes

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountItemSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSpellWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountAmmoItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWeaponWhereInput
  }



  /**
   * Count Type SpellCountOutputType
   */

  export type SpellCountOutputType = {
    ItemSpell: number
  }

  export type SpellCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ItemSpell?: boolean | SpellCountOutputTypeCountItemSpellArgs
  }

  // Custom InputTypes

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellCountOutputType
     */
    select?: SpellCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountItemSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSpellWhereInput
  }



  /**
   * Count Type QuestCountOutputType
   */

  export type QuestCountOutputType = {
    CharacterQuest: number
  }

  export type QuestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CharacterQuest?: boolean | QuestCountOutputTypeCountCharacterQuestArgs
  }

  // Custom InputTypes

  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestCountOutputType
     */
    select?: QuestCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeCountCharacterQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterQuestWhereInput
  }



  /**
   * Count Type ArticleCountOutputType
   */

  export type ArticleCountOutputType = {
    ArticleContent: number
  }

  export type ArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ArticleContent?: boolean | ArticleCountOutputTypeCountArticleContentArgs
  }

  // Custom InputTypes

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountArticleContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleVersionWhereInput
  }



  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    AppliedTag: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AppliedTag?: boolean | TagCountOutputTypeCountAppliedTagArgs
  }

  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountAppliedTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppliedTagWhereInput
  }



  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    Mob: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mob?: boolean | AreaCountOutputTypeCountMobArgs
  }

  // Custom InputTypes

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountMobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    mudId: string | null
    createdDate: Date | null
    modifiedDate: Date | null
    firstName: string | null
    lastName: string | null
    email: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    mudId: string | null
    createdDate: Date | null
    modifiedDate: Date | null
    firstName: string | null
    lastName: string | null
    email: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    mudId: number
    createdDate: number
    modifiedDate: number
    firstName: number
    lastName: number
    email: number
    preferences: number
    roles: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    mudId?: true
    createdDate?: true
    modifiedDate?: true
    firstName?: true
    lastName?: true
    email?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    mudId?: true
    createdDate?: true
    modifiedDate?: true
    firstName?: true
    lastName?: true
    email?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    mudId?: true
    createdDate?: true
    modifiedDate?: true
    firstName?: true
    lastName?: true
    email?: true
    preferences?: true
    roles?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    mudId: string | null
    createdDate: Date
    modifiedDate: Date
    firstName: string | null
    lastName: string | null
    email: string
    preferences: JsonValue | null
    roles: JsonValue | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mudId?: boolean
    createdDate?: boolean
    modifiedDate?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    preferences?: boolean
    roles?: boolean
    AccountNotification?: boolean | Account$AccountNotificationArgs<ExtArgs>
    AccountPassword?: boolean | Account$AccountPasswordArgs<ExtArgs>
    Character?: boolean | Account$CharacterArgs<ExtArgs>
    NetworkHistory?: boolean | Account$NetworkHistoryArgs<ExtArgs>
    NetworkBlacklist?: boolean | Account$NetworkBlacklistArgs<ExtArgs>
    Notification?: boolean | Account$NotificationArgs<ExtArgs>
    CreatedItems?: boolean | Account$CreatedItemsArgs<ExtArgs>
    ModifiedItems?: boolean | Account$ModifiedItemsArgs<ExtArgs>
    CreatedSpells?: boolean | Account$CreatedSpellsArgs<ExtArgs>
    ModifiedSpells?: boolean | Account$ModifiedSpellsArgs<ExtArgs>
    CreatedPotions?: boolean | Account$CreatedPotionsArgs<ExtArgs>
    ModifiedPotions?: boolean | Account$ModifiedPotionsArgs<ExtArgs>
    CreatedSkills?: boolean | Account$CreatedSkillsArgs<ExtArgs>
    ModifiedSkills?: boolean | Account$ModifiedSkillsArgs<ExtArgs>
    CreatedAbilities?: boolean | Account$CreatedAbilitiesArgs<ExtArgs>
    ModifiedAbilities?: boolean | Account$ModifiedAbilitiesArgs<ExtArgs>
    CreatedQuests?: boolean | Account$CreatedQuestsArgs<ExtArgs>
    ModifiedQuests?: boolean | Account$ModifiedQuestsArgs<ExtArgs>
    Article?: boolean | Account$ArticleArgs<ExtArgs>
    ArticleVersion?: boolean | Account$ArticleVersionArgs<ExtArgs>
    Tag?: boolean | Account$TagArgs<ExtArgs>
    Area?: boolean | Account$AreaArgs<ExtArgs>
    ChangeLog?: boolean | Account$ChangeLogArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    mudId?: boolean
    createdDate?: boolean
    modifiedDate?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    preferences?: boolean
    roles?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AccountNotification?: boolean | Account$AccountNotificationArgs<ExtArgs>
    AccountPassword?: boolean | Account$AccountPasswordArgs<ExtArgs>
    Character?: boolean | Account$CharacterArgs<ExtArgs>
    NetworkHistory?: boolean | Account$NetworkHistoryArgs<ExtArgs>
    NetworkBlacklist?: boolean | Account$NetworkBlacklistArgs<ExtArgs>
    Notification?: boolean | Account$NotificationArgs<ExtArgs>
    CreatedItems?: boolean | Account$CreatedItemsArgs<ExtArgs>
    ModifiedItems?: boolean | Account$ModifiedItemsArgs<ExtArgs>
    CreatedSpells?: boolean | Account$CreatedSpellsArgs<ExtArgs>
    ModifiedSpells?: boolean | Account$ModifiedSpellsArgs<ExtArgs>
    CreatedPotions?: boolean | Account$CreatedPotionsArgs<ExtArgs>
    ModifiedPotions?: boolean | Account$ModifiedPotionsArgs<ExtArgs>
    CreatedSkills?: boolean | Account$CreatedSkillsArgs<ExtArgs>
    ModifiedSkills?: boolean | Account$ModifiedSkillsArgs<ExtArgs>
    CreatedAbilities?: boolean | Account$CreatedAbilitiesArgs<ExtArgs>
    ModifiedAbilities?: boolean | Account$ModifiedAbilitiesArgs<ExtArgs>
    CreatedQuests?: boolean | Account$CreatedQuestsArgs<ExtArgs>
    ModifiedQuests?: boolean | Account$ModifiedQuestsArgs<ExtArgs>
    Article?: boolean | Account$ArticleArgs<ExtArgs>
    ArticleVersion?: boolean | Account$ArticleVersionArgs<ExtArgs>
    Tag?: boolean | Account$TagArgs<ExtArgs>
    Area?: boolean | Account$AreaArgs<ExtArgs>
    ChangeLog?: boolean | Account$ChangeLogArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      AccountNotification: Prisma.$AccountNotificationPayload<ExtArgs>[]
      AccountPassword: Prisma.$AccountPasswordPayload<ExtArgs>[]
      Character: Prisma.$CharacterPayload<ExtArgs>[]
      NetworkHistory: Prisma.$NetworkHistoryPayload<ExtArgs>[]
      NetworkBlacklist: Prisma.$NetworkBlacklistPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      CreatedItems: Prisma.$ItemPayload<ExtArgs>[]
      ModifiedItems: Prisma.$ItemPayload<ExtArgs>[]
      CreatedSpells: Prisma.$SpellPayload<ExtArgs>[]
      ModifiedSpells: Prisma.$SpellPayload<ExtArgs>[]
      CreatedPotions: Prisma.$PotionPayload<ExtArgs>[]
      ModifiedPotions: Prisma.$PotionPayload<ExtArgs>[]
      CreatedSkills: Prisma.$SkillPayload<ExtArgs>[]
      ModifiedSkills: Prisma.$SkillPayload<ExtArgs>[]
      CreatedAbilities: Prisma.$AbilityPayload<ExtArgs>[]
      ModifiedAbilities: Prisma.$AbilityPayload<ExtArgs>[]
      CreatedQuests: Prisma.$QuestPayload<ExtArgs>[]
      ModifiedQuests: Prisma.$QuestPayload<ExtArgs>[]
      Article: Prisma.$ArticlePayload<ExtArgs>[]
      ArticleVersion: Prisma.$ArticleVersionPayload<ExtArgs>[]
      Tag: Prisma.$TagPayload<ExtArgs>[]
      Area: Prisma.$AreaPayload<ExtArgs>[]
      ChangeLog: Prisma.$ChangeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mudId: string | null
      createdDate: Date
      modifiedDate: Date
      firstName: string | null
      lastName: string | null
      email: string
      preferences: Prisma.JsonValue | null
      roles: Prisma.JsonValue | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    AccountNotification<T extends Account$AccountNotificationArgs<ExtArgs> = {}>(args?: Subset<T, Account$AccountNotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    AccountPassword<T extends Account$AccountPasswordArgs<ExtArgs> = {}>(args?: Subset<T, Account$AccountPasswordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'findMany'> | Null>;

    Character<T extends Account$CharacterArgs<ExtArgs> = {}>(args?: Subset<T, Account$CharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    NetworkHistory<T extends Account$NetworkHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Account$NetworkHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    NetworkBlacklist<T extends Account$NetworkBlacklistArgs<ExtArgs> = {}>(args?: Subset<T, Account$NetworkBlacklistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'findMany'> | Null>;

    Notification<T extends Account$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Account$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    CreatedItems<T extends Account$CreatedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Account$CreatedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    ModifiedItems<T extends Account$ModifiedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Account$ModifiedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    CreatedSpells<T extends Account$CreatedSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Account$CreatedSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    ModifiedSpells<T extends Account$ModifiedSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Account$ModifiedSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    CreatedPotions<T extends Account$CreatedPotionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$CreatedPotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findMany'> | Null>;

    ModifiedPotions<T extends Account$ModifiedPotionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$ModifiedPotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findMany'> | Null>;

    CreatedSkills<T extends Account$CreatedSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Account$CreatedSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    ModifiedSkills<T extends Account$ModifiedSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Account$ModifiedSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    CreatedAbilities<T extends Account$CreatedAbilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Account$CreatedAbilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findMany'> | Null>;

    ModifiedAbilities<T extends Account$ModifiedAbilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Account$ModifiedAbilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findMany'> | Null>;

    CreatedQuests<T extends Account$CreatedQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Account$CreatedQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findMany'> | Null>;

    ModifiedQuests<T extends Account$ModifiedQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Account$ModifiedQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findMany'> | Null>;

    Article<T extends Account$ArticleArgs<ExtArgs> = {}>(args?: Subset<T, Account$ArticleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'> | Null>;

    ArticleVersion<T extends Account$ArticleVersionArgs<ExtArgs> = {}>(args?: Subset<T, Account$ArticleVersionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'findMany'> | Null>;

    Tag<T extends Account$TagArgs<ExtArgs> = {}>(args?: Subset<T, Account$TagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'> | Null>;

    Area<T extends Account$AreaArgs<ExtArgs> = {}>(args?: Subset<T, Account$AreaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findMany'> | Null>;

    ChangeLog<T extends Account$ChangeLogArgs<ExtArgs> = {}>(args?: Subset<T, Account$ChangeLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly mudId: FieldRef<"Account", 'String'>
    readonly createdDate: FieldRef<"Account", 'DateTime'>
    readonly modifiedDate: FieldRef<"Account", 'DateTime'>
    readonly firstName: FieldRef<"Account", 'String'>
    readonly lastName: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly preferences: FieldRef<"Account", 'Json'>
    readonly roles: FieldRef<"Account", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account.AccountNotification
   */
  export type Account$AccountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    where?: AccountNotificationWhereInput
    orderBy?: AccountNotificationOrderByWithRelationInput | AccountNotificationOrderByWithRelationInput[]
    cursor?: AccountNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountNotificationScalarFieldEnum | AccountNotificationScalarFieldEnum[]
  }


  /**
   * Account.AccountPassword
   */
  export type Account$AccountPasswordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    where?: AccountPasswordWhereInput
    orderBy?: AccountPasswordOrderByWithRelationInput | AccountPasswordOrderByWithRelationInput[]
    cursor?: AccountPasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountPasswordScalarFieldEnum | AccountPasswordScalarFieldEnum[]
  }


  /**
   * Account.Character
   */
  export type Account$CharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Account.NetworkHistory
   */
  export type Account$NetworkHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    where?: NetworkHistoryWhereInput
    orderBy?: NetworkHistoryOrderByWithRelationInput | NetworkHistoryOrderByWithRelationInput[]
    cursor?: NetworkHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkHistoryScalarFieldEnum | NetworkHistoryScalarFieldEnum[]
  }


  /**
   * Account.NetworkBlacklist
   */
  export type Account$NetworkBlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    where?: NetworkBlacklistWhereInput
    orderBy?: NetworkBlacklistOrderByWithRelationInput | NetworkBlacklistOrderByWithRelationInput[]
    cursor?: NetworkBlacklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkBlacklistScalarFieldEnum | NetworkBlacklistScalarFieldEnum[]
  }


  /**
   * Account.Notification
   */
  export type Account$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Account.CreatedItems
   */
  export type Account$CreatedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Account.ModifiedItems
   */
  export type Account$ModifiedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Account.CreatedSpells
   */
  export type Account$CreatedSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    cursor?: SpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Account.ModifiedSpells
   */
  export type Account$ModifiedSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    cursor?: SpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Account.CreatedPotions
   */
  export type Account$CreatedPotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    where?: PotionWhereInput
    orderBy?: PotionOrderByWithRelationInput | PotionOrderByWithRelationInput[]
    cursor?: PotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PotionScalarFieldEnum | PotionScalarFieldEnum[]
  }


  /**
   * Account.ModifiedPotions
   */
  export type Account$ModifiedPotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    where?: PotionWhereInput
    orderBy?: PotionOrderByWithRelationInput | PotionOrderByWithRelationInput[]
    cursor?: PotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PotionScalarFieldEnum | PotionScalarFieldEnum[]
  }


  /**
   * Account.CreatedSkills
   */
  export type Account$CreatedSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Account.ModifiedSkills
   */
  export type Account$ModifiedSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Account.CreatedAbilities
   */
  export type Account$CreatedAbilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    where?: AbilityWhereInput
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    cursor?: AbilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }


  /**
   * Account.ModifiedAbilities
   */
  export type Account$ModifiedAbilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    where?: AbilityWhereInput
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    cursor?: AbilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }


  /**
   * Account.CreatedQuests
   */
  export type Account$CreatedQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }


  /**
   * Account.ModifiedQuests
   */
  export type Account$ModifiedQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }


  /**
   * Account.Article
   */
  export type Account$ArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Account.ArticleVersion
   */
  export type Account$ArticleVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    where?: ArticleVersionWhereInput
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    cursor?: ArticleVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }


  /**
   * Account.Tag
   */
  export type Account$TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Account.Area
   */
  export type Account$AreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    cursor?: AreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }


  /**
   * Account.ChangeLog
   */
  export type Account$ChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    cursor?: ChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model AccountNotification
   */

  export type AggregateAccountNotification = {
    _count: AccountNotificationCountAggregateOutputType | null
    _avg: AccountNotificationAvgAggregateOutputType | null
    _sum: AccountNotificationSumAggregateOutputType | null
    _min: AccountNotificationMinAggregateOutputType | null
    _max: AccountNotificationMaxAggregateOutputType | null
  }

  export type AccountNotificationAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    notificationId: number | null
  }

  export type AccountNotificationSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    notificationId: number | null
  }

  export type AccountNotificationMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    notificationId: number | null
    read: boolean | null
    readDate: Date | null
  }

  export type AccountNotificationMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    notificationId: number | null
    read: boolean | null
    readDate: Date | null
  }

  export type AccountNotificationCountAggregateOutputType = {
    id: number
    accountId: number
    notificationId: number
    read: number
    readDate: number
    _all: number
  }


  export type AccountNotificationAvgAggregateInputType = {
    id?: true
    accountId?: true
    notificationId?: true
  }

  export type AccountNotificationSumAggregateInputType = {
    id?: true
    accountId?: true
    notificationId?: true
  }

  export type AccountNotificationMinAggregateInputType = {
    id?: true
    accountId?: true
    notificationId?: true
    read?: true
    readDate?: true
  }

  export type AccountNotificationMaxAggregateInputType = {
    id?: true
    accountId?: true
    notificationId?: true
    read?: true
    readDate?: true
  }

  export type AccountNotificationCountAggregateInputType = {
    id?: true
    accountId?: true
    notificationId?: true
    read?: true
    readDate?: true
    _all?: true
  }

  export type AccountNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountNotification to aggregate.
     */
    where?: AccountNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountNotifications to fetch.
     */
    orderBy?: AccountNotificationOrderByWithRelationInput | AccountNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountNotifications
    **/
    _count?: true | AccountNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountNotificationMaxAggregateInputType
  }

  export type GetAccountNotificationAggregateType<T extends AccountNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountNotification[P]>
      : GetScalarType<T[P], AggregateAccountNotification[P]>
  }




  export type AccountNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountNotificationWhereInput
    orderBy?: AccountNotificationOrderByWithAggregationInput | AccountNotificationOrderByWithAggregationInput[]
    by: AccountNotificationScalarFieldEnum[] | AccountNotificationScalarFieldEnum
    having?: AccountNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountNotificationCountAggregateInputType | true
    _avg?: AccountNotificationAvgAggregateInputType
    _sum?: AccountNotificationSumAggregateInputType
    _min?: AccountNotificationMinAggregateInputType
    _max?: AccountNotificationMaxAggregateInputType
  }

  export type AccountNotificationGroupByOutputType = {
    id: number
    accountId: number
    notificationId: number
    read: boolean | null
    readDate: Date | null
    _count: AccountNotificationCountAggregateOutputType | null
    _avg: AccountNotificationAvgAggregateOutputType | null
    _sum: AccountNotificationSumAggregateOutputType | null
    _min: AccountNotificationMinAggregateOutputType | null
    _max: AccountNotificationMaxAggregateOutputType | null
  }

  type GetAccountNotificationGroupByPayload<T extends AccountNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], AccountNotificationGroupByOutputType[P]>
        }
      >
    >


  export type AccountNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    notificationId?: boolean
    read?: boolean
    readDate?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountNotification"]>

  export type AccountNotificationSelectScalar = {
    id?: boolean
    accountId?: boolean
    notificationId?: boolean
    read?: boolean
    readDate?: boolean
  }

  export type AccountNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }


  export type $AccountNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountNotification"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountId: number
      notificationId: number
      read: boolean | null
      readDate: Date | null
    }, ExtArgs["result"]["accountNotification"]>
    composites: {}
  }


  type AccountNotificationGetPayload<S extends boolean | null | undefined | AccountNotificationDefaultArgs> = $Result.GetResult<Prisma.$AccountNotificationPayload, S>

  type AccountNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountNotificationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AccountNotificationCountAggregateInputType | true
    }

  export interface AccountNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountNotification'], meta: { name: 'AccountNotification' } }
    /**
     * Find zero or one AccountNotification that matches the filter.
     * @param {AccountNotificationFindUniqueArgs} args - Arguments to find a AccountNotification
     * @example
     * // Get one AccountNotification
     * const accountNotification = await prisma.accountNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountNotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountNotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AccountNotification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountNotificationFindUniqueOrThrowArgs} args - Arguments to find a AccountNotification
     * @example
     * // Get one AccountNotification
     * const accountNotification = await prisma.accountNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountNotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountNotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AccountNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountNotificationFindFirstArgs} args - Arguments to find a AccountNotification
     * @example
     * // Get one AccountNotification
     * const accountNotification = await prisma.accountNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountNotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountNotificationFindFirstArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AccountNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountNotificationFindFirstOrThrowArgs} args - Arguments to find a AccountNotification
     * @example
     * // Get one AccountNotification
     * const accountNotification = await prisma.accountNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountNotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountNotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AccountNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountNotifications
     * const accountNotifications = await prisma.accountNotification.findMany()
     * 
     * // Get first 10 AccountNotifications
     * const accountNotifications = await prisma.accountNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountNotificationWithIdOnly = await prisma.accountNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountNotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountNotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AccountNotification.
     * @param {AccountNotificationCreateArgs} args - Arguments to create a AccountNotification.
     * @example
     * // Create one AccountNotification
     * const AccountNotification = await prisma.accountNotification.create({
     *   data: {
     *     // ... data to create a AccountNotification
     *   }
     * })
     * 
    **/
    create<T extends AccountNotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountNotificationCreateArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AccountNotifications.
     *     @param {AccountNotificationCreateManyArgs} args - Arguments to create many AccountNotifications.
     *     @example
     *     // Create many AccountNotifications
     *     const accountNotification = await prisma.accountNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountNotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountNotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountNotification.
     * @param {AccountNotificationDeleteArgs} args - Arguments to delete one AccountNotification.
     * @example
     * // Delete one AccountNotification
     * const AccountNotification = await prisma.accountNotification.delete({
     *   where: {
     *     // ... filter to delete one AccountNotification
     *   }
     * })
     * 
    **/
    delete<T extends AccountNotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountNotificationDeleteArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AccountNotification.
     * @param {AccountNotificationUpdateArgs} args - Arguments to update one AccountNotification.
     * @example
     * // Update one AccountNotification
     * const accountNotification = await prisma.accountNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountNotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountNotificationUpdateArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AccountNotifications.
     * @param {AccountNotificationDeleteManyArgs} args - Arguments to filter AccountNotifications to delete.
     * @example
     * // Delete a few AccountNotifications
     * const { count } = await prisma.accountNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountNotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountNotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountNotifications
     * const accountNotification = await prisma.accountNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountNotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountNotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountNotification.
     * @param {AccountNotificationUpsertArgs} args - Arguments to update or create a AccountNotification.
     * @example
     * // Update or create a AccountNotification
     * const accountNotification = await prisma.accountNotification.upsert({
     *   create: {
     *     // ... data to create a AccountNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountNotification we want to update
     *   }
     * })
    **/
    upsert<T extends AccountNotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountNotificationUpsertArgs<ExtArgs>>
    ): Prisma__AccountNotificationClient<$Result.GetResult<Prisma.$AccountNotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AccountNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountNotificationCountArgs} args - Arguments to filter AccountNotifications to count.
     * @example
     * // Count the number of AccountNotifications
     * const count = await prisma.accountNotification.count({
     *   where: {
     *     // ... the filter for the AccountNotifications we want to count
     *   }
     * })
    **/
    count<T extends AccountNotificationCountArgs>(
      args?: Subset<T, AccountNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountNotificationAggregateArgs>(args: Subset<T, AccountNotificationAggregateArgs>): Prisma.PrismaPromise<GetAccountNotificationAggregateType<T>>

    /**
     * Group by AccountNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountNotificationGroupByArgs['orderBy'] }
        : { orderBy?: AccountNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountNotification model
   */
  readonly fields: AccountNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AccountNotification model
   */ 
  interface AccountNotificationFieldRefs {
    readonly id: FieldRef<"AccountNotification", 'Int'>
    readonly accountId: FieldRef<"AccountNotification", 'Int'>
    readonly notificationId: FieldRef<"AccountNotification", 'Int'>
    readonly read: FieldRef<"AccountNotification", 'Boolean'>
    readonly readDate: FieldRef<"AccountNotification", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AccountNotification findUnique
   */
  export type AccountNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AccountNotification to fetch.
     */
    where: AccountNotificationWhereUniqueInput
  }


  /**
   * AccountNotification findUniqueOrThrow
   */
  export type AccountNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AccountNotification to fetch.
     */
    where: AccountNotificationWhereUniqueInput
  }


  /**
   * AccountNotification findFirst
   */
  export type AccountNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AccountNotification to fetch.
     */
    where?: AccountNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountNotifications to fetch.
     */
    orderBy?: AccountNotificationOrderByWithRelationInput | AccountNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountNotifications.
     */
    cursor?: AccountNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountNotifications.
     */
    distinct?: AccountNotificationScalarFieldEnum | AccountNotificationScalarFieldEnum[]
  }


  /**
   * AccountNotification findFirstOrThrow
   */
  export type AccountNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AccountNotification to fetch.
     */
    where?: AccountNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountNotifications to fetch.
     */
    orderBy?: AccountNotificationOrderByWithRelationInput | AccountNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountNotifications.
     */
    cursor?: AccountNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountNotifications.
     */
    distinct?: AccountNotificationScalarFieldEnum | AccountNotificationScalarFieldEnum[]
  }


  /**
   * AccountNotification findMany
   */
  export type AccountNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AccountNotifications to fetch.
     */
    where?: AccountNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountNotifications to fetch.
     */
    orderBy?: AccountNotificationOrderByWithRelationInput | AccountNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountNotifications.
     */
    cursor?: AccountNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountNotifications.
     */
    skip?: number
    distinct?: AccountNotificationScalarFieldEnum | AccountNotificationScalarFieldEnum[]
  }


  /**
   * AccountNotification create
   */
  export type AccountNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountNotification.
     */
    data: XOR<AccountNotificationCreateInput, AccountNotificationUncheckedCreateInput>
  }


  /**
   * AccountNotification createMany
   */
  export type AccountNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountNotifications.
     */
    data: AccountNotificationCreateManyInput | AccountNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AccountNotification update
   */
  export type AccountNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountNotification.
     */
    data: XOR<AccountNotificationUpdateInput, AccountNotificationUncheckedUpdateInput>
    /**
     * Choose, which AccountNotification to update.
     */
    where: AccountNotificationWhereUniqueInput
  }


  /**
   * AccountNotification updateMany
   */
  export type AccountNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountNotifications.
     */
    data: XOR<AccountNotificationUpdateManyMutationInput, AccountNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AccountNotifications to update
     */
    where?: AccountNotificationWhereInput
  }


  /**
   * AccountNotification upsert
   */
  export type AccountNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountNotification to update in case it exists.
     */
    where: AccountNotificationWhereUniqueInput
    /**
     * In case the AccountNotification found by the `where` argument doesn't exist, create a new AccountNotification with this data.
     */
    create: XOR<AccountNotificationCreateInput, AccountNotificationUncheckedCreateInput>
    /**
     * In case the AccountNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountNotificationUpdateInput, AccountNotificationUncheckedUpdateInput>
  }


  /**
   * AccountNotification delete
   */
  export type AccountNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
    /**
     * Filter which AccountNotification to delete.
     */
    where: AccountNotificationWhereUniqueInput
  }


  /**
   * AccountNotification deleteMany
   */
  export type AccountNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountNotifications to delete
     */
    where?: AccountNotificationWhereInput
  }


  /**
   * AccountNotification without action
   */
  export type AccountNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountNotification
     */
    select?: AccountNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountNotificationInclude<ExtArgs> | null
  }



  /**
   * Model AccountPassword
   */

  export type AggregateAccountPassword = {
    _count: AccountPasswordCountAggregateOutputType | null
    _avg: AccountPasswordAvgAggregateOutputType | null
    _sum: AccountPasswordSumAggregateOutputType | null
    _min: AccountPasswordMinAggregateOutputType | null
    _max: AccountPasswordMaxAggregateOutputType | null
  }

  export type AccountPasswordAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type AccountPasswordSumAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type AccountPasswordMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    passwordHash: string | null
  }

  export type AccountPasswordMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    passwordHash: string | null
  }

  export type AccountPasswordCountAggregateOutputType = {
    id: number
    accountId: number
    passwordHash: number
    _all: number
  }


  export type AccountPasswordAvgAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type AccountPasswordSumAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type AccountPasswordMinAggregateInputType = {
    id?: true
    accountId?: true
    passwordHash?: true
  }

  export type AccountPasswordMaxAggregateInputType = {
    id?: true
    accountId?: true
    passwordHash?: true
  }

  export type AccountPasswordCountAggregateInputType = {
    id?: true
    accountId?: true
    passwordHash?: true
    _all?: true
  }

  export type AccountPasswordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountPassword to aggregate.
     */
    where?: AccountPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountPasswords to fetch.
     */
    orderBy?: AccountPasswordOrderByWithRelationInput | AccountPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountPasswords
    **/
    _count?: true | AccountPasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountPasswordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountPasswordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountPasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountPasswordMaxAggregateInputType
  }

  export type GetAccountPasswordAggregateType<T extends AccountPasswordAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountPassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountPassword[P]>
      : GetScalarType<T[P], AggregateAccountPassword[P]>
  }




  export type AccountPasswordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountPasswordWhereInput
    orderBy?: AccountPasswordOrderByWithAggregationInput | AccountPasswordOrderByWithAggregationInput[]
    by: AccountPasswordScalarFieldEnum[] | AccountPasswordScalarFieldEnum
    having?: AccountPasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountPasswordCountAggregateInputType | true
    _avg?: AccountPasswordAvgAggregateInputType
    _sum?: AccountPasswordSumAggregateInputType
    _min?: AccountPasswordMinAggregateInputType
    _max?: AccountPasswordMaxAggregateInputType
  }

  export type AccountPasswordGroupByOutputType = {
    id: number
    accountId: number
    passwordHash: string
    _count: AccountPasswordCountAggregateOutputType | null
    _avg: AccountPasswordAvgAggregateOutputType | null
    _sum: AccountPasswordSumAggregateOutputType | null
    _min: AccountPasswordMinAggregateOutputType | null
    _max: AccountPasswordMaxAggregateOutputType | null
  }

  type GetAccountPasswordGroupByPayload<T extends AccountPasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountPasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountPasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountPasswordGroupByOutputType[P]>
            : GetScalarType<T[P], AccountPasswordGroupByOutputType[P]>
        }
      >
    >


  export type AccountPasswordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    passwordHash?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountPassword"]>

  export type AccountPasswordSelectScalar = {
    id?: boolean
    accountId?: boolean
    passwordHash?: boolean
  }

  export type AccountPasswordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }


  export type $AccountPasswordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountPassword"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountId: number
      passwordHash: string
    }, ExtArgs["result"]["accountPassword"]>
    composites: {}
  }


  type AccountPasswordGetPayload<S extends boolean | null | undefined | AccountPasswordDefaultArgs> = $Result.GetResult<Prisma.$AccountPasswordPayload, S>

  type AccountPasswordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountPasswordFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AccountPasswordCountAggregateInputType | true
    }

  export interface AccountPasswordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountPassword'], meta: { name: 'AccountPassword' } }
    /**
     * Find zero or one AccountPassword that matches the filter.
     * @param {AccountPasswordFindUniqueArgs} args - Arguments to find a AccountPassword
     * @example
     * // Get one AccountPassword
     * const accountPassword = await prisma.accountPassword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountPasswordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountPasswordFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AccountPassword that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountPasswordFindUniqueOrThrowArgs} args - Arguments to find a AccountPassword
     * @example
     * // Get one AccountPassword
     * const accountPassword = await prisma.accountPassword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountPasswordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountPasswordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AccountPassword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountPasswordFindFirstArgs} args - Arguments to find a AccountPassword
     * @example
     * // Get one AccountPassword
     * const accountPassword = await prisma.accountPassword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountPasswordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountPasswordFindFirstArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AccountPassword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountPasswordFindFirstOrThrowArgs} args - Arguments to find a AccountPassword
     * @example
     * // Get one AccountPassword
     * const accountPassword = await prisma.accountPassword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountPasswordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountPasswordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AccountPasswords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountPasswordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountPasswords
     * const accountPasswords = await prisma.accountPassword.findMany()
     * 
     * // Get first 10 AccountPasswords
     * const accountPasswords = await prisma.accountPassword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountPasswordWithIdOnly = await prisma.accountPassword.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountPasswordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountPasswordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AccountPassword.
     * @param {AccountPasswordCreateArgs} args - Arguments to create a AccountPassword.
     * @example
     * // Create one AccountPassword
     * const AccountPassword = await prisma.accountPassword.create({
     *   data: {
     *     // ... data to create a AccountPassword
     *   }
     * })
     * 
    **/
    create<T extends AccountPasswordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountPasswordCreateArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AccountPasswords.
     *     @param {AccountPasswordCreateManyArgs} args - Arguments to create many AccountPasswords.
     *     @example
     *     // Create many AccountPasswords
     *     const accountPassword = await prisma.accountPassword.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountPasswordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountPasswordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountPassword.
     * @param {AccountPasswordDeleteArgs} args - Arguments to delete one AccountPassword.
     * @example
     * // Delete one AccountPassword
     * const AccountPassword = await prisma.accountPassword.delete({
     *   where: {
     *     // ... filter to delete one AccountPassword
     *   }
     * })
     * 
    **/
    delete<T extends AccountPasswordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountPasswordDeleteArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AccountPassword.
     * @param {AccountPasswordUpdateArgs} args - Arguments to update one AccountPassword.
     * @example
     * // Update one AccountPassword
     * const accountPassword = await prisma.accountPassword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountPasswordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountPasswordUpdateArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AccountPasswords.
     * @param {AccountPasswordDeleteManyArgs} args - Arguments to filter AccountPasswords to delete.
     * @example
     * // Delete a few AccountPasswords
     * const { count } = await prisma.accountPassword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountPasswordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountPasswordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountPasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountPasswords
     * const accountPassword = await prisma.accountPassword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountPasswordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountPasswordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountPassword.
     * @param {AccountPasswordUpsertArgs} args - Arguments to update or create a AccountPassword.
     * @example
     * // Update or create a AccountPassword
     * const accountPassword = await prisma.accountPassword.upsert({
     *   create: {
     *     // ... data to create a AccountPassword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountPassword we want to update
     *   }
     * })
    **/
    upsert<T extends AccountPasswordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountPasswordUpsertArgs<ExtArgs>>
    ): Prisma__AccountPasswordClient<$Result.GetResult<Prisma.$AccountPasswordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AccountPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountPasswordCountArgs} args - Arguments to filter AccountPasswords to count.
     * @example
     * // Count the number of AccountPasswords
     * const count = await prisma.accountPassword.count({
     *   where: {
     *     // ... the filter for the AccountPasswords we want to count
     *   }
     * })
    **/
    count<T extends AccountPasswordCountArgs>(
      args?: Subset<T, AccountPasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountPasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountPasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountPasswordAggregateArgs>(args: Subset<T, AccountPasswordAggregateArgs>): Prisma.PrismaPromise<GetAccountPasswordAggregateType<T>>

    /**
     * Group by AccountPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountPasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountPasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountPasswordGroupByArgs['orderBy'] }
        : { orderBy?: AccountPasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountPasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountPassword model
   */
  readonly fields: AccountPasswordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountPassword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountPasswordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AccountPassword model
   */ 
  interface AccountPasswordFieldRefs {
    readonly id: FieldRef<"AccountPassword", 'Int'>
    readonly accountId: FieldRef<"AccountPassword", 'Int'>
    readonly passwordHash: FieldRef<"AccountPassword", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AccountPassword findUnique
   */
  export type AccountPasswordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * Filter, which AccountPassword to fetch.
     */
    where: AccountPasswordWhereUniqueInput
  }


  /**
   * AccountPassword findUniqueOrThrow
   */
  export type AccountPasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * Filter, which AccountPassword to fetch.
     */
    where: AccountPasswordWhereUniqueInput
  }


  /**
   * AccountPassword findFirst
   */
  export type AccountPasswordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * Filter, which AccountPassword to fetch.
     */
    where?: AccountPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountPasswords to fetch.
     */
    orderBy?: AccountPasswordOrderByWithRelationInput | AccountPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountPasswords.
     */
    cursor?: AccountPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountPasswords.
     */
    distinct?: AccountPasswordScalarFieldEnum | AccountPasswordScalarFieldEnum[]
  }


  /**
   * AccountPassword findFirstOrThrow
   */
  export type AccountPasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * Filter, which AccountPassword to fetch.
     */
    where?: AccountPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountPasswords to fetch.
     */
    orderBy?: AccountPasswordOrderByWithRelationInput | AccountPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountPasswords.
     */
    cursor?: AccountPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountPasswords.
     */
    distinct?: AccountPasswordScalarFieldEnum | AccountPasswordScalarFieldEnum[]
  }


  /**
   * AccountPassword findMany
   */
  export type AccountPasswordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * Filter, which AccountPasswords to fetch.
     */
    where?: AccountPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountPasswords to fetch.
     */
    orderBy?: AccountPasswordOrderByWithRelationInput | AccountPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountPasswords.
     */
    cursor?: AccountPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountPasswords.
     */
    skip?: number
    distinct?: AccountPasswordScalarFieldEnum | AccountPasswordScalarFieldEnum[]
  }


  /**
   * AccountPassword create
   */
  export type AccountPasswordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountPassword.
     */
    data: XOR<AccountPasswordCreateInput, AccountPasswordUncheckedCreateInput>
  }


  /**
   * AccountPassword createMany
   */
  export type AccountPasswordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountPasswords.
     */
    data: AccountPasswordCreateManyInput | AccountPasswordCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AccountPassword update
   */
  export type AccountPasswordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountPassword.
     */
    data: XOR<AccountPasswordUpdateInput, AccountPasswordUncheckedUpdateInput>
    /**
     * Choose, which AccountPassword to update.
     */
    where: AccountPasswordWhereUniqueInput
  }


  /**
   * AccountPassword updateMany
   */
  export type AccountPasswordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountPasswords.
     */
    data: XOR<AccountPasswordUpdateManyMutationInput, AccountPasswordUncheckedUpdateManyInput>
    /**
     * Filter which AccountPasswords to update
     */
    where?: AccountPasswordWhereInput
  }


  /**
   * AccountPassword upsert
   */
  export type AccountPasswordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountPassword to update in case it exists.
     */
    where: AccountPasswordWhereUniqueInput
    /**
     * In case the AccountPassword found by the `where` argument doesn't exist, create a new AccountPassword with this data.
     */
    create: XOR<AccountPasswordCreateInput, AccountPasswordUncheckedCreateInput>
    /**
     * In case the AccountPassword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountPasswordUpdateInput, AccountPasswordUncheckedUpdateInput>
  }


  /**
   * AccountPassword delete
   */
  export type AccountPasswordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
    /**
     * Filter which AccountPassword to delete.
     */
    where: AccountPasswordWhereUniqueInput
  }


  /**
   * AccountPassword deleteMany
   */
  export type AccountPasswordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountPasswords to delete
     */
    where?: AccountPasswordWhereInput
  }


  /**
   * AccountPassword without action
   */
  export type AccountPasswordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountPassword
     */
    select?: AccountPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountPasswordInclude<ExtArgs> | null
  }



  /**
   * Model NetworkHistory
   */

  export type AggregateNetworkHistory = {
    _count: NetworkHistoryCountAggregateOutputType | null
    _avg: NetworkHistoryAvgAggregateOutputType | null
    _sum: NetworkHistorySumAggregateOutputType | null
    _min: NetworkHistoryMinAggregateOutputType | null
    _max: NetworkHistoryMaxAggregateOutputType | null
  }

  export type NetworkHistoryAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type NetworkHistorySumAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type NetworkHistoryMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    createdDate: Date | null
    loginDate: Date | null
    ipAddress: string | null
  }

  export type NetworkHistoryMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    createdDate: Date | null
    loginDate: Date | null
    ipAddress: string | null
  }

  export type NetworkHistoryCountAggregateOutputType = {
    id: number
    accountId: number
    createdDate: number
    loginDate: number
    ipAddress: number
    _all: number
  }


  export type NetworkHistoryAvgAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type NetworkHistorySumAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type NetworkHistoryMinAggregateInputType = {
    id?: true
    accountId?: true
    createdDate?: true
    loginDate?: true
    ipAddress?: true
  }

  export type NetworkHistoryMaxAggregateInputType = {
    id?: true
    accountId?: true
    createdDate?: true
    loginDate?: true
    ipAddress?: true
  }

  export type NetworkHistoryCountAggregateInputType = {
    id?: true
    accountId?: true
    createdDate?: true
    loginDate?: true
    ipAddress?: true
    _all?: true
  }

  export type NetworkHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkHistory to aggregate.
     */
    where?: NetworkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkHistories to fetch.
     */
    orderBy?: NetworkHistoryOrderByWithRelationInput | NetworkHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkHistories
    **/
    _count?: true | NetworkHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NetworkHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NetworkHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkHistoryMaxAggregateInputType
  }

  export type GetNetworkHistoryAggregateType<T extends NetworkHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkHistory[P]>
      : GetScalarType<T[P], AggregateNetworkHistory[P]>
  }




  export type NetworkHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkHistoryWhereInput
    orderBy?: NetworkHistoryOrderByWithAggregationInput | NetworkHistoryOrderByWithAggregationInput[]
    by: NetworkHistoryScalarFieldEnum[] | NetworkHistoryScalarFieldEnum
    having?: NetworkHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkHistoryCountAggregateInputType | true
    _avg?: NetworkHistoryAvgAggregateInputType
    _sum?: NetworkHistorySumAggregateInputType
    _min?: NetworkHistoryMinAggregateInputType
    _max?: NetworkHistoryMaxAggregateInputType
  }

  export type NetworkHistoryGroupByOutputType = {
    id: number
    accountId: number
    createdDate: Date
    loginDate: Date
    ipAddress: string
    _count: NetworkHistoryCountAggregateOutputType | null
    _avg: NetworkHistoryAvgAggregateOutputType | null
    _sum: NetworkHistorySumAggregateOutputType | null
    _min: NetworkHistoryMinAggregateOutputType | null
    _max: NetworkHistoryMaxAggregateOutputType | null
  }

  type GetNetworkHistoryGroupByPayload<T extends NetworkHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkHistoryGroupByOutputType[P]>
        }
      >
    >


  export type NetworkHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    createdDate?: boolean
    loginDate?: boolean
    ipAddress?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    NetworkBlacklist?: boolean | NetworkHistory$NetworkBlacklistArgs<ExtArgs>
    _count?: boolean | NetworkHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkHistory"]>

  export type NetworkHistorySelectScalar = {
    id?: boolean
    accountId?: boolean
    createdDate?: boolean
    loginDate?: boolean
    ipAddress?: boolean
  }

  export type NetworkHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    NetworkBlacklist?: boolean | NetworkHistory$NetworkBlacklistArgs<ExtArgs>
    _count?: boolean | NetworkHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $NetworkHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkHistory"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
      NetworkBlacklist: Prisma.$NetworkBlacklistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountId: number
      createdDate: Date
      loginDate: Date
      ipAddress: string
    }, ExtArgs["result"]["networkHistory"]>
    composites: {}
  }


  type NetworkHistoryGetPayload<S extends boolean | null | undefined | NetworkHistoryDefaultArgs> = $Result.GetResult<Prisma.$NetworkHistoryPayload, S>

  type NetworkHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NetworkHistoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NetworkHistoryCountAggregateInputType | true
    }

  export interface NetworkHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkHistory'], meta: { name: 'NetworkHistory' } }
    /**
     * Find zero or one NetworkHistory that matches the filter.
     * @param {NetworkHistoryFindUniqueArgs} args - Arguments to find a NetworkHistory
     * @example
     * // Get one NetworkHistory
     * const networkHistory = await prisma.networkHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NetworkHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NetworkHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NetworkHistoryFindUniqueOrThrowArgs} args - Arguments to find a NetworkHistory
     * @example
     * // Get one NetworkHistory
     * const networkHistory = await prisma.networkHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NetworkHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NetworkHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkHistoryFindFirstArgs} args - Arguments to find a NetworkHistory
     * @example
     * // Get one NetworkHistory
     * const networkHistory = await prisma.networkHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NetworkHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NetworkHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkHistoryFindFirstOrThrowArgs} args - Arguments to find a NetworkHistory
     * @example
     * // Get one NetworkHistory
     * const networkHistory = await prisma.networkHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NetworkHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NetworkHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkHistories
     * const networkHistories = await prisma.networkHistory.findMany()
     * 
     * // Get first 10 NetworkHistories
     * const networkHistories = await prisma.networkHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkHistoryWithIdOnly = await prisma.networkHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NetworkHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NetworkHistory.
     * @param {NetworkHistoryCreateArgs} args - Arguments to create a NetworkHistory.
     * @example
     * // Create one NetworkHistory
     * const NetworkHistory = await prisma.networkHistory.create({
     *   data: {
     *     // ... data to create a NetworkHistory
     *   }
     * })
     * 
    **/
    create<T extends NetworkHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkHistoryCreateArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NetworkHistories.
     *     @param {NetworkHistoryCreateManyArgs} args - Arguments to create many NetworkHistories.
     *     @example
     *     // Create many NetworkHistories
     *     const networkHistory = await prisma.networkHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NetworkHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NetworkHistory.
     * @param {NetworkHistoryDeleteArgs} args - Arguments to delete one NetworkHistory.
     * @example
     * // Delete one NetworkHistory
     * const NetworkHistory = await prisma.networkHistory.delete({
     *   where: {
     *     // ... filter to delete one NetworkHistory
     *   }
     * })
     * 
    **/
    delete<T extends NetworkHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkHistoryDeleteArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NetworkHistory.
     * @param {NetworkHistoryUpdateArgs} args - Arguments to update one NetworkHistory.
     * @example
     * // Update one NetworkHistory
     * const networkHistory = await prisma.networkHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NetworkHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkHistoryUpdateArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NetworkHistories.
     * @param {NetworkHistoryDeleteManyArgs} args - Arguments to filter NetworkHistories to delete.
     * @example
     * // Delete a few NetworkHistories
     * const { count } = await prisma.networkHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NetworkHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkHistories
     * const networkHistory = await prisma.networkHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NetworkHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NetworkHistory.
     * @param {NetworkHistoryUpsertArgs} args - Arguments to update or create a NetworkHistory.
     * @example
     * // Update or create a NetworkHistory
     * const networkHistory = await prisma.networkHistory.upsert({
     *   create: {
     *     // ... data to create a NetworkHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkHistory we want to update
     *   }
     * })
    **/
    upsert<T extends NetworkHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkHistoryUpsertArgs<ExtArgs>>
    ): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NetworkHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkHistoryCountArgs} args - Arguments to filter NetworkHistories to count.
     * @example
     * // Count the number of NetworkHistories
     * const count = await prisma.networkHistory.count({
     *   where: {
     *     // ... the filter for the NetworkHistories we want to count
     *   }
     * })
    **/
    count<T extends NetworkHistoryCountArgs>(
      args?: Subset<T, NetworkHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkHistoryAggregateArgs>(args: Subset<T, NetworkHistoryAggregateArgs>): Prisma.PrismaPromise<GetNetworkHistoryAggregateType<T>>

    /**
     * Group by NetworkHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkHistoryGroupByArgs['orderBy'] }
        : { orderBy?: NetworkHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkHistory model
   */
  readonly fields: NetworkHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    NetworkBlacklist<T extends NetworkHistory$NetworkBlacklistArgs<ExtArgs> = {}>(args?: Subset<T, NetworkHistory$NetworkBlacklistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NetworkHistory model
   */ 
  interface NetworkHistoryFieldRefs {
    readonly id: FieldRef<"NetworkHistory", 'Int'>
    readonly accountId: FieldRef<"NetworkHistory", 'Int'>
    readonly createdDate: FieldRef<"NetworkHistory", 'DateTime'>
    readonly loginDate: FieldRef<"NetworkHistory", 'DateTime'>
    readonly ipAddress: FieldRef<"NetworkHistory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * NetworkHistory findUnique
   */
  export type NetworkHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NetworkHistory to fetch.
     */
    where: NetworkHistoryWhereUniqueInput
  }


  /**
   * NetworkHistory findUniqueOrThrow
   */
  export type NetworkHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NetworkHistory to fetch.
     */
    where: NetworkHistoryWhereUniqueInput
  }


  /**
   * NetworkHistory findFirst
   */
  export type NetworkHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NetworkHistory to fetch.
     */
    where?: NetworkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkHistories to fetch.
     */
    orderBy?: NetworkHistoryOrderByWithRelationInput | NetworkHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkHistories.
     */
    cursor?: NetworkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkHistories.
     */
    distinct?: NetworkHistoryScalarFieldEnum | NetworkHistoryScalarFieldEnum[]
  }


  /**
   * NetworkHistory findFirstOrThrow
   */
  export type NetworkHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NetworkHistory to fetch.
     */
    where?: NetworkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkHistories to fetch.
     */
    orderBy?: NetworkHistoryOrderByWithRelationInput | NetworkHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkHistories.
     */
    cursor?: NetworkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkHistories.
     */
    distinct?: NetworkHistoryScalarFieldEnum | NetworkHistoryScalarFieldEnum[]
  }


  /**
   * NetworkHistory findMany
   */
  export type NetworkHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * Filter, which NetworkHistories to fetch.
     */
    where?: NetworkHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkHistories to fetch.
     */
    orderBy?: NetworkHistoryOrderByWithRelationInput | NetworkHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkHistories.
     */
    cursor?: NetworkHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkHistories.
     */
    skip?: number
    distinct?: NetworkHistoryScalarFieldEnum | NetworkHistoryScalarFieldEnum[]
  }


  /**
   * NetworkHistory create
   */
  export type NetworkHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkHistory.
     */
    data: XOR<NetworkHistoryCreateInput, NetworkHistoryUncheckedCreateInput>
  }


  /**
   * NetworkHistory createMany
   */
  export type NetworkHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkHistories.
     */
    data: NetworkHistoryCreateManyInput | NetworkHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NetworkHistory update
   */
  export type NetworkHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkHistory.
     */
    data: XOR<NetworkHistoryUpdateInput, NetworkHistoryUncheckedUpdateInput>
    /**
     * Choose, which NetworkHistory to update.
     */
    where: NetworkHistoryWhereUniqueInput
  }


  /**
   * NetworkHistory updateMany
   */
  export type NetworkHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkHistories.
     */
    data: XOR<NetworkHistoryUpdateManyMutationInput, NetworkHistoryUncheckedUpdateManyInput>
    /**
     * Filter which NetworkHistories to update
     */
    where?: NetworkHistoryWhereInput
  }


  /**
   * NetworkHistory upsert
   */
  export type NetworkHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkHistory to update in case it exists.
     */
    where: NetworkHistoryWhereUniqueInput
    /**
     * In case the NetworkHistory found by the `where` argument doesn't exist, create a new NetworkHistory with this data.
     */
    create: XOR<NetworkHistoryCreateInput, NetworkHistoryUncheckedCreateInput>
    /**
     * In case the NetworkHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkHistoryUpdateInput, NetworkHistoryUncheckedUpdateInput>
  }


  /**
   * NetworkHistory delete
   */
  export type NetworkHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
    /**
     * Filter which NetworkHistory to delete.
     */
    where: NetworkHistoryWhereUniqueInput
  }


  /**
   * NetworkHistory deleteMany
   */
  export type NetworkHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkHistories to delete
     */
    where?: NetworkHistoryWhereInput
  }


  /**
   * NetworkHistory.NetworkBlacklist
   */
  export type NetworkHistory$NetworkBlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    where?: NetworkBlacklistWhereInput
    orderBy?: NetworkBlacklistOrderByWithRelationInput | NetworkBlacklistOrderByWithRelationInput[]
    cursor?: NetworkBlacklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkBlacklistScalarFieldEnum | NetworkBlacklistScalarFieldEnum[]
  }


  /**
   * NetworkHistory without action
   */
  export type NetworkHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkHistory
     */
    select?: NetworkHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkHistoryInclude<ExtArgs> | null
  }



  /**
   * Model NetworkBlacklist
   */

  export type AggregateNetworkBlacklist = {
    _count: NetworkBlacklistCountAggregateOutputType | null
    _avg: NetworkBlacklistAvgAggregateOutputType | null
    _sum: NetworkBlacklistSumAggregateOutputType | null
    _min: NetworkBlacklistMinAggregateOutputType | null
    _max: NetworkBlacklistMaxAggregateOutputType | null
  }

  export type NetworkBlacklistAvgAggregateOutputType = {
    id: number | null
    networkHistoryId: number | null
    issuer: number | null
  }

  export type NetworkBlacklistSumAggregateOutputType = {
    id: number | null
    networkHistoryId: number | null
    issuer: number | null
  }

  export type NetworkBlacklistMinAggregateOutputType = {
    id: number | null
    networkHistoryId: number | null
    issueDate: Date | null
    termDate: Date | null
    issuer: number | null
  }

  export type NetworkBlacklistMaxAggregateOutputType = {
    id: number | null
    networkHistoryId: number | null
    issueDate: Date | null
    termDate: Date | null
    issuer: number | null
  }

  export type NetworkBlacklistCountAggregateOutputType = {
    id: number
    networkHistoryId: number
    issueDate: number
    termDate: number
    issuer: number
    _all: number
  }


  export type NetworkBlacklistAvgAggregateInputType = {
    id?: true
    networkHistoryId?: true
    issuer?: true
  }

  export type NetworkBlacklistSumAggregateInputType = {
    id?: true
    networkHistoryId?: true
    issuer?: true
  }

  export type NetworkBlacklistMinAggregateInputType = {
    id?: true
    networkHistoryId?: true
    issueDate?: true
    termDate?: true
    issuer?: true
  }

  export type NetworkBlacklistMaxAggregateInputType = {
    id?: true
    networkHistoryId?: true
    issueDate?: true
    termDate?: true
    issuer?: true
  }

  export type NetworkBlacklistCountAggregateInputType = {
    id?: true
    networkHistoryId?: true
    issueDate?: true
    termDate?: true
    issuer?: true
    _all?: true
  }

  export type NetworkBlacklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkBlacklist to aggregate.
     */
    where?: NetworkBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkBlacklists to fetch.
     */
    orderBy?: NetworkBlacklistOrderByWithRelationInput | NetworkBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkBlacklists
    **/
    _count?: true | NetworkBlacklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NetworkBlacklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NetworkBlacklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkBlacklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkBlacklistMaxAggregateInputType
  }

  export type GetNetworkBlacklistAggregateType<T extends NetworkBlacklistAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkBlacklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkBlacklist[P]>
      : GetScalarType<T[P], AggregateNetworkBlacklist[P]>
  }




  export type NetworkBlacklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkBlacklistWhereInput
    orderBy?: NetworkBlacklistOrderByWithAggregationInput | NetworkBlacklistOrderByWithAggregationInput[]
    by: NetworkBlacklistScalarFieldEnum[] | NetworkBlacklistScalarFieldEnum
    having?: NetworkBlacklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkBlacklistCountAggregateInputType | true
    _avg?: NetworkBlacklistAvgAggregateInputType
    _sum?: NetworkBlacklistSumAggregateInputType
    _min?: NetworkBlacklistMinAggregateInputType
    _max?: NetworkBlacklistMaxAggregateInputType
  }

  export type NetworkBlacklistGroupByOutputType = {
    id: number
    networkHistoryId: number
    issueDate: Date
    termDate: Date
    issuer: number
    _count: NetworkBlacklistCountAggregateOutputType | null
    _avg: NetworkBlacklistAvgAggregateOutputType | null
    _sum: NetworkBlacklistSumAggregateOutputType | null
    _min: NetworkBlacklistMinAggregateOutputType | null
    _max: NetworkBlacklistMaxAggregateOutputType | null
  }

  type GetNetworkBlacklistGroupByPayload<T extends NetworkBlacklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkBlacklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkBlacklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkBlacklistGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkBlacklistGroupByOutputType[P]>
        }
      >
    >


  export type NetworkBlacklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    networkHistoryId?: boolean
    issueDate?: boolean
    termDate?: boolean
    issuer?: boolean
    NetworkHistory?: boolean | NetworkHistoryDefaultArgs<ExtArgs>
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkBlacklist"]>

  export type NetworkBlacklistSelectScalar = {
    id?: boolean
    networkHistoryId?: boolean
    issueDate?: boolean
    termDate?: boolean
    issuer?: boolean
  }

  export type NetworkBlacklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NetworkHistory?: boolean | NetworkHistoryDefaultArgs<ExtArgs>
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }


  export type $NetworkBlacklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkBlacklist"
    objects: {
      NetworkHistory: Prisma.$NetworkHistoryPayload<ExtArgs>
      Account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      networkHistoryId: number
      issueDate: Date
      termDate: Date
      issuer: number
    }, ExtArgs["result"]["networkBlacklist"]>
    composites: {}
  }


  type NetworkBlacklistGetPayload<S extends boolean | null | undefined | NetworkBlacklistDefaultArgs> = $Result.GetResult<Prisma.$NetworkBlacklistPayload, S>

  type NetworkBlacklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NetworkBlacklistFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NetworkBlacklistCountAggregateInputType | true
    }

  export interface NetworkBlacklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkBlacklist'], meta: { name: 'NetworkBlacklist' } }
    /**
     * Find zero or one NetworkBlacklist that matches the filter.
     * @param {NetworkBlacklistFindUniqueArgs} args - Arguments to find a NetworkBlacklist
     * @example
     * // Get one NetworkBlacklist
     * const networkBlacklist = await prisma.networkBlacklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NetworkBlacklistFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkBlacklistFindUniqueArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NetworkBlacklist that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NetworkBlacklistFindUniqueOrThrowArgs} args - Arguments to find a NetworkBlacklist
     * @example
     * // Get one NetworkBlacklist
     * const networkBlacklist = await prisma.networkBlacklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NetworkBlacklistFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkBlacklistFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NetworkBlacklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkBlacklistFindFirstArgs} args - Arguments to find a NetworkBlacklist
     * @example
     * // Get one NetworkBlacklist
     * const networkBlacklist = await prisma.networkBlacklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NetworkBlacklistFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkBlacklistFindFirstArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NetworkBlacklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkBlacklistFindFirstOrThrowArgs} args - Arguments to find a NetworkBlacklist
     * @example
     * // Get one NetworkBlacklist
     * const networkBlacklist = await prisma.networkBlacklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NetworkBlacklistFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkBlacklistFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NetworkBlacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkBlacklistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkBlacklists
     * const networkBlacklists = await prisma.networkBlacklist.findMany()
     * 
     * // Get first 10 NetworkBlacklists
     * const networkBlacklists = await prisma.networkBlacklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkBlacklistWithIdOnly = await prisma.networkBlacklist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NetworkBlacklistFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkBlacklistFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NetworkBlacklist.
     * @param {NetworkBlacklistCreateArgs} args - Arguments to create a NetworkBlacklist.
     * @example
     * // Create one NetworkBlacklist
     * const NetworkBlacklist = await prisma.networkBlacklist.create({
     *   data: {
     *     // ... data to create a NetworkBlacklist
     *   }
     * })
     * 
    **/
    create<T extends NetworkBlacklistCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkBlacklistCreateArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NetworkBlacklists.
     *     @param {NetworkBlacklistCreateManyArgs} args - Arguments to create many NetworkBlacklists.
     *     @example
     *     // Create many NetworkBlacklists
     *     const networkBlacklist = await prisma.networkBlacklist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NetworkBlacklistCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkBlacklistCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NetworkBlacklist.
     * @param {NetworkBlacklistDeleteArgs} args - Arguments to delete one NetworkBlacklist.
     * @example
     * // Delete one NetworkBlacklist
     * const NetworkBlacklist = await prisma.networkBlacklist.delete({
     *   where: {
     *     // ... filter to delete one NetworkBlacklist
     *   }
     * })
     * 
    **/
    delete<T extends NetworkBlacklistDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkBlacklistDeleteArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NetworkBlacklist.
     * @param {NetworkBlacklistUpdateArgs} args - Arguments to update one NetworkBlacklist.
     * @example
     * // Update one NetworkBlacklist
     * const networkBlacklist = await prisma.networkBlacklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NetworkBlacklistUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkBlacklistUpdateArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NetworkBlacklists.
     * @param {NetworkBlacklistDeleteManyArgs} args - Arguments to filter NetworkBlacklists to delete.
     * @example
     * // Delete a few NetworkBlacklists
     * const { count } = await prisma.networkBlacklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NetworkBlacklistDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NetworkBlacklistDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkBlacklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkBlacklists
     * const networkBlacklist = await prisma.networkBlacklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NetworkBlacklistUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkBlacklistUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NetworkBlacklist.
     * @param {NetworkBlacklistUpsertArgs} args - Arguments to update or create a NetworkBlacklist.
     * @example
     * // Update or create a NetworkBlacklist
     * const networkBlacklist = await prisma.networkBlacklist.upsert({
     *   create: {
     *     // ... data to create a NetworkBlacklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkBlacklist we want to update
     *   }
     * })
    **/
    upsert<T extends NetworkBlacklistUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NetworkBlacklistUpsertArgs<ExtArgs>>
    ): Prisma__NetworkBlacklistClient<$Result.GetResult<Prisma.$NetworkBlacklistPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NetworkBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkBlacklistCountArgs} args - Arguments to filter NetworkBlacklists to count.
     * @example
     * // Count the number of NetworkBlacklists
     * const count = await prisma.networkBlacklist.count({
     *   where: {
     *     // ... the filter for the NetworkBlacklists we want to count
     *   }
     * })
    **/
    count<T extends NetworkBlacklistCountArgs>(
      args?: Subset<T, NetworkBlacklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkBlacklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkBlacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkBlacklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkBlacklistAggregateArgs>(args: Subset<T, NetworkBlacklistAggregateArgs>): Prisma.PrismaPromise<GetNetworkBlacklistAggregateType<T>>

    /**
     * Group by NetworkBlacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkBlacklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkBlacklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkBlacklistGroupByArgs['orderBy'] }
        : { orderBy?: NetworkBlacklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkBlacklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkBlacklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkBlacklist model
   */
  readonly fields: NetworkBlacklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkBlacklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkBlacklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    NetworkHistory<T extends NetworkHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NetworkHistoryDefaultArgs<ExtArgs>>): Prisma__NetworkHistoryClient<$Result.GetResult<Prisma.$NetworkHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NetworkBlacklist model
   */ 
  interface NetworkBlacklistFieldRefs {
    readonly id: FieldRef<"NetworkBlacklist", 'Int'>
    readonly networkHistoryId: FieldRef<"NetworkBlacklist", 'Int'>
    readonly issueDate: FieldRef<"NetworkBlacklist", 'DateTime'>
    readonly termDate: FieldRef<"NetworkBlacklist", 'DateTime'>
    readonly issuer: FieldRef<"NetworkBlacklist", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * NetworkBlacklist findUnique
   */
  export type NetworkBlacklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * Filter, which NetworkBlacklist to fetch.
     */
    where: NetworkBlacklistWhereUniqueInput
  }


  /**
   * NetworkBlacklist findUniqueOrThrow
   */
  export type NetworkBlacklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * Filter, which NetworkBlacklist to fetch.
     */
    where: NetworkBlacklistWhereUniqueInput
  }


  /**
   * NetworkBlacklist findFirst
   */
  export type NetworkBlacklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * Filter, which NetworkBlacklist to fetch.
     */
    where?: NetworkBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkBlacklists to fetch.
     */
    orderBy?: NetworkBlacklistOrderByWithRelationInput | NetworkBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkBlacklists.
     */
    cursor?: NetworkBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkBlacklists.
     */
    distinct?: NetworkBlacklistScalarFieldEnum | NetworkBlacklistScalarFieldEnum[]
  }


  /**
   * NetworkBlacklist findFirstOrThrow
   */
  export type NetworkBlacklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * Filter, which NetworkBlacklist to fetch.
     */
    where?: NetworkBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkBlacklists to fetch.
     */
    orderBy?: NetworkBlacklistOrderByWithRelationInput | NetworkBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkBlacklists.
     */
    cursor?: NetworkBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkBlacklists.
     */
    distinct?: NetworkBlacklistScalarFieldEnum | NetworkBlacklistScalarFieldEnum[]
  }


  /**
   * NetworkBlacklist findMany
   */
  export type NetworkBlacklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * Filter, which NetworkBlacklists to fetch.
     */
    where?: NetworkBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkBlacklists to fetch.
     */
    orderBy?: NetworkBlacklistOrderByWithRelationInput | NetworkBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkBlacklists.
     */
    cursor?: NetworkBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkBlacklists.
     */
    skip?: number
    distinct?: NetworkBlacklistScalarFieldEnum | NetworkBlacklistScalarFieldEnum[]
  }


  /**
   * NetworkBlacklist create
   */
  export type NetworkBlacklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkBlacklist.
     */
    data: XOR<NetworkBlacklistCreateInput, NetworkBlacklistUncheckedCreateInput>
  }


  /**
   * NetworkBlacklist createMany
   */
  export type NetworkBlacklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkBlacklists.
     */
    data: NetworkBlacklistCreateManyInput | NetworkBlacklistCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NetworkBlacklist update
   */
  export type NetworkBlacklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkBlacklist.
     */
    data: XOR<NetworkBlacklistUpdateInput, NetworkBlacklistUncheckedUpdateInput>
    /**
     * Choose, which NetworkBlacklist to update.
     */
    where: NetworkBlacklistWhereUniqueInput
  }


  /**
   * NetworkBlacklist updateMany
   */
  export type NetworkBlacklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkBlacklists.
     */
    data: XOR<NetworkBlacklistUpdateManyMutationInput, NetworkBlacklistUncheckedUpdateManyInput>
    /**
     * Filter which NetworkBlacklists to update
     */
    where?: NetworkBlacklistWhereInput
  }


  /**
   * NetworkBlacklist upsert
   */
  export type NetworkBlacklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkBlacklist to update in case it exists.
     */
    where: NetworkBlacklistWhereUniqueInput
    /**
     * In case the NetworkBlacklist found by the `where` argument doesn't exist, create a new NetworkBlacklist with this data.
     */
    create: XOR<NetworkBlacklistCreateInput, NetworkBlacklistUncheckedCreateInput>
    /**
     * In case the NetworkBlacklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkBlacklistUpdateInput, NetworkBlacklistUncheckedUpdateInput>
  }


  /**
   * NetworkBlacklist delete
   */
  export type NetworkBlacklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
    /**
     * Filter which NetworkBlacklist to delete.
     */
    where: NetworkBlacklistWhereUniqueInput
  }


  /**
   * NetworkBlacklist deleteMany
   */
  export type NetworkBlacklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkBlacklists to delete
     */
    where?: NetworkBlacklistWhereInput
  }


  /**
   * NetworkBlacklist without action
   */
  export type NetworkBlacklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkBlacklist
     */
    select?: NetworkBlacklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NetworkBlacklistInclude<ExtArgs> | null
  }



  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    type: $Enums.NotificationType | null
    title: string | null
    description: string | null
    content: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    type: $Enums.NotificationType | null
    title: string | null
    description: string | null
    content: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    type: number
    title: number
    description: number
    content: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    type?: true
    title?: true
    description?: true
    content?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    type?: true
    title?: true
    description?: true
    content?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    type?: true
    title?: true
    description?: true
    content?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    type: $Enums.NotificationType
    title: string
    description: string | null
    content: string | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      type: $Enums.NotificationType
      title: string
      description: string | null
      content: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly createdDate: FieldRef<"Notification", 'DateTime'>
    readonly createdBy: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly description: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
  }



  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    id: number | null
    mudId: number | null
    accountId: number | null
    level: number | null
  }

  export type CharacterSumAggregateOutputType = {
    id: number | null
    mudId: number | null
    accountId: number | null
    level: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: number | null
    mudId: number | null
    accountId: number | null
    createdDate: Date | null
    modifiedDate: Date | null
    name: string | null
    description: string | null
    level: number | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: number | null
    mudId: number | null
    accountId: number | null
    createdDate: Date | null
    modifiedDate: Date | null
    name: string | null
    description: string | null
    level: number | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    mudId: number
    accountId: number
    createdDate: number
    modifiedDate: number
    name: number
    description: number
    level: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    id?: true
    mudId?: true
    accountId?: true
    level?: true
  }

  export type CharacterSumAggregateInputType = {
    id?: true
    mudId?: true
    accountId?: true
    level?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    mudId?: true
    accountId?: true
    createdDate?: true
    modifiedDate?: true
    name?: true
    description?: true
    level?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    mudId?: true
    accountId?: true
    createdDate?: true
    modifiedDate?: true
    name?: true
    description?: true
    level?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    mudId?: true
    accountId?: true
    createdDate?: true
    modifiedDate?: true
    name?: true
    description?: true
    level?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: number
    mudId: number | null
    accountId: number
    createdDate: Date
    modifiedDate: Date
    name: string
    description: string | null
    level: number | null
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mudId?: boolean
    accountId?: boolean
    createdDate?: boolean
    modifiedDate?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    CharacterVersion?: boolean | Character$CharacterVersionArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    mudId?: boolean
    accountId?: boolean
    createdDate?: boolean
    modifiedDate?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
  }

  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    CharacterVersion?: boolean | Character$CharacterVersionArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
      CharacterVersion: Prisma.$CharacterVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mudId: number | null
      accountId: number
      createdDate: Date
      modifiedDate: Date
      name: string
      description: string | null
      level: number | null
    }, ExtArgs["result"]["character"]>
    composites: {}
  }


  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Character that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
    **/
    create<T extends CharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Characters.
     *     @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     *     @example
     *     // Create many Characters
     *     const character = await prisma.character.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
    **/
    delete<T extends CharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    CharacterVersion<T extends Character$CharacterVersionArgs<ExtArgs> = {}>(args?: Subset<T, Character$CharacterVersionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Character model
   */ 
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'Int'>
    readonly mudId: FieldRef<"Character", 'Int'>
    readonly accountId: FieldRef<"Character", 'Int'>
    readonly createdDate: FieldRef<"Character", 'DateTime'>
    readonly modifiedDate: FieldRef<"Character", 'DateTime'>
    readonly name: FieldRef<"Character", 'String'>
    readonly description: FieldRef<"Character", 'String'>
    readonly level: FieldRef<"Character", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }


  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
  }


  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }


  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
  }


  /**
   * Character.CharacterVersion
   */
  export type Character$CharacterVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    where?: CharacterVersionWhereInput
    orderBy?: CharacterVersionOrderByWithRelationInput | CharacterVersionOrderByWithRelationInput[]
    cursor?: CharacterVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterVersionScalarFieldEnum | CharacterVersionScalarFieldEnum[]
  }


  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
  }



  /**
   * Model CharacterVersion
   */

  export type AggregateCharacterVersion = {
    _count: CharacterVersionCountAggregateOutputType | null
    _avg: CharacterVersionAvgAggregateOutputType | null
    _sum: CharacterVersionSumAggregateOutputType | null
    _min: CharacterVersionMinAggregateOutputType | null
    _max: CharacterVersionMaxAggregateOutputType | null
  }

  export type CharacterVersionAvgAggregateOutputType = {
    id: number | null
    characterId: number | null
    equipmentId: number | null
    statsId: number | null
    characterEquipmentId: number | null
  }

  export type CharacterVersionSumAggregateOutputType = {
    id: number | null
    characterId: number | null
    equipmentId: number | null
    statsId: number | null
    characterEquipmentId: number | null
  }

  export type CharacterVersionMinAggregateOutputType = {
    id: number | null
    characterId: number | null
    equipmentId: number | null
    statsId: number | null
    createdDate: Date | null
    modifiedDate: Date | null
    version: string | null
    hometown: string | null
    characterEquipmentId: number | null
  }

  export type CharacterVersionMaxAggregateOutputType = {
    id: number | null
    characterId: number | null
    equipmentId: number | null
    statsId: number | null
    createdDate: Date | null
    modifiedDate: Date | null
    version: string | null
    hometown: string | null
    characterEquipmentId: number | null
  }

  export type CharacterVersionCountAggregateOutputType = {
    id: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate: number
    modifiedDate: number
    version: number
    hometown: number
    characterEquipmentId: number
    _all: number
  }


  export type CharacterVersionAvgAggregateInputType = {
    id?: true
    characterId?: true
    equipmentId?: true
    statsId?: true
    characterEquipmentId?: true
  }

  export type CharacterVersionSumAggregateInputType = {
    id?: true
    characterId?: true
    equipmentId?: true
    statsId?: true
    characterEquipmentId?: true
  }

  export type CharacterVersionMinAggregateInputType = {
    id?: true
    characterId?: true
    equipmentId?: true
    statsId?: true
    createdDate?: true
    modifiedDate?: true
    version?: true
    hometown?: true
    characterEquipmentId?: true
  }

  export type CharacterVersionMaxAggregateInputType = {
    id?: true
    characterId?: true
    equipmentId?: true
    statsId?: true
    createdDate?: true
    modifiedDate?: true
    version?: true
    hometown?: true
    characterEquipmentId?: true
  }

  export type CharacterVersionCountAggregateInputType = {
    id?: true
    characterId?: true
    equipmentId?: true
    statsId?: true
    createdDate?: true
    modifiedDate?: true
    version?: true
    hometown?: true
    characterEquipmentId?: true
    _all?: true
  }

  export type CharacterVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterVersion to aggregate.
     */
    where?: CharacterVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVersions to fetch.
     */
    orderBy?: CharacterVersionOrderByWithRelationInput | CharacterVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterVersions
    **/
    _count?: true | CharacterVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterVersionMaxAggregateInputType
  }

  export type GetCharacterVersionAggregateType<T extends CharacterVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterVersion[P]>
      : GetScalarType<T[P], AggregateCharacterVersion[P]>
  }




  export type CharacterVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterVersionWhereInput
    orderBy?: CharacterVersionOrderByWithAggregationInput | CharacterVersionOrderByWithAggregationInput[]
    by: CharacterVersionScalarFieldEnum[] | CharacterVersionScalarFieldEnum
    having?: CharacterVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterVersionCountAggregateInputType | true
    _avg?: CharacterVersionAvgAggregateInputType
    _sum?: CharacterVersionSumAggregateInputType
    _min?: CharacterVersionMinAggregateInputType
    _max?: CharacterVersionMaxAggregateInputType
  }

  export type CharacterVersionGroupByOutputType = {
    id: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate: Date
    modifiedDate: Date
    version: string
    hometown: string | null
    characterEquipmentId: number | null
    _count: CharacterVersionCountAggregateOutputType | null
    _avg: CharacterVersionAvgAggregateOutputType | null
    _sum: CharacterVersionSumAggregateOutputType | null
    _min: CharacterVersionMinAggregateOutputType | null
    _max: CharacterVersionMaxAggregateOutputType | null
  }

  type GetCharacterVersionGroupByPayload<T extends CharacterVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterVersionGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterVersionGroupByOutputType[P]>
        }
      >
    >


  export type CharacterVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    equipmentId?: boolean
    statsId?: boolean
    createdDate?: boolean
    modifiedDate?: boolean
    version?: boolean
    hometown?: boolean
    characterEquipmentId?: boolean
    Character?: boolean | CharacterDefaultArgs<ExtArgs>
    CharacterStat?: boolean | CharacterVersion$CharacterStatArgs<ExtArgs>
    CharacterQuest?: boolean | CharacterVersion$CharacterQuestArgs<ExtArgs>
    CharacterEquipment?: boolean | CharacterVersion$CharacterEquipmentArgs<ExtArgs>
    _count?: boolean | CharacterVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterVersion"]>

  export type CharacterVersionSelectScalar = {
    id?: boolean
    characterId?: boolean
    equipmentId?: boolean
    statsId?: boolean
    createdDate?: boolean
    modifiedDate?: boolean
    version?: boolean
    hometown?: boolean
    characterEquipmentId?: boolean
  }

  export type CharacterVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Character?: boolean | CharacterDefaultArgs<ExtArgs>
    CharacterStat?: boolean | CharacterVersion$CharacterStatArgs<ExtArgs>
    CharacterQuest?: boolean | CharacterVersion$CharacterQuestArgs<ExtArgs>
    CharacterEquipment?: boolean | CharacterVersion$CharacterEquipmentArgs<ExtArgs>
    _count?: boolean | CharacterVersionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CharacterVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterVersion"
    objects: {
      Character: Prisma.$CharacterPayload<ExtArgs>
      CharacterStat: Prisma.$CharacterStatPayload<ExtArgs> | null
      CharacterQuest: Prisma.$CharacterQuestPayload<ExtArgs>[]
      CharacterEquipment: Prisma.$CharacterEquipmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      characterId: number
      equipmentId: number
      statsId: number
      createdDate: Date
      modifiedDate: Date
      version: string
      hometown: string | null
      characterEquipmentId: number | null
    }, ExtArgs["result"]["characterVersion"]>
    composites: {}
  }


  type CharacterVersionGetPayload<S extends boolean | null | undefined | CharacterVersionDefaultArgs> = $Result.GetResult<Prisma.$CharacterVersionPayload, S>

  type CharacterVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterVersionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CharacterVersionCountAggregateInputType | true
    }

  export interface CharacterVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterVersion'], meta: { name: 'CharacterVersion' } }
    /**
     * Find zero or one CharacterVersion that matches the filter.
     * @param {CharacterVersionFindUniqueArgs} args - Arguments to find a CharacterVersion
     * @example
     * // Get one CharacterVersion
     * const characterVersion = await prisma.characterVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterVersionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterVersionFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterVersion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterVersionFindUniqueOrThrowArgs} args - Arguments to find a CharacterVersion
     * @example
     * // Get one CharacterVersion
     * const characterVersion = await prisma.characterVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterVersionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterVersionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVersionFindFirstArgs} args - Arguments to find a CharacterVersion
     * @example
     * // Get one CharacterVersion
     * const characterVersion = await prisma.characterVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterVersionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterVersionFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVersionFindFirstOrThrowArgs} args - Arguments to find a CharacterVersion
     * @example
     * // Get one CharacterVersion
     * const characterVersion = await prisma.characterVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterVersionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterVersionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterVersions
     * const characterVersions = await prisma.characterVersion.findMany()
     * 
     * // Get first 10 CharacterVersions
     * const characterVersions = await prisma.characterVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterVersionWithIdOnly = await prisma.characterVersion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterVersionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterVersionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterVersion.
     * @param {CharacterVersionCreateArgs} args - Arguments to create a CharacterVersion.
     * @example
     * // Create one CharacterVersion
     * const CharacterVersion = await prisma.characterVersion.create({
     *   data: {
     *     // ... data to create a CharacterVersion
     *   }
     * })
     * 
    **/
    create<T extends CharacterVersionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterVersionCreateArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterVersions.
     *     @param {CharacterVersionCreateManyArgs} args - Arguments to create many CharacterVersions.
     *     @example
     *     // Create many CharacterVersions
     *     const characterVersion = await prisma.characterVersion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterVersionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterVersionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterVersion.
     * @param {CharacterVersionDeleteArgs} args - Arguments to delete one CharacterVersion.
     * @example
     * // Delete one CharacterVersion
     * const CharacterVersion = await prisma.characterVersion.delete({
     *   where: {
     *     // ... filter to delete one CharacterVersion
     *   }
     * })
     * 
    **/
    delete<T extends CharacterVersionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterVersionDeleteArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterVersion.
     * @param {CharacterVersionUpdateArgs} args - Arguments to update one CharacterVersion.
     * @example
     * // Update one CharacterVersion
     * const characterVersion = await prisma.characterVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterVersionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterVersionUpdateArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterVersions.
     * @param {CharacterVersionDeleteManyArgs} args - Arguments to filter CharacterVersions to delete.
     * @example
     * // Delete a few CharacterVersions
     * const { count } = await prisma.characterVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterVersionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterVersionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterVersions
     * const characterVersion = await prisma.characterVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterVersionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterVersionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterVersion.
     * @param {CharacterVersionUpsertArgs} args - Arguments to update or create a CharacterVersion.
     * @example
     * // Update or create a CharacterVersion
     * const characterVersion = await prisma.characterVersion.upsert({
     *   create: {
     *     // ... data to create a CharacterVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterVersion we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterVersionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterVersionUpsertArgs<ExtArgs>>
    ): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVersionCountArgs} args - Arguments to filter CharacterVersions to count.
     * @example
     * // Count the number of CharacterVersions
     * const count = await prisma.characterVersion.count({
     *   where: {
     *     // ... the filter for the CharacterVersions we want to count
     *   }
     * })
    **/
    count<T extends CharacterVersionCountArgs>(
      args?: Subset<T, CharacterVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterVersionAggregateArgs>(args: Subset<T, CharacterVersionAggregateArgs>): Prisma.PrismaPromise<GetCharacterVersionAggregateType<T>>

    /**
     * Group by CharacterVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterVersionGroupByArgs['orderBy'] }
        : { orderBy?: CharacterVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterVersion model
   */
  readonly fields: CharacterVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    CharacterStat<T extends CharacterVersion$CharacterStatArgs<ExtArgs> = {}>(args?: Subset<T, CharacterVersion$CharacterStatArgs<ExtArgs>>): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    CharacterQuest<T extends CharacterVersion$CharacterQuestArgs<ExtArgs> = {}>(args?: Subset<T, CharacterVersion$CharacterQuestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'findMany'> | Null>;

    CharacterEquipment<T extends CharacterVersion$CharacterEquipmentArgs<ExtArgs> = {}>(args?: Subset<T, CharacterVersion$CharacterEquipmentArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterVersion model
   */ 
  interface CharacterVersionFieldRefs {
    readonly id: FieldRef<"CharacterVersion", 'Int'>
    readonly characterId: FieldRef<"CharacterVersion", 'Int'>
    readonly equipmentId: FieldRef<"CharacterVersion", 'Int'>
    readonly statsId: FieldRef<"CharacterVersion", 'Int'>
    readonly createdDate: FieldRef<"CharacterVersion", 'DateTime'>
    readonly modifiedDate: FieldRef<"CharacterVersion", 'DateTime'>
    readonly version: FieldRef<"CharacterVersion", 'String'>
    readonly hometown: FieldRef<"CharacterVersion", 'String'>
    readonly characterEquipmentId: FieldRef<"CharacterVersion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CharacterVersion findUnique
   */
  export type CharacterVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVersion to fetch.
     */
    where: CharacterVersionWhereUniqueInput
  }


  /**
   * CharacterVersion findUniqueOrThrow
   */
  export type CharacterVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVersion to fetch.
     */
    where: CharacterVersionWhereUniqueInput
  }


  /**
   * CharacterVersion findFirst
   */
  export type CharacterVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVersion to fetch.
     */
    where?: CharacterVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVersions to fetch.
     */
    orderBy?: CharacterVersionOrderByWithRelationInput | CharacterVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterVersions.
     */
    cursor?: CharacterVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterVersions.
     */
    distinct?: CharacterVersionScalarFieldEnum | CharacterVersionScalarFieldEnum[]
  }


  /**
   * CharacterVersion findFirstOrThrow
   */
  export type CharacterVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVersion to fetch.
     */
    where?: CharacterVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVersions to fetch.
     */
    orderBy?: CharacterVersionOrderByWithRelationInput | CharacterVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterVersions.
     */
    cursor?: CharacterVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterVersions.
     */
    distinct?: CharacterVersionScalarFieldEnum | CharacterVersionScalarFieldEnum[]
  }


  /**
   * CharacterVersion findMany
   */
  export type CharacterVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVersions to fetch.
     */
    where?: CharacterVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVersions to fetch.
     */
    orderBy?: CharacterVersionOrderByWithRelationInput | CharacterVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterVersions.
     */
    cursor?: CharacterVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVersions.
     */
    skip?: number
    distinct?: CharacterVersionScalarFieldEnum | CharacterVersionScalarFieldEnum[]
  }


  /**
   * CharacterVersion create
   */
  export type CharacterVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterVersion.
     */
    data: XOR<CharacterVersionCreateInput, CharacterVersionUncheckedCreateInput>
  }


  /**
   * CharacterVersion createMany
   */
  export type CharacterVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterVersions.
     */
    data: CharacterVersionCreateManyInput | CharacterVersionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterVersion update
   */
  export type CharacterVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterVersion.
     */
    data: XOR<CharacterVersionUpdateInput, CharacterVersionUncheckedUpdateInput>
    /**
     * Choose, which CharacterVersion to update.
     */
    where: CharacterVersionWhereUniqueInput
  }


  /**
   * CharacterVersion updateMany
   */
  export type CharacterVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterVersions.
     */
    data: XOR<CharacterVersionUpdateManyMutationInput, CharacterVersionUncheckedUpdateManyInput>
    /**
     * Filter which CharacterVersions to update
     */
    where?: CharacterVersionWhereInput
  }


  /**
   * CharacterVersion upsert
   */
  export type CharacterVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterVersion to update in case it exists.
     */
    where: CharacterVersionWhereUniqueInput
    /**
     * In case the CharacterVersion found by the `where` argument doesn't exist, create a new CharacterVersion with this data.
     */
    create: XOR<CharacterVersionCreateInput, CharacterVersionUncheckedCreateInput>
    /**
     * In case the CharacterVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterVersionUpdateInput, CharacterVersionUncheckedUpdateInput>
  }


  /**
   * CharacterVersion delete
   */
  export type CharacterVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    /**
     * Filter which CharacterVersion to delete.
     */
    where: CharacterVersionWhereUniqueInput
  }


  /**
   * CharacterVersion deleteMany
   */
  export type CharacterVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterVersions to delete
     */
    where?: CharacterVersionWhereInput
  }


  /**
   * CharacterVersion.CharacterStat
   */
  export type CharacterVersion$CharacterStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    where?: CharacterStatWhereInput
  }


  /**
   * CharacterVersion.CharacterQuest
   */
  export type CharacterVersion$CharacterQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    where?: CharacterQuestWhereInput
    orderBy?: CharacterQuestOrderByWithRelationInput | CharacterQuestOrderByWithRelationInput[]
    cursor?: CharacterQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterQuestScalarFieldEnum | CharacterQuestScalarFieldEnum[]
  }


  /**
   * CharacterVersion.CharacterEquipment
   */
  export type CharacterVersion$CharacterEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    where?: CharacterEquipmentWhereInput
  }


  /**
   * CharacterVersion without action
   */
  export type CharacterVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
  }



  /**
   * Model CharacterStat
   */

  export type AggregateCharacterStat = {
    _count: CharacterStatCountAggregateOutputType | null
    _avg: CharacterStatAvgAggregateOutputType | null
    _sum: CharacterStatSumAggregateOutputType | null
    _min: CharacterStatMinAggregateOutputType | null
    _max: CharacterStatMaxAggregateOutputType | null
  }

  export type CharacterStatAvgAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    strSwap: number | null
    minSwap: number | null
    dexSwap: number | null
    conSwap: number | null
    perSwap: number | null
    spiSwap: number | null
  }

  export type CharacterStatSumAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    strSwap: number | null
    minSwap: number | null
    dexSwap: number | null
    conSwap: number | null
    perSwap: number | null
    spiSwap: number | null
  }

  export type CharacterStatMinAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    strSwap: number | null
    minSwap: number | null
    dexSwap: number | null
    conSwap: number | null
    perSwap: number | null
    spiSwap: number | null
  }

  export type CharacterStatMaxAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    strSwap: number | null
    minSwap: number | null
    dexSwap: number | null
    conSwap: number | null
    perSwap: number | null
    spiSwap: number | null
  }

  export type CharacterStatCountAggregateOutputType = {
    id: number
    characterVersionId: number
    str: number
    min: number
    dex: number
    con: number
    per: number
    spi: number
    strSwap: number
    minSwap: number
    dexSwap: number
    conSwap: number
    perSwap: number
    spiSwap: number
    _all: number
  }


  export type CharacterStatAvgAggregateInputType = {
    id?: true
    characterVersionId?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    strSwap?: true
    minSwap?: true
    dexSwap?: true
    conSwap?: true
    perSwap?: true
    spiSwap?: true
  }

  export type CharacterStatSumAggregateInputType = {
    id?: true
    characterVersionId?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    strSwap?: true
    minSwap?: true
    dexSwap?: true
    conSwap?: true
    perSwap?: true
    spiSwap?: true
  }

  export type CharacterStatMinAggregateInputType = {
    id?: true
    characterVersionId?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    strSwap?: true
    minSwap?: true
    dexSwap?: true
    conSwap?: true
    perSwap?: true
    spiSwap?: true
  }

  export type CharacterStatMaxAggregateInputType = {
    id?: true
    characterVersionId?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    strSwap?: true
    minSwap?: true
    dexSwap?: true
    conSwap?: true
    perSwap?: true
    spiSwap?: true
  }

  export type CharacterStatCountAggregateInputType = {
    id?: true
    characterVersionId?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    strSwap?: true
    minSwap?: true
    dexSwap?: true
    conSwap?: true
    perSwap?: true
    spiSwap?: true
    _all?: true
  }

  export type CharacterStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterStat to aggregate.
     */
    where?: CharacterStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStats to fetch.
     */
    orderBy?: CharacterStatOrderByWithRelationInput | CharacterStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterStats
    **/
    _count?: true | CharacterStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterStatMaxAggregateInputType
  }

  export type GetCharacterStatAggregateType<T extends CharacterStatAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterStat[P]>
      : GetScalarType<T[P], AggregateCharacterStat[P]>
  }




  export type CharacterStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterStatWhereInput
    orderBy?: CharacterStatOrderByWithAggregationInput | CharacterStatOrderByWithAggregationInput[]
    by: CharacterStatScalarFieldEnum[] | CharacterStatScalarFieldEnum
    having?: CharacterStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterStatCountAggregateInputType | true
    _avg?: CharacterStatAvgAggregateInputType
    _sum?: CharacterStatSumAggregateInputType
    _min?: CharacterStatMinAggregateInputType
    _max?: CharacterStatMaxAggregateInputType
  }

  export type CharacterStatGroupByOutputType = {
    id: number
    characterVersionId: number
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    strSwap: number | null
    minSwap: number | null
    dexSwap: number | null
    conSwap: number | null
    perSwap: number | null
    spiSwap: number | null
    _count: CharacterStatCountAggregateOutputType | null
    _avg: CharacterStatAvgAggregateOutputType | null
    _sum: CharacterStatSumAggregateOutputType | null
    _min: CharacterStatMinAggregateOutputType | null
    _max: CharacterStatMaxAggregateOutputType | null
  }

  type GetCharacterStatGroupByPayload<T extends CharacterStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterStatGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterStatGroupByOutputType[P]>
        }
      >
    >


  export type CharacterStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterVersionId?: boolean
    str?: boolean
    min?: boolean
    dex?: boolean
    con?: boolean
    per?: boolean
    spi?: boolean
    strSwap?: boolean
    minSwap?: boolean
    dexSwap?: boolean
    conSwap?: boolean
    perSwap?: boolean
    spiSwap?: boolean
    CharacterVersion?: boolean | CharacterVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterStat"]>

  export type CharacterStatSelectScalar = {
    id?: boolean
    characterVersionId?: boolean
    str?: boolean
    min?: boolean
    dex?: boolean
    con?: boolean
    per?: boolean
    spi?: boolean
    strSwap?: boolean
    minSwap?: boolean
    dexSwap?: boolean
    conSwap?: boolean
    perSwap?: boolean
    spiSwap?: boolean
  }

  export type CharacterStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CharacterVersion?: boolean | CharacterVersionDefaultArgs<ExtArgs>
  }


  export type $CharacterStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterStat"
    objects: {
      CharacterVersion: Prisma.$CharacterVersionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      characterVersionId: number
      str: number | null
      min: number | null
      dex: number | null
      con: number | null
      per: number | null
      spi: number | null
      strSwap: number | null
      minSwap: number | null
      dexSwap: number | null
      conSwap: number | null
      perSwap: number | null
      spiSwap: number | null
    }, ExtArgs["result"]["characterStat"]>
    composites: {}
  }


  type CharacterStatGetPayload<S extends boolean | null | undefined | CharacterStatDefaultArgs> = $Result.GetResult<Prisma.$CharacterStatPayload, S>

  type CharacterStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterStatFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CharacterStatCountAggregateInputType | true
    }

  export interface CharacterStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterStat'], meta: { name: 'CharacterStat' } }
    /**
     * Find zero or one CharacterStat that matches the filter.
     * @param {CharacterStatFindUniqueArgs} args - Arguments to find a CharacterStat
     * @example
     * // Get one CharacterStat
     * const characterStat = await prisma.characterStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterStatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterStatFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterStat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterStatFindUniqueOrThrowArgs} args - Arguments to find a CharacterStat
     * @example
     * // Get one CharacterStat
     * const characterStat = await prisma.characterStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterStatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterStatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStatFindFirstArgs} args - Arguments to find a CharacterStat
     * @example
     * // Get one CharacterStat
     * const characterStat = await prisma.characterStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterStatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterStatFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStatFindFirstOrThrowArgs} args - Arguments to find a CharacterStat
     * @example
     * // Get one CharacterStat
     * const characterStat = await prisma.characterStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterStatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterStatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterStats
     * const characterStats = await prisma.characterStat.findMany()
     * 
     * // Get first 10 CharacterStats
     * const characterStats = await prisma.characterStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterStatWithIdOnly = await prisma.characterStat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterStatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterStatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterStat.
     * @param {CharacterStatCreateArgs} args - Arguments to create a CharacterStat.
     * @example
     * // Create one CharacterStat
     * const CharacterStat = await prisma.characterStat.create({
     *   data: {
     *     // ... data to create a CharacterStat
     *   }
     * })
     * 
    **/
    create<T extends CharacterStatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterStatCreateArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterStats.
     *     @param {CharacterStatCreateManyArgs} args - Arguments to create many CharacterStats.
     *     @example
     *     // Create many CharacterStats
     *     const characterStat = await prisma.characterStat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterStatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterStatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterStat.
     * @param {CharacterStatDeleteArgs} args - Arguments to delete one CharacterStat.
     * @example
     * // Delete one CharacterStat
     * const CharacterStat = await prisma.characterStat.delete({
     *   where: {
     *     // ... filter to delete one CharacterStat
     *   }
     * })
     * 
    **/
    delete<T extends CharacterStatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterStatDeleteArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterStat.
     * @param {CharacterStatUpdateArgs} args - Arguments to update one CharacterStat.
     * @example
     * // Update one CharacterStat
     * const characterStat = await prisma.characterStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterStatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterStatUpdateArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterStats.
     * @param {CharacterStatDeleteManyArgs} args - Arguments to filter CharacterStats to delete.
     * @example
     * // Delete a few CharacterStats
     * const { count } = await prisma.characterStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterStatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterStatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterStats
     * const characterStat = await prisma.characterStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterStatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterStatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterStat.
     * @param {CharacterStatUpsertArgs} args - Arguments to update or create a CharacterStat.
     * @example
     * // Update or create a CharacterStat
     * const characterStat = await prisma.characterStat.upsert({
     *   create: {
     *     // ... data to create a CharacterStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterStat we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterStatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterStatUpsertArgs<ExtArgs>>
    ): Prisma__CharacterStatClient<$Result.GetResult<Prisma.$CharacterStatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStatCountArgs} args - Arguments to filter CharacterStats to count.
     * @example
     * // Count the number of CharacterStats
     * const count = await prisma.characterStat.count({
     *   where: {
     *     // ... the filter for the CharacterStats we want to count
     *   }
     * })
    **/
    count<T extends CharacterStatCountArgs>(
      args?: Subset<T, CharacterStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterStatAggregateArgs>(args: Subset<T, CharacterStatAggregateArgs>): Prisma.PrismaPromise<GetCharacterStatAggregateType<T>>

    /**
     * Group by CharacterStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterStatGroupByArgs['orderBy'] }
        : { orderBy?: CharacterStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterStat model
   */
  readonly fields: CharacterStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CharacterVersion<T extends CharacterVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterVersionDefaultArgs<ExtArgs>>): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterStat model
   */ 
  interface CharacterStatFieldRefs {
    readonly id: FieldRef<"CharacterStat", 'Int'>
    readonly characterVersionId: FieldRef<"CharacterStat", 'Int'>
    readonly str: FieldRef<"CharacterStat", 'Int'>
    readonly min: FieldRef<"CharacterStat", 'Int'>
    readonly dex: FieldRef<"CharacterStat", 'Int'>
    readonly con: FieldRef<"CharacterStat", 'Int'>
    readonly per: FieldRef<"CharacterStat", 'Int'>
    readonly spi: FieldRef<"CharacterStat", 'Int'>
    readonly strSwap: FieldRef<"CharacterStat", 'Int'>
    readonly minSwap: FieldRef<"CharacterStat", 'Int'>
    readonly dexSwap: FieldRef<"CharacterStat", 'Int'>
    readonly conSwap: FieldRef<"CharacterStat", 'Int'>
    readonly perSwap: FieldRef<"CharacterStat", 'Int'>
    readonly spiSwap: FieldRef<"CharacterStat", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CharacterStat findUnique
   */
  export type CharacterStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * Filter, which CharacterStat to fetch.
     */
    where: CharacterStatWhereUniqueInput
  }


  /**
   * CharacterStat findUniqueOrThrow
   */
  export type CharacterStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * Filter, which CharacterStat to fetch.
     */
    where: CharacterStatWhereUniqueInput
  }


  /**
   * CharacterStat findFirst
   */
  export type CharacterStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * Filter, which CharacterStat to fetch.
     */
    where?: CharacterStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStats to fetch.
     */
    orderBy?: CharacterStatOrderByWithRelationInput | CharacterStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterStats.
     */
    cursor?: CharacterStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterStats.
     */
    distinct?: CharacterStatScalarFieldEnum | CharacterStatScalarFieldEnum[]
  }


  /**
   * CharacterStat findFirstOrThrow
   */
  export type CharacterStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * Filter, which CharacterStat to fetch.
     */
    where?: CharacterStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStats to fetch.
     */
    orderBy?: CharacterStatOrderByWithRelationInput | CharacterStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterStats.
     */
    cursor?: CharacterStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterStats.
     */
    distinct?: CharacterStatScalarFieldEnum | CharacterStatScalarFieldEnum[]
  }


  /**
   * CharacterStat findMany
   */
  export type CharacterStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * Filter, which CharacterStats to fetch.
     */
    where?: CharacterStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterStats to fetch.
     */
    orderBy?: CharacterStatOrderByWithRelationInput | CharacterStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterStats.
     */
    cursor?: CharacterStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterStats.
     */
    skip?: number
    distinct?: CharacterStatScalarFieldEnum | CharacterStatScalarFieldEnum[]
  }


  /**
   * CharacterStat create
   */
  export type CharacterStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterStat.
     */
    data: XOR<CharacterStatCreateInput, CharacterStatUncheckedCreateInput>
  }


  /**
   * CharacterStat createMany
   */
  export type CharacterStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterStats.
     */
    data: CharacterStatCreateManyInput | CharacterStatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterStat update
   */
  export type CharacterStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterStat.
     */
    data: XOR<CharacterStatUpdateInput, CharacterStatUncheckedUpdateInput>
    /**
     * Choose, which CharacterStat to update.
     */
    where: CharacterStatWhereUniqueInput
  }


  /**
   * CharacterStat updateMany
   */
  export type CharacterStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterStats.
     */
    data: XOR<CharacterStatUpdateManyMutationInput, CharacterStatUncheckedUpdateManyInput>
    /**
     * Filter which CharacterStats to update
     */
    where?: CharacterStatWhereInput
  }


  /**
   * CharacterStat upsert
   */
  export type CharacterStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterStat to update in case it exists.
     */
    where: CharacterStatWhereUniqueInput
    /**
     * In case the CharacterStat found by the `where` argument doesn't exist, create a new CharacterStat with this data.
     */
    create: XOR<CharacterStatCreateInput, CharacterStatUncheckedCreateInput>
    /**
     * In case the CharacterStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterStatUpdateInput, CharacterStatUncheckedUpdateInput>
  }


  /**
   * CharacterStat delete
   */
  export type CharacterStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
    /**
     * Filter which CharacterStat to delete.
     */
    where: CharacterStatWhereUniqueInput
  }


  /**
   * CharacterStat deleteMany
   */
  export type CharacterStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterStats to delete
     */
    where?: CharacterStatWhereInput
  }


  /**
   * CharacterStat without action
   */
  export type CharacterStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterStat
     */
    select?: CharacterStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterStatInclude<ExtArgs> | null
  }



  /**
   * Model CharacterQuest
   */

  export type AggregateCharacterQuest = {
    _count: CharacterQuestCountAggregateOutputType | null
    _avg: CharacterQuestAvgAggregateOutputType | null
    _sum: CharacterQuestSumAggregateOutputType | null
    _min: CharacterQuestMinAggregateOutputType | null
    _max: CharacterQuestMaxAggregateOutputType | null
  }

  export type CharacterQuestAvgAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    questId: number | null
  }

  export type CharacterQuestSumAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    questId: number | null
  }

  export type CharacterQuestMinAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    questId: number | null
  }

  export type CharacterQuestMaxAggregateOutputType = {
    id: number | null
    characterVersionId: number | null
    questId: number | null
  }

  export type CharacterQuestCountAggregateOutputType = {
    id: number
    characterVersionId: number
    questId: number
    _all: number
  }


  export type CharacterQuestAvgAggregateInputType = {
    id?: true
    characterVersionId?: true
    questId?: true
  }

  export type CharacterQuestSumAggregateInputType = {
    id?: true
    characterVersionId?: true
    questId?: true
  }

  export type CharacterQuestMinAggregateInputType = {
    id?: true
    characterVersionId?: true
    questId?: true
  }

  export type CharacterQuestMaxAggregateInputType = {
    id?: true
    characterVersionId?: true
    questId?: true
  }

  export type CharacterQuestCountAggregateInputType = {
    id?: true
    characterVersionId?: true
    questId?: true
    _all?: true
  }

  export type CharacterQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterQuest to aggregate.
     */
    where?: CharacterQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterQuests to fetch.
     */
    orderBy?: CharacterQuestOrderByWithRelationInput | CharacterQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterQuests
    **/
    _count?: true | CharacterQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterQuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterQuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterQuestMaxAggregateInputType
  }

  export type GetCharacterQuestAggregateType<T extends CharacterQuestAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterQuest[P]>
      : GetScalarType<T[P], AggregateCharacterQuest[P]>
  }




  export type CharacterQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterQuestWhereInput
    orderBy?: CharacterQuestOrderByWithAggregationInput | CharacterQuestOrderByWithAggregationInput[]
    by: CharacterQuestScalarFieldEnum[] | CharacterQuestScalarFieldEnum
    having?: CharacterQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterQuestCountAggregateInputType | true
    _avg?: CharacterQuestAvgAggregateInputType
    _sum?: CharacterQuestSumAggregateInputType
    _min?: CharacterQuestMinAggregateInputType
    _max?: CharacterQuestMaxAggregateInputType
  }

  export type CharacterQuestGroupByOutputType = {
    id: number
    characterVersionId: number
    questId: number
    _count: CharacterQuestCountAggregateOutputType | null
    _avg: CharacterQuestAvgAggregateOutputType | null
    _sum: CharacterQuestSumAggregateOutputType | null
    _min: CharacterQuestMinAggregateOutputType | null
    _max: CharacterQuestMaxAggregateOutputType | null
  }

  type GetCharacterQuestGroupByPayload<T extends CharacterQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterQuestGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterQuestGroupByOutputType[P]>
        }
      >
    >


  export type CharacterQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterVersionId?: boolean
    questId?: boolean
    CharacterVersion?: boolean | CharacterVersionDefaultArgs<ExtArgs>
    Quest?: boolean | QuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterQuest"]>

  export type CharacterQuestSelectScalar = {
    id?: boolean
    characterVersionId?: boolean
    questId?: boolean
  }

  export type CharacterQuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CharacterVersion?: boolean | CharacterVersionDefaultArgs<ExtArgs>
    Quest?: boolean | QuestDefaultArgs<ExtArgs>
  }


  export type $CharacterQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterQuest"
    objects: {
      CharacterVersion: Prisma.$CharacterVersionPayload<ExtArgs>
      Quest: Prisma.$QuestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      characterVersionId: number
      questId: number
    }, ExtArgs["result"]["characterQuest"]>
    composites: {}
  }


  type CharacterQuestGetPayload<S extends boolean | null | undefined | CharacterQuestDefaultArgs> = $Result.GetResult<Prisma.$CharacterQuestPayload, S>

  type CharacterQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterQuestFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CharacterQuestCountAggregateInputType | true
    }

  export interface CharacterQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterQuest'], meta: { name: 'CharacterQuest' } }
    /**
     * Find zero or one CharacterQuest that matches the filter.
     * @param {CharacterQuestFindUniqueArgs} args - Arguments to find a CharacterQuest
     * @example
     * // Get one CharacterQuest
     * const characterQuest = await prisma.characterQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterQuestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterQuestFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterQuest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterQuestFindUniqueOrThrowArgs} args - Arguments to find a CharacterQuest
     * @example
     * // Get one CharacterQuest
     * const characterQuest = await prisma.characterQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterQuestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterQuestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterQuestFindFirstArgs} args - Arguments to find a CharacterQuest
     * @example
     * // Get one CharacterQuest
     * const characterQuest = await prisma.characterQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterQuestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterQuestFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterQuestFindFirstOrThrowArgs} args - Arguments to find a CharacterQuest
     * @example
     * // Get one CharacterQuest
     * const characterQuest = await prisma.characterQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterQuestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterQuestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterQuestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterQuests
     * const characterQuests = await prisma.characterQuest.findMany()
     * 
     * // Get first 10 CharacterQuests
     * const characterQuests = await prisma.characterQuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterQuestWithIdOnly = await prisma.characterQuest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterQuestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterQuestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterQuest.
     * @param {CharacterQuestCreateArgs} args - Arguments to create a CharacterQuest.
     * @example
     * // Create one CharacterQuest
     * const CharacterQuest = await prisma.characterQuest.create({
     *   data: {
     *     // ... data to create a CharacterQuest
     *   }
     * })
     * 
    **/
    create<T extends CharacterQuestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterQuestCreateArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterQuests.
     *     @param {CharacterQuestCreateManyArgs} args - Arguments to create many CharacterQuests.
     *     @example
     *     // Create many CharacterQuests
     *     const characterQuest = await prisma.characterQuest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterQuestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterQuestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterQuest.
     * @param {CharacterQuestDeleteArgs} args - Arguments to delete one CharacterQuest.
     * @example
     * // Delete one CharacterQuest
     * const CharacterQuest = await prisma.characterQuest.delete({
     *   where: {
     *     // ... filter to delete one CharacterQuest
     *   }
     * })
     * 
    **/
    delete<T extends CharacterQuestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterQuestDeleteArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterQuest.
     * @param {CharacterQuestUpdateArgs} args - Arguments to update one CharacterQuest.
     * @example
     * // Update one CharacterQuest
     * const characterQuest = await prisma.characterQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterQuestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterQuestUpdateArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterQuests.
     * @param {CharacterQuestDeleteManyArgs} args - Arguments to filter CharacterQuests to delete.
     * @example
     * // Delete a few CharacterQuests
     * const { count } = await prisma.characterQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterQuestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterQuestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterQuests
     * const characterQuest = await prisma.characterQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterQuestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterQuestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterQuest.
     * @param {CharacterQuestUpsertArgs} args - Arguments to update or create a CharacterQuest.
     * @example
     * // Update or create a CharacterQuest
     * const characterQuest = await prisma.characterQuest.upsert({
     *   create: {
     *     // ... data to create a CharacterQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterQuest we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterQuestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterQuestUpsertArgs<ExtArgs>>
    ): Prisma__CharacterQuestClient<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterQuestCountArgs} args - Arguments to filter CharacterQuests to count.
     * @example
     * // Count the number of CharacterQuests
     * const count = await prisma.characterQuest.count({
     *   where: {
     *     // ... the filter for the CharacterQuests we want to count
     *   }
     * })
    **/
    count<T extends CharacterQuestCountArgs>(
      args?: Subset<T, CharacterQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterQuestAggregateArgs>(args: Subset<T, CharacterQuestAggregateArgs>): Prisma.PrismaPromise<GetCharacterQuestAggregateType<T>>

    /**
     * Group by CharacterQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterQuestGroupByArgs['orderBy'] }
        : { orderBy?: CharacterQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterQuest model
   */
  readonly fields: CharacterQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CharacterVersion<T extends CharacterVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterVersionDefaultArgs<ExtArgs>>): Prisma__CharacterVersionClient<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Quest<T extends QuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestDefaultArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterQuest model
   */ 
  interface CharacterQuestFieldRefs {
    readonly id: FieldRef<"CharacterQuest", 'Int'>
    readonly characterVersionId: FieldRef<"CharacterQuest", 'Int'>
    readonly questId: FieldRef<"CharacterQuest", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CharacterQuest findUnique
   */
  export type CharacterQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * Filter, which CharacterQuest to fetch.
     */
    where: CharacterQuestWhereUniqueInput
  }


  /**
   * CharacterQuest findUniqueOrThrow
   */
  export type CharacterQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * Filter, which CharacterQuest to fetch.
     */
    where: CharacterQuestWhereUniqueInput
  }


  /**
   * CharacterQuest findFirst
   */
  export type CharacterQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * Filter, which CharacterQuest to fetch.
     */
    where?: CharacterQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterQuests to fetch.
     */
    orderBy?: CharacterQuestOrderByWithRelationInput | CharacterQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterQuests.
     */
    cursor?: CharacterQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterQuests.
     */
    distinct?: CharacterQuestScalarFieldEnum | CharacterQuestScalarFieldEnum[]
  }


  /**
   * CharacterQuest findFirstOrThrow
   */
  export type CharacterQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * Filter, which CharacterQuest to fetch.
     */
    where?: CharacterQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterQuests to fetch.
     */
    orderBy?: CharacterQuestOrderByWithRelationInput | CharacterQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterQuests.
     */
    cursor?: CharacterQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterQuests.
     */
    distinct?: CharacterQuestScalarFieldEnum | CharacterQuestScalarFieldEnum[]
  }


  /**
   * CharacterQuest findMany
   */
  export type CharacterQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * Filter, which CharacterQuests to fetch.
     */
    where?: CharacterQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterQuests to fetch.
     */
    orderBy?: CharacterQuestOrderByWithRelationInput | CharacterQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterQuests.
     */
    cursor?: CharacterQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterQuests.
     */
    skip?: number
    distinct?: CharacterQuestScalarFieldEnum | CharacterQuestScalarFieldEnum[]
  }


  /**
   * CharacterQuest create
   */
  export type CharacterQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterQuest.
     */
    data: XOR<CharacterQuestCreateInput, CharacterQuestUncheckedCreateInput>
  }


  /**
   * CharacterQuest createMany
   */
  export type CharacterQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterQuests.
     */
    data: CharacterQuestCreateManyInput | CharacterQuestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterQuest update
   */
  export type CharacterQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterQuest.
     */
    data: XOR<CharacterQuestUpdateInput, CharacterQuestUncheckedUpdateInput>
    /**
     * Choose, which CharacterQuest to update.
     */
    where: CharacterQuestWhereUniqueInput
  }


  /**
   * CharacterQuest updateMany
   */
  export type CharacterQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterQuests.
     */
    data: XOR<CharacterQuestUpdateManyMutationInput, CharacterQuestUncheckedUpdateManyInput>
    /**
     * Filter which CharacterQuests to update
     */
    where?: CharacterQuestWhereInput
  }


  /**
   * CharacterQuest upsert
   */
  export type CharacterQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterQuest to update in case it exists.
     */
    where: CharacterQuestWhereUniqueInput
    /**
     * In case the CharacterQuest found by the `where` argument doesn't exist, create a new CharacterQuest with this data.
     */
    create: XOR<CharacterQuestCreateInput, CharacterQuestUncheckedCreateInput>
    /**
     * In case the CharacterQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterQuestUpdateInput, CharacterQuestUncheckedUpdateInput>
  }


  /**
   * CharacterQuest delete
   */
  export type CharacterQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    /**
     * Filter which CharacterQuest to delete.
     */
    where: CharacterQuestWhereUniqueInput
  }


  /**
   * CharacterQuest deleteMany
   */
  export type CharacterQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterQuests to delete
     */
    where?: CharacterQuestWhereInput
  }


  /**
   * CharacterQuest without action
   */
  export type CharacterQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
  }



  /**
   * Model CharacterEquipment
   */

  export type AggregateCharacterEquipment = {
    _count: CharacterEquipmentCountAggregateOutputType | null
    _avg: CharacterEquipmentAvgAggregateOutputType | null
    _sum: CharacterEquipmentSumAggregateOutputType | null
    _min: CharacterEquipmentMinAggregateOutputType | null
    _max: CharacterEquipmentMaxAggregateOutputType | null
  }

  export type CharacterEquipmentAvgAggregateOutputType = {
    id: number | null
    light: number | null
    finger1: number | null
    finger2: number | null
    neck1: number | null
    neck2: number | null
    body: number | null
    head: number | null
    hands: number | null
    feet: number | null
    face: number | null
    arms: number | null
    legs: number | null
    about: number | null
    waist: number | null
    wrist1: number | null
    wrist2: number | null
    wield: number | null
    hold1: number | null
    hold2: number | null
    hold3: number | null
    ear1: number | null
    ear2: number | null
    arm: number | null
    amulet: number | null
    aux: number | null
  }

  export type CharacterEquipmentSumAggregateOutputType = {
    id: number | null
    light: number | null
    finger1: number | null
    finger2: number | null
    neck1: number | null
    neck2: number | null
    body: number | null
    head: number | null
    hands: number | null
    feet: number | null
    face: number | null
    arms: number | null
    legs: number | null
    about: number | null
    waist: number | null
    wrist1: number | null
    wrist2: number | null
    wield: number | null
    hold1: number | null
    hold2: number | null
    hold3: number | null
    ear1: number | null
    ear2: number | null
    arm: number | null
    amulet: number | null
    aux: number | null
  }

  export type CharacterEquipmentMinAggregateOutputType = {
    id: number | null
    light: number | null
    finger1: number | null
    finger2: number | null
    neck1: number | null
    neck2: number | null
    body: number | null
    head: number | null
    hands: number | null
    feet: number | null
    face: number | null
    arms: number | null
    legs: number | null
    about: number | null
    waist: number | null
    wrist1: number | null
    wrist2: number | null
    wield: number | null
    hold1: number | null
    hold2: number | null
    hold3: number | null
    ear1: number | null
    ear2: number | null
    arm: number | null
    amulet: number | null
    aux: number | null
  }

  export type CharacterEquipmentMaxAggregateOutputType = {
    id: number | null
    light: number | null
    finger1: number | null
    finger2: number | null
    neck1: number | null
    neck2: number | null
    body: number | null
    head: number | null
    hands: number | null
    feet: number | null
    face: number | null
    arms: number | null
    legs: number | null
    about: number | null
    waist: number | null
    wrist1: number | null
    wrist2: number | null
    wield: number | null
    hold1: number | null
    hold2: number | null
    hold3: number | null
    ear1: number | null
    ear2: number | null
    arm: number | null
    amulet: number | null
    aux: number | null
  }

  export type CharacterEquipmentCountAggregateOutputType = {
    id: number
    light: number
    finger1: number
    finger2: number
    neck1: number
    neck2: number
    body: number
    head: number
    hands: number
    feet: number
    face: number
    arms: number
    legs: number
    about: number
    waist: number
    wrist1: number
    wrist2: number
    wield: number
    hold1: number
    hold2: number
    hold3: number
    ear1: number
    ear2: number
    arm: number
    amulet: number
    aux: number
    _all: number
  }


  export type CharacterEquipmentAvgAggregateInputType = {
    id?: true
    light?: true
    finger1?: true
    finger2?: true
    neck1?: true
    neck2?: true
    body?: true
    head?: true
    hands?: true
    feet?: true
    face?: true
    arms?: true
    legs?: true
    about?: true
    waist?: true
    wrist1?: true
    wrist2?: true
    wield?: true
    hold1?: true
    hold2?: true
    hold3?: true
    ear1?: true
    ear2?: true
    arm?: true
    amulet?: true
    aux?: true
  }

  export type CharacterEquipmentSumAggregateInputType = {
    id?: true
    light?: true
    finger1?: true
    finger2?: true
    neck1?: true
    neck2?: true
    body?: true
    head?: true
    hands?: true
    feet?: true
    face?: true
    arms?: true
    legs?: true
    about?: true
    waist?: true
    wrist1?: true
    wrist2?: true
    wield?: true
    hold1?: true
    hold2?: true
    hold3?: true
    ear1?: true
    ear2?: true
    arm?: true
    amulet?: true
    aux?: true
  }

  export type CharacterEquipmentMinAggregateInputType = {
    id?: true
    light?: true
    finger1?: true
    finger2?: true
    neck1?: true
    neck2?: true
    body?: true
    head?: true
    hands?: true
    feet?: true
    face?: true
    arms?: true
    legs?: true
    about?: true
    waist?: true
    wrist1?: true
    wrist2?: true
    wield?: true
    hold1?: true
    hold2?: true
    hold3?: true
    ear1?: true
    ear2?: true
    arm?: true
    amulet?: true
    aux?: true
  }

  export type CharacterEquipmentMaxAggregateInputType = {
    id?: true
    light?: true
    finger1?: true
    finger2?: true
    neck1?: true
    neck2?: true
    body?: true
    head?: true
    hands?: true
    feet?: true
    face?: true
    arms?: true
    legs?: true
    about?: true
    waist?: true
    wrist1?: true
    wrist2?: true
    wield?: true
    hold1?: true
    hold2?: true
    hold3?: true
    ear1?: true
    ear2?: true
    arm?: true
    amulet?: true
    aux?: true
  }

  export type CharacterEquipmentCountAggregateInputType = {
    id?: true
    light?: true
    finger1?: true
    finger2?: true
    neck1?: true
    neck2?: true
    body?: true
    head?: true
    hands?: true
    feet?: true
    face?: true
    arms?: true
    legs?: true
    about?: true
    waist?: true
    wrist1?: true
    wrist2?: true
    wield?: true
    hold1?: true
    hold2?: true
    hold3?: true
    ear1?: true
    ear2?: true
    arm?: true
    amulet?: true
    aux?: true
    _all?: true
  }

  export type CharacterEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterEquipment to aggregate.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterEquipments
    **/
    _count?: true | CharacterEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterEquipmentMaxAggregateInputType
  }

  export type GetCharacterEquipmentAggregateType<T extends CharacterEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterEquipment[P]>
      : GetScalarType<T[P], AggregateCharacterEquipment[P]>
  }




  export type CharacterEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterEquipmentWhereInput
    orderBy?: CharacterEquipmentOrderByWithAggregationInput | CharacterEquipmentOrderByWithAggregationInput[]
    by: CharacterEquipmentScalarFieldEnum[] | CharacterEquipmentScalarFieldEnum
    having?: CharacterEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterEquipmentCountAggregateInputType | true
    _avg?: CharacterEquipmentAvgAggregateInputType
    _sum?: CharacterEquipmentSumAggregateInputType
    _min?: CharacterEquipmentMinAggregateInputType
    _max?: CharacterEquipmentMaxAggregateInputType
  }

  export type CharacterEquipmentGroupByOutputType = {
    id: number
    light: number | null
    finger1: number | null
    finger2: number | null
    neck1: number | null
    neck2: number | null
    body: number | null
    head: number | null
    hands: number | null
    feet: number | null
    face: number | null
    arms: number | null
    legs: number | null
    about: number | null
    waist: number | null
    wrist1: number | null
    wrist2: number | null
    wield: number | null
    hold1: number | null
    hold2: number | null
    hold3: number | null
    ear1: number | null
    ear2: number | null
    arm: number | null
    amulet: number | null
    aux: number | null
    _count: CharacterEquipmentCountAggregateOutputType | null
    _avg: CharacterEquipmentAvgAggregateOutputType | null
    _sum: CharacterEquipmentSumAggregateOutputType | null
    _min: CharacterEquipmentMinAggregateOutputType | null
    _max: CharacterEquipmentMaxAggregateOutputType | null
  }

  type GetCharacterEquipmentGroupByPayload<T extends CharacterEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type CharacterEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    light?: boolean
    finger1?: boolean
    finger2?: boolean
    neck1?: boolean
    neck2?: boolean
    body?: boolean
    head?: boolean
    hands?: boolean
    feet?: boolean
    face?: boolean
    arms?: boolean
    legs?: boolean
    about?: boolean
    waist?: boolean
    wrist1?: boolean
    wrist2?: boolean
    wield?: boolean
    hold1?: boolean
    hold2?: boolean
    hold3?: boolean
    ear1?: boolean
    ear2?: boolean
    arm?: boolean
    amulet?: boolean
    aux?: boolean
    CharacterVersion?: boolean | CharacterEquipment$CharacterVersionArgs<ExtArgs>
    _count?: boolean | CharacterEquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterEquipment"]>

  export type CharacterEquipmentSelectScalar = {
    id?: boolean
    light?: boolean
    finger1?: boolean
    finger2?: boolean
    neck1?: boolean
    neck2?: boolean
    body?: boolean
    head?: boolean
    hands?: boolean
    feet?: boolean
    face?: boolean
    arms?: boolean
    legs?: boolean
    about?: boolean
    waist?: boolean
    wrist1?: boolean
    wrist2?: boolean
    wield?: boolean
    hold1?: boolean
    hold2?: boolean
    hold3?: boolean
    ear1?: boolean
    ear2?: boolean
    arm?: boolean
    amulet?: boolean
    aux?: boolean
  }

  export type CharacterEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CharacterVersion?: boolean | CharacterEquipment$CharacterVersionArgs<ExtArgs>
    _count?: boolean | CharacterEquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CharacterEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterEquipment"
    objects: {
      CharacterVersion: Prisma.$CharacterVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      light: number | null
      finger1: number | null
      finger2: number | null
      neck1: number | null
      neck2: number | null
      body: number | null
      head: number | null
      hands: number | null
      feet: number | null
      face: number | null
      arms: number | null
      legs: number | null
      about: number | null
      waist: number | null
      wrist1: number | null
      wrist2: number | null
      wield: number | null
      hold1: number | null
      hold2: number | null
      hold3: number | null
      ear1: number | null
      ear2: number | null
      arm: number | null
      amulet: number | null
      aux: number | null
    }, ExtArgs["result"]["characterEquipment"]>
    composites: {}
  }


  type CharacterEquipmentGetPayload<S extends boolean | null | undefined | CharacterEquipmentDefaultArgs> = $Result.GetResult<Prisma.$CharacterEquipmentPayload, S>

  type CharacterEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterEquipmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CharacterEquipmentCountAggregateInputType | true
    }

  export interface CharacterEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterEquipment'], meta: { name: 'CharacterEquipment' } }
    /**
     * Find zero or one CharacterEquipment that matches the filter.
     * @param {CharacterEquipmentFindUniqueArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterEquipmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEquipmentFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterEquipment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterEquipmentFindUniqueOrThrowArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterEquipmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEquipmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentFindFirstArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterEquipmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEquipmentFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentFindFirstOrThrowArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterEquipmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEquipmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterEquipments
     * const characterEquipments = await prisma.characterEquipment.findMany()
     * 
     * // Get first 10 CharacterEquipments
     * const characterEquipments = await prisma.characterEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterEquipmentWithIdOnly = await prisma.characterEquipment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterEquipmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEquipmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterEquipment.
     * @param {CharacterEquipmentCreateArgs} args - Arguments to create a CharacterEquipment.
     * @example
     * // Create one CharacterEquipment
     * const CharacterEquipment = await prisma.characterEquipment.create({
     *   data: {
     *     // ... data to create a CharacterEquipment
     *   }
     * })
     * 
    **/
    create<T extends CharacterEquipmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEquipmentCreateArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterEquipments.
     *     @param {CharacterEquipmentCreateManyArgs} args - Arguments to create many CharacterEquipments.
     *     @example
     *     // Create many CharacterEquipments
     *     const characterEquipment = await prisma.characterEquipment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterEquipmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEquipmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterEquipment.
     * @param {CharacterEquipmentDeleteArgs} args - Arguments to delete one CharacterEquipment.
     * @example
     * // Delete one CharacterEquipment
     * const CharacterEquipment = await prisma.characterEquipment.delete({
     *   where: {
     *     // ... filter to delete one CharacterEquipment
     *   }
     * })
     * 
    **/
    delete<T extends CharacterEquipmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEquipmentDeleteArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterEquipment.
     * @param {CharacterEquipmentUpdateArgs} args - Arguments to update one CharacterEquipment.
     * @example
     * // Update one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterEquipmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEquipmentUpdateArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterEquipments.
     * @param {CharacterEquipmentDeleteManyArgs} args - Arguments to filter CharacterEquipments to delete.
     * @example
     * // Delete a few CharacterEquipments
     * const { count } = await prisma.characterEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterEquipmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEquipmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterEquipments
     * const characterEquipment = await prisma.characterEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterEquipmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEquipmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterEquipment.
     * @param {CharacterEquipmentUpsertArgs} args - Arguments to update or create a CharacterEquipment.
     * @example
     * // Update or create a CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.upsert({
     *   create: {
     *     // ... data to create a CharacterEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterEquipment we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterEquipmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEquipmentUpsertArgs<ExtArgs>>
    ): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentCountArgs} args - Arguments to filter CharacterEquipments to count.
     * @example
     * // Count the number of CharacterEquipments
     * const count = await prisma.characterEquipment.count({
     *   where: {
     *     // ... the filter for the CharacterEquipments we want to count
     *   }
     * })
    **/
    count<T extends CharacterEquipmentCountArgs>(
      args?: Subset<T, CharacterEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterEquipmentAggregateArgs>(args: Subset<T, CharacterEquipmentAggregateArgs>): Prisma.PrismaPromise<GetCharacterEquipmentAggregateType<T>>

    /**
     * Group by CharacterEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: CharacterEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterEquipment model
   */
  readonly fields: CharacterEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CharacterVersion<T extends CharacterEquipment$CharacterVersionArgs<ExtArgs> = {}>(args?: Subset<T, CharacterEquipment$CharacterVersionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVersionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterEquipment model
   */ 
  interface CharacterEquipmentFieldRefs {
    readonly id: FieldRef<"CharacterEquipment", 'Int'>
    readonly light: FieldRef<"CharacterEquipment", 'Int'>
    readonly finger1: FieldRef<"CharacterEquipment", 'Int'>
    readonly finger2: FieldRef<"CharacterEquipment", 'Int'>
    readonly neck1: FieldRef<"CharacterEquipment", 'Int'>
    readonly neck2: FieldRef<"CharacterEquipment", 'Int'>
    readonly body: FieldRef<"CharacterEquipment", 'Int'>
    readonly head: FieldRef<"CharacterEquipment", 'Int'>
    readonly hands: FieldRef<"CharacterEquipment", 'Int'>
    readonly feet: FieldRef<"CharacterEquipment", 'Int'>
    readonly face: FieldRef<"CharacterEquipment", 'Int'>
    readonly arms: FieldRef<"CharacterEquipment", 'Int'>
    readonly legs: FieldRef<"CharacterEquipment", 'Int'>
    readonly about: FieldRef<"CharacterEquipment", 'Int'>
    readonly waist: FieldRef<"CharacterEquipment", 'Int'>
    readonly wrist1: FieldRef<"CharacterEquipment", 'Int'>
    readonly wrist2: FieldRef<"CharacterEquipment", 'Int'>
    readonly wield: FieldRef<"CharacterEquipment", 'Int'>
    readonly hold1: FieldRef<"CharacterEquipment", 'Int'>
    readonly hold2: FieldRef<"CharacterEquipment", 'Int'>
    readonly hold3: FieldRef<"CharacterEquipment", 'Int'>
    readonly ear1: FieldRef<"CharacterEquipment", 'Int'>
    readonly ear2: FieldRef<"CharacterEquipment", 'Int'>
    readonly arm: FieldRef<"CharacterEquipment", 'Int'>
    readonly amulet: FieldRef<"CharacterEquipment", 'Int'>
    readonly aux: FieldRef<"CharacterEquipment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CharacterEquipment findUnique
   */
  export type CharacterEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where: CharacterEquipmentWhereUniqueInput
  }


  /**
   * CharacterEquipment findUniqueOrThrow
   */
  export type CharacterEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where: CharacterEquipmentWhereUniqueInput
  }


  /**
   * CharacterEquipment findFirst
   */
  export type CharacterEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterEquipments.
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterEquipments.
     */
    distinct?: CharacterEquipmentScalarFieldEnum | CharacterEquipmentScalarFieldEnum[]
  }


  /**
   * CharacterEquipment findFirstOrThrow
   */
  export type CharacterEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterEquipments.
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterEquipments.
     */
    distinct?: CharacterEquipmentScalarFieldEnum | CharacterEquipmentScalarFieldEnum[]
  }


  /**
   * CharacterEquipment findMany
   */
  export type CharacterEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipments to fetch.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterEquipments.
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    distinct?: CharacterEquipmentScalarFieldEnum | CharacterEquipmentScalarFieldEnum[]
  }


  /**
   * CharacterEquipment create
   */
  export type CharacterEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterEquipment.
     */
    data?: XOR<CharacterEquipmentCreateInput, CharacterEquipmentUncheckedCreateInput>
  }


  /**
   * CharacterEquipment createMany
   */
  export type CharacterEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterEquipments.
     */
    data: CharacterEquipmentCreateManyInput | CharacterEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterEquipment update
   */
  export type CharacterEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterEquipment.
     */
    data: XOR<CharacterEquipmentUpdateInput, CharacterEquipmentUncheckedUpdateInput>
    /**
     * Choose, which CharacterEquipment to update.
     */
    where: CharacterEquipmentWhereUniqueInput
  }


  /**
   * CharacterEquipment updateMany
   */
  export type CharacterEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterEquipments.
     */
    data: XOR<CharacterEquipmentUpdateManyMutationInput, CharacterEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which CharacterEquipments to update
     */
    where?: CharacterEquipmentWhereInput
  }


  /**
   * CharacterEquipment upsert
   */
  export type CharacterEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterEquipment to update in case it exists.
     */
    where: CharacterEquipmentWhereUniqueInput
    /**
     * In case the CharacterEquipment found by the `where` argument doesn't exist, create a new CharacterEquipment with this data.
     */
    create: XOR<CharacterEquipmentCreateInput, CharacterEquipmentUncheckedCreateInput>
    /**
     * In case the CharacterEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterEquipmentUpdateInput, CharacterEquipmentUncheckedUpdateInput>
  }


  /**
   * CharacterEquipment delete
   */
  export type CharacterEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter which CharacterEquipment to delete.
     */
    where: CharacterEquipmentWhereUniqueInput
  }


  /**
   * CharacterEquipment deleteMany
   */
  export type CharacterEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterEquipments to delete
     */
    where?: CharacterEquipmentWhereInput
  }


  /**
   * CharacterEquipment.CharacterVersion
   */
  export type CharacterEquipment$CharacterVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVersion
     */
    select?: CharacterVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterVersionInclude<ExtArgs> | null
    where?: CharacterVersionWhereInput
    orderBy?: CharacterVersionOrderByWithRelationInput | CharacterVersionOrderByWithRelationInput[]
    cursor?: CharacterVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterVersionScalarFieldEnum | CharacterVersionScalarFieldEnum[]
  }


  /**
   * CharacterEquipment without action
   */
  export type CharacterEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
  }



  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    timer: number | null
    rent: number | null
    netStat: number | null
    weight: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    timer: number | null
    rent: number | null
    netStat: number | null
    weight: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    shortDescription: string | null
    longDescription: string | null
    timer: number | null
    align: $Enums.Align | null
    rent: number | null
    preservable: boolean | null
    netStat: number | null
    notes: string | null
    weight: number | null
    slots: string | null
    isBonded: boolean | null
    isCastable: boolean | null
    isHeroic: boolean | null
    isLevelRequired: boolean | null
    isLight: boolean | null
    isLimited: boolean | null
    isSoulbound: boolean | null
    isUnique: boolean | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    shortDescription: string | null
    longDescription: string | null
    timer: number | null
    align: $Enums.Align | null
    rent: number | null
    preservable: boolean | null
    netStat: number | null
    notes: string | null
    weight: number | null
    slots: string | null
    isBonded: boolean | null
    isCastable: boolean | null
    isHeroic: boolean | null
    isLevelRequired: boolean | null
    isLight: boolean | null
    isLimited: boolean | null
    isSoulbound: boolean | null
    isUnique: boolean | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    modifiedDate: number
    modifiedBy: number
    shortDescription: number
    longDescription: number
    timer: number
    align: number
    rent: number
    preservable: number
    netStat: number
    notes: number
    weight: number
    slots: number
    isBonded: number
    isCastable: number
    isHeroic: number
    isLevelRequired: number
    isLight: number
    isLimited: number
    isSoulbound: number
    isUnique: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    timer?: true
    rent?: true
    netStat?: true
    weight?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    timer?: true
    rent?: true
    netStat?: true
    weight?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    shortDescription?: true
    longDescription?: true
    timer?: true
    align?: true
    rent?: true
    preservable?: true
    netStat?: true
    notes?: true
    weight?: true
    slots?: true
    isBonded?: true
    isCastable?: true
    isHeroic?: true
    isLevelRequired?: true
    isLight?: true
    isLimited?: true
    isSoulbound?: true
    isUnique?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    shortDescription?: true
    longDescription?: true
    timer?: true
    align?: true
    rent?: true
    preservable?: true
    netStat?: true
    notes?: true
    weight?: true
    slots?: true
    isBonded?: true
    isCastable?: true
    isHeroic?: true
    isLevelRequired?: true
    isLight?: true
    isLimited?: true
    isSoulbound?: true
    isUnique?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    shortDescription?: true
    longDescription?: true
    timer?: true
    align?: true
    rent?: true
    preservable?: true
    netStat?: true
    notes?: true
    weight?: true
    slots?: true
    isBonded?: true
    isCastable?: true
    isHeroic?: true
    isLevelRequired?: true
    isLight?: true
    isLimited?: true
    isSoulbound?: true
    isUnique?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    modifiedDate: Date | null
    modifiedBy: number | null
    shortDescription: string
    longDescription: string | null
    timer: number | null
    align: $Enums.Align | null
    rent: number | null
    preservable: boolean | null
    netStat: number | null
    notes: string | null
    weight: number | null
    slots: string | null
    isBonded: boolean | null
    isCastable: boolean | null
    isHeroic: boolean | null
    isLevelRequired: boolean | null
    isLight: boolean | null
    isLimited: boolean | null
    isSoulbound: boolean | null
    isUnique: boolean | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    timer?: boolean
    align?: boolean
    rent?: boolean
    preservable?: boolean
    netStat?: boolean
    notes?: boolean
    weight?: boolean
    slots?: boolean
    isBonded?: boolean
    isCastable?: boolean
    isHeroic?: boolean
    isLevelRequired?: boolean
    isLight?: boolean
    isLimited?: boolean
    isSoulbound?: boolean
    isUnique?: boolean
    CreatedItems?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedItems?: boolean | Item$ModifiedItemsArgs<ExtArgs>
    ItemSpell?: boolean | Item$ItemSpellArgs<ExtArgs>
    ItemWeapon?: boolean | Item$ItemWeaponArgs<ExtArgs>
    AmmoItem?: boolean | Item$AmmoItemArgs<ExtArgs>
    StatModifer?: boolean | Item$StatModiferArgs<ExtArgs>
    ItemTagSource?: boolean | Item$ItemTagSourceArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    timer?: boolean
    align?: boolean
    rent?: boolean
    preservable?: boolean
    netStat?: boolean
    notes?: boolean
    weight?: boolean
    slots?: boolean
    isBonded?: boolean
    isCastable?: boolean
    isHeroic?: boolean
    isLevelRequired?: boolean
    isLight?: boolean
    isLimited?: boolean
    isSoulbound?: boolean
    isUnique?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedItems?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedItems?: boolean | Item$ModifiedItemsArgs<ExtArgs>
    ItemSpell?: boolean | Item$ItemSpellArgs<ExtArgs>
    ItemWeapon?: boolean | Item$ItemWeaponArgs<ExtArgs>
    AmmoItem?: boolean | Item$AmmoItemArgs<ExtArgs>
    StatModifer?: boolean | Item$StatModiferArgs<ExtArgs>
    ItemTagSource?: boolean | Item$ItemTagSourceArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      CreatedItems: Prisma.$AccountPayload<ExtArgs>
      ModifiedItems: Prisma.$AccountPayload<ExtArgs> | null
      ItemSpell: Prisma.$ItemSpellPayload<ExtArgs>[]
      ItemWeapon: Prisma.$ItemWeaponPayload<ExtArgs> | null
      AmmoItem: Prisma.$ItemWeaponPayload<ExtArgs>[]
      StatModifer: Prisma.$StatModiferPayload<ExtArgs> | null
      ItemTagSource: Prisma.$AppliedTagPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      modifiedDate: Date | null
      modifiedBy: number | null
      shortDescription: string
      longDescription: string | null
      timer: number | null
      align: $Enums.Align | null
      rent: number | null
      preservable: boolean | null
      netStat: number | null
      notes: string | null
      weight: number | null
      slots: string | null
      isBonded: boolean | null
      isCastable: boolean | null
      isHeroic: boolean | null
      isLevelRequired: boolean | null
      isLight: boolean | null
      isLimited: boolean | null
      isSoulbound: boolean | null
      isUnique: boolean | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }


  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCreateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CreatedItems<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ModifiedItems<T extends Item$ModifiedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$ModifiedItemsArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ItemSpell<T extends Item$ItemSpellArgs<ExtArgs> = {}>(args?: Subset<T, Item$ItemSpellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    ItemWeapon<T extends Item$ItemWeaponArgs<ExtArgs> = {}>(args?: Subset<T, Item$ItemWeaponArgs<ExtArgs>>): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    AmmoItem<T extends Item$AmmoItemArgs<ExtArgs> = {}>(args?: Subset<T, Item$AmmoItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'findMany'> | Null>;

    StatModifer<T extends Item$StatModiferArgs<ExtArgs> = {}>(args?: Subset<T, Item$StatModiferArgs<ExtArgs>>): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ItemTagSource<T extends Item$ItemTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, Item$ItemTagSourceArgs<ExtArgs>>): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'Int'>
    readonly createdDate: FieldRef<"Item", 'DateTime'>
    readonly createdBy: FieldRef<"Item", 'Int'>
    readonly modifiedDate: FieldRef<"Item", 'DateTime'>
    readonly modifiedBy: FieldRef<"Item", 'Int'>
    readonly shortDescription: FieldRef<"Item", 'String'>
    readonly longDescription: FieldRef<"Item", 'String'>
    readonly timer: FieldRef<"Item", 'Int'>
    readonly align: FieldRef<"Item", 'Align'>
    readonly rent: FieldRef<"Item", 'Int'>
    readonly preservable: FieldRef<"Item", 'Boolean'>
    readonly netStat: FieldRef<"Item", 'Int'>
    readonly notes: FieldRef<"Item", 'String'>
    readonly weight: FieldRef<"Item", 'Float'>
    readonly slots: FieldRef<"Item", 'String'>
    readonly isBonded: FieldRef<"Item", 'Boolean'>
    readonly isCastable: FieldRef<"Item", 'Boolean'>
    readonly isHeroic: FieldRef<"Item", 'Boolean'>
    readonly isLevelRequired: FieldRef<"Item", 'Boolean'>
    readonly isLight: FieldRef<"Item", 'Boolean'>
    readonly isLimited: FieldRef<"Item", 'Boolean'>
    readonly isSoulbound: FieldRef<"Item", 'Boolean'>
    readonly isUnique: FieldRef<"Item", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }


  /**
   * Item.ModifiedItems
   */
  export type Item$ModifiedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }


  /**
   * Item.ItemSpell
   */
  export type Item$ItemSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    where?: ItemSpellWhereInput
    orderBy?: ItemSpellOrderByWithRelationInput | ItemSpellOrderByWithRelationInput[]
    cursor?: ItemSpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSpellScalarFieldEnum | ItemSpellScalarFieldEnum[]
  }


  /**
   * Item.ItemWeapon
   */
  export type Item$ItemWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    where?: ItemWeaponWhereInput
  }


  /**
   * Item.AmmoItem
   */
  export type Item$AmmoItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    where?: ItemWeaponWhereInput
    orderBy?: ItemWeaponOrderByWithRelationInput | ItemWeaponOrderByWithRelationInput[]
    cursor?: ItemWeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemWeaponScalarFieldEnum | ItemWeaponScalarFieldEnum[]
  }


  /**
   * Item.StatModifer
   */
  export type Item$StatModiferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    where?: StatModiferWhereInput
  }


  /**
   * Item.ItemTagSource
   */
  export type Item$ItemTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    where?: AppliedTagWhereInput
  }


  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
  }



  /**
   * Model ItemWeapon
   */

  export type AggregateItemWeapon = {
    _count: ItemWeaponCountAggregateOutputType | null
    _avg: ItemWeaponAvgAggregateOutputType | null
    _sum: ItemWeaponSumAggregateOutputType | null
    _min: ItemWeaponMinAggregateOutputType | null
    _max: ItemWeaponMaxAggregateOutputType | null
  }

  export type ItemWeaponAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    quality: number | null
    speed: number | null
    ammoCapacity: number | null
    ammoTypeId: number | null
    shotAccuracy: number | null
    maxDamage: number | null
    minDamage: number | null
    avgDamage: number | null
  }

  export type ItemWeaponSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    quality: number | null
    speed: number | null
    ammoCapacity: number | null
    ammoTypeId: number | null
    shotAccuracy: number | null
    maxDamage: number | null
    minDamage: number | null
    avgDamage: number | null
  }

  export type ItemWeaponMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    quality: number | null
    speed: number | null
    isHoldable: boolean | null
    isTwoHanded: boolean | null
    ammoCapacity: number | null
    ammoTypeId: number | null
    shotAccuracy: number | null
    maxDamage: number | null
    minDamage: number | null
    avgDamage: number | null
    stat: $Enums.WeaponStat | null
    type: $Enums.WeaponType | null
  }

  export type ItemWeaponMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    quality: number | null
    speed: number | null
    isHoldable: boolean | null
    isTwoHanded: boolean | null
    ammoCapacity: number | null
    ammoTypeId: number | null
    shotAccuracy: number | null
    maxDamage: number | null
    minDamage: number | null
    avgDamage: number | null
    stat: $Enums.WeaponStat | null
    type: $Enums.WeaponType | null
  }

  export type ItemWeaponCountAggregateOutputType = {
    id: number
    itemId: number
    quality: number
    speed: number
    isHoldable: number
    isTwoHanded: number
    ammoCapacity: number
    ammoTypeId: number
    shotAccuracy: number
    maxDamage: number
    minDamage: number
    avgDamage: number
    stat: number
    type: number
    _all: number
  }


  export type ItemWeaponAvgAggregateInputType = {
    id?: true
    itemId?: true
    quality?: true
    speed?: true
    ammoCapacity?: true
    ammoTypeId?: true
    shotAccuracy?: true
    maxDamage?: true
    minDamage?: true
    avgDamage?: true
  }

  export type ItemWeaponSumAggregateInputType = {
    id?: true
    itemId?: true
    quality?: true
    speed?: true
    ammoCapacity?: true
    ammoTypeId?: true
    shotAccuracy?: true
    maxDamage?: true
    minDamage?: true
    avgDamage?: true
  }

  export type ItemWeaponMinAggregateInputType = {
    id?: true
    itemId?: true
    quality?: true
    speed?: true
    isHoldable?: true
    isTwoHanded?: true
    ammoCapacity?: true
    ammoTypeId?: true
    shotAccuracy?: true
    maxDamage?: true
    minDamage?: true
    avgDamage?: true
    stat?: true
    type?: true
  }

  export type ItemWeaponMaxAggregateInputType = {
    id?: true
    itemId?: true
    quality?: true
    speed?: true
    isHoldable?: true
    isTwoHanded?: true
    ammoCapacity?: true
    ammoTypeId?: true
    shotAccuracy?: true
    maxDamage?: true
    minDamage?: true
    avgDamage?: true
    stat?: true
    type?: true
  }

  export type ItemWeaponCountAggregateInputType = {
    id?: true
    itemId?: true
    quality?: true
    speed?: true
    isHoldable?: true
    isTwoHanded?: true
    ammoCapacity?: true
    ammoTypeId?: true
    shotAccuracy?: true
    maxDamage?: true
    minDamage?: true
    avgDamage?: true
    stat?: true
    type?: true
    _all?: true
  }

  export type ItemWeaponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemWeapon to aggregate.
     */
    where?: ItemWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWeapons to fetch.
     */
    orderBy?: ItemWeaponOrderByWithRelationInput | ItemWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemWeapons
    **/
    _count?: true | ItemWeaponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemWeaponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemWeaponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemWeaponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemWeaponMaxAggregateInputType
  }

  export type GetItemWeaponAggregateType<T extends ItemWeaponAggregateArgs> = {
        [P in keyof T & keyof AggregateItemWeapon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemWeapon[P]>
      : GetScalarType<T[P], AggregateItemWeapon[P]>
  }




  export type ItemWeaponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWeaponWhereInput
    orderBy?: ItemWeaponOrderByWithAggregationInput | ItemWeaponOrderByWithAggregationInput[]
    by: ItemWeaponScalarFieldEnum[] | ItemWeaponScalarFieldEnum
    having?: ItemWeaponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemWeaponCountAggregateInputType | true
    _avg?: ItemWeaponAvgAggregateInputType
    _sum?: ItemWeaponSumAggregateInputType
    _min?: ItemWeaponMinAggregateInputType
    _max?: ItemWeaponMaxAggregateInputType
  }

  export type ItemWeaponGroupByOutputType = {
    id: number
    itemId: number
    quality: number | null
    speed: number | null
    isHoldable: boolean
    isTwoHanded: boolean
    ammoCapacity: number | null
    ammoTypeId: number
    shotAccuracy: number | null
    maxDamage: number | null
    minDamage: number | null
    avgDamage: number | null
    stat: $Enums.WeaponStat | null
    type: $Enums.WeaponType | null
    _count: ItemWeaponCountAggregateOutputType | null
    _avg: ItemWeaponAvgAggregateOutputType | null
    _sum: ItemWeaponSumAggregateOutputType | null
    _min: ItemWeaponMinAggregateOutputType | null
    _max: ItemWeaponMaxAggregateOutputType | null
  }

  type GetItemWeaponGroupByPayload<T extends ItemWeaponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemWeaponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemWeaponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemWeaponGroupByOutputType[P]>
            : GetScalarType<T[P], ItemWeaponGroupByOutputType[P]>
        }
      >
    >


  export type ItemWeaponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    quality?: boolean
    speed?: boolean
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: boolean
    ammoTypeId?: boolean
    shotAccuracy?: boolean
    maxDamage?: boolean
    minDamage?: boolean
    avgDamage?: boolean
    stat?: boolean
    type?: boolean
    Item?: boolean | ItemDefaultArgs<ExtArgs>
    AmmoItem?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemWeapon"]>

  export type ItemWeaponSelectScalar = {
    id?: boolean
    itemId?: boolean
    quality?: boolean
    speed?: boolean
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: boolean
    ammoTypeId?: boolean
    shotAccuracy?: boolean
    maxDamage?: boolean
    minDamage?: boolean
    avgDamage?: boolean
    stat?: boolean
    type?: boolean
  }

  export type ItemWeaponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Item?: boolean | ItemDefaultArgs<ExtArgs>
    AmmoItem?: boolean | ItemDefaultArgs<ExtArgs>
  }


  export type $ItemWeaponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemWeapon"
    objects: {
      Item: Prisma.$ItemPayload<ExtArgs>
      AmmoItem: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      quality: number | null
      speed: number | null
      isHoldable: boolean
      isTwoHanded: boolean
      ammoCapacity: number | null
      ammoTypeId: number
      shotAccuracy: number | null
      maxDamage: number | null
      minDamage: number | null
      avgDamage: number | null
      stat: $Enums.WeaponStat | null
      type: $Enums.WeaponType | null
    }, ExtArgs["result"]["itemWeapon"]>
    composites: {}
  }


  type ItemWeaponGetPayload<S extends boolean | null | undefined | ItemWeaponDefaultArgs> = $Result.GetResult<Prisma.$ItemWeaponPayload, S>

  type ItemWeaponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemWeaponFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ItemWeaponCountAggregateInputType | true
    }

  export interface ItemWeaponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemWeapon'], meta: { name: 'ItemWeapon' } }
    /**
     * Find zero or one ItemWeapon that matches the filter.
     * @param {ItemWeaponFindUniqueArgs} args - Arguments to find a ItemWeapon
     * @example
     * // Get one ItemWeapon
     * const itemWeapon = await prisma.itemWeapon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemWeaponFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWeaponFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemWeapon that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemWeaponFindUniqueOrThrowArgs} args - Arguments to find a ItemWeapon
     * @example
     * // Get one ItemWeapon
     * const itemWeapon = await prisma.itemWeapon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemWeaponFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWeaponFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemWeapon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWeaponFindFirstArgs} args - Arguments to find a ItemWeapon
     * @example
     * // Get one ItemWeapon
     * const itemWeapon = await prisma.itemWeapon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemWeaponFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWeaponFindFirstArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemWeapon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWeaponFindFirstOrThrowArgs} args - Arguments to find a ItemWeapon
     * @example
     * // Get one ItemWeapon
     * const itemWeapon = await prisma.itemWeapon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemWeaponFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWeaponFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemWeapons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWeaponFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemWeapons
     * const itemWeapons = await prisma.itemWeapon.findMany()
     * 
     * // Get first 10 ItemWeapons
     * const itemWeapons = await prisma.itemWeapon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWeaponWithIdOnly = await prisma.itemWeapon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemWeaponFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWeaponFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemWeapon.
     * @param {ItemWeaponCreateArgs} args - Arguments to create a ItemWeapon.
     * @example
     * // Create one ItemWeapon
     * const ItemWeapon = await prisma.itemWeapon.create({
     *   data: {
     *     // ... data to create a ItemWeapon
     *   }
     * })
     * 
    **/
    create<T extends ItemWeaponCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWeaponCreateArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemWeapons.
     *     @param {ItemWeaponCreateManyArgs} args - Arguments to create many ItemWeapons.
     *     @example
     *     // Create many ItemWeapons
     *     const itemWeapon = await prisma.itemWeapon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemWeaponCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWeaponCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemWeapon.
     * @param {ItemWeaponDeleteArgs} args - Arguments to delete one ItemWeapon.
     * @example
     * // Delete one ItemWeapon
     * const ItemWeapon = await prisma.itemWeapon.delete({
     *   where: {
     *     // ... filter to delete one ItemWeapon
     *   }
     * })
     * 
    **/
    delete<T extends ItemWeaponDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWeaponDeleteArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemWeapon.
     * @param {ItemWeaponUpdateArgs} args - Arguments to update one ItemWeapon.
     * @example
     * // Update one ItemWeapon
     * const itemWeapon = await prisma.itemWeapon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemWeaponUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWeaponUpdateArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemWeapons.
     * @param {ItemWeaponDeleteManyArgs} args - Arguments to filter ItemWeapons to delete.
     * @example
     * // Delete a few ItemWeapons
     * const { count } = await prisma.itemWeapon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemWeaponDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWeaponDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemWeapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWeaponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemWeapons
     * const itemWeapon = await prisma.itemWeapon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemWeaponUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWeaponUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemWeapon.
     * @param {ItemWeaponUpsertArgs} args - Arguments to update or create a ItemWeapon.
     * @example
     * // Update or create a ItemWeapon
     * const itemWeapon = await prisma.itemWeapon.upsert({
     *   create: {
     *     // ... data to create a ItemWeapon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemWeapon we want to update
     *   }
     * })
    **/
    upsert<T extends ItemWeaponUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWeaponUpsertArgs<ExtArgs>>
    ): Prisma__ItemWeaponClient<$Result.GetResult<Prisma.$ItemWeaponPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemWeapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWeaponCountArgs} args - Arguments to filter ItemWeapons to count.
     * @example
     * // Count the number of ItemWeapons
     * const count = await prisma.itemWeapon.count({
     *   where: {
     *     // ... the filter for the ItemWeapons we want to count
     *   }
     * })
    **/
    count<T extends ItemWeaponCountArgs>(
      args?: Subset<T, ItemWeaponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemWeaponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemWeapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWeaponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemWeaponAggregateArgs>(args: Subset<T, ItemWeaponAggregateArgs>): Prisma.PrismaPromise<GetItemWeaponAggregateType<T>>

    /**
     * Group by ItemWeapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWeaponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemWeaponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemWeaponGroupByArgs['orderBy'] }
        : { orderBy?: ItemWeaponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemWeaponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemWeaponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemWeapon model
   */
  readonly fields: ItemWeaponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemWeapon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemWeaponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    AmmoItem<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemWeapon model
   */ 
  interface ItemWeaponFieldRefs {
    readonly id: FieldRef<"ItemWeapon", 'Int'>
    readonly itemId: FieldRef<"ItemWeapon", 'Int'>
    readonly quality: FieldRef<"ItemWeapon", 'Int'>
    readonly speed: FieldRef<"ItemWeapon", 'Int'>
    readonly isHoldable: FieldRef<"ItemWeapon", 'Boolean'>
    readonly isTwoHanded: FieldRef<"ItemWeapon", 'Boolean'>
    readonly ammoCapacity: FieldRef<"ItemWeapon", 'Int'>
    readonly ammoTypeId: FieldRef<"ItemWeapon", 'Int'>
    readonly shotAccuracy: FieldRef<"ItemWeapon", 'Int'>
    readonly maxDamage: FieldRef<"ItemWeapon", 'Int'>
    readonly minDamage: FieldRef<"ItemWeapon", 'Int'>
    readonly avgDamage: FieldRef<"ItemWeapon", 'Int'>
    readonly stat: FieldRef<"ItemWeapon", 'WeaponStat'>
    readonly type: FieldRef<"ItemWeapon", 'WeaponType'>
  }
    

  // Custom InputTypes

  /**
   * ItemWeapon findUnique
   */
  export type ItemWeaponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * Filter, which ItemWeapon to fetch.
     */
    where: ItemWeaponWhereUniqueInput
  }


  /**
   * ItemWeapon findUniqueOrThrow
   */
  export type ItemWeaponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * Filter, which ItemWeapon to fetch.
     */
    where: ItemWeaponWhereUniqueInput
  }


  /**
   * ItemWeapon findFirst
   */
  export type ItemWeaponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * Filter, which ItemWeapon to fetch.
     */
    where?: ItemWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWeapons to fetch.
     */
    orderBy?: ItemWeaponOrderByWithRelationInput | ItemWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemWeapons.
     */
    cursor?: ItemWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemWeapons.
     */
    distinct?: ItemWeaponScalarFieldEnum | ItemWeaponScalarFieldEnum[]
  }


  /**
   * ItemWeapon findFirstOrThrow
   */
  export type ItemWeaponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * Filter, which ItemWeapon to fetch.
     */
    where?: ItemWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWeapons to fetch.
     */
    orderBy?: ItemWeaponOrderByWithRelationInput | ItemWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemWeapons.
     */
    cursor?: ItemWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemWeapons.
     */
    distinct?: ItemWeaponScalarFieldEnum | ItemWeaponScalarFieldEnum[]
  }


  /**
   * ItemWeapon findMany
   */
  export type ItemWeaponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * Filter, which ItemWeapons to fetch.
     */
    where?: ItemWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWeapons to fetch.
     */
    orderBy?: ItemWeaponOrderByWithRelationInput | ItemWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemWeapons.
     */
    cursor?: ItemWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWeapons.
     */
    skip?: number
    distinct?: ItemWeaponScalarFieldEnum | ItemWeaponScalarFieldEnum[]
  }


  /**
   * ItemWeapon create
   */
  export type ItemWeaponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemWeapon.
     */
    data: XOR<ItemWeaponCreateInput, ItemWeaponUncheckedCreateInput>
  }


  /**
   * ItemWeapon createMany
   */
  export type ItemWeaponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemWeapons.
     */
    data: ItemWeaponCreateManyInput | ItemWeaponCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemWeapon update
   */
  export type ItemWeaponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemWeapon.
     */
    data: XOR<ItemWeaponUpdateInput, ItemWeaponUncheckedUpdateInput>
    /**
     * Choose, which ItemWeapon to update.
     */
    where: ItemWeaponWhereUniqueInput
  }


  /**
   * ItemWeapon updateMany
   */
  export type ItemWeaponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemWeapons.
     */
    data: XOR<ItemWeaponUpdateManyMutationInput, ItemWeaponUncheckedUpdateManyInput>
    /**
     * Filter which ItemWeapons to update
     */
    where?: ItemWeaponWhereInput
  }


  /**
   * ItemWeapon upsert
   */
  export type ItemWeaponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemWeapon to update in case it exists.
     */
    where: ItemWeaponWhereUniqueInput
    /**
     * In case the ItemWeapon found by the `where` argument doesn't exist, create a new ItemWeapon with this data.
     */
    create: XOR<ItemWeaponCreateInput, ItemWeaponUncheckedCreateInput>
    /**
     * In case the ItemWeapon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemWeaponUpdateInput, ItemWeaponUncheckedUpdateInput>
  }


  /**
   * ItemWeapon delete
   */
  export type ItemWeaponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
    /**
     * Filter which ItemWeapon to delete.
     */
    where: ItemWeaponWhereUniqueInput
  }


  /**
   * ItemWeapon deleteMany
   */
  export type ItemWeaponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemWeapons to delete
     */
    where?: ItemWeaponWhereInput
  }


  /**
   * ItemWeapon without action
   */
  export type ItemWeaponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWeapon
     */
    select?: ItemWeaponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemWeaponInclude<ExtArgs> | null
  }



  /**
   * Model ItemSpell
   */

  export type AggregateItemSpell = {
    _count: ItemSpellCountAggregateOutputType | null
    _avg: ItemSpellAvgAggregateOutputType | null
    _sum: ItemSpellSumAggregateOutputType | null
    _min: ItemSpellMinAggregateOutputType | null
    _max: ItemSpellMaxAggregateOutputType | null
  }

  export type ItemSpellAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    spellId: number | null
  }

  export type ItemSpellSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    spellId: number | null
  }

  export type ItemSpellMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    spellId: number | null
  }

  export type ItemSpellMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    spellId: number | null
  }

  export type ItemSpellCountAggregateOutputType = {
    id: number
    itemId: number
    spellId: number
    _all: number
  }


  export type ItemSpellAvgAggregateInputType = {
    id?: true
    itemId?: true
    spellId?: true
  }

  export type ItemSpellSumAggregateInputType = {
    id?: true
    itemId?: true
    spellId?: true
  }

  export type ItemSpellMinAggregateInputType = {
    id?: true
    itemId?: true
    spellId?: true
  }

  export type ItemSpellMaxAggregateInputType = {
    id?: true
    itemId?: true
    spellId?: true
  }

  export type ItemSpellCountAggregateInputType = {
    id?: true
    itemId?: true
    spellId?: true
    _all?: true
  }

  export type ItemSpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSpell to aggregate.
     */
    where?: ItemSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSpells to fetch.
     */
    orderBy?: ItemSpellOrderByWithRelationInput | ItemSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemSpells
    **/
    _count?: true | ItemSpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemSpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemSpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemSpellMaxAggregateInputType
  }

  export type GetItemSpellAggregateType<T extends ItemSpellAggregateArgs> = {
        [P in keyof T & keyof AggregateItemSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemSpell[P]>
      : GetScalarType<T[P], AggregateItemSpell[P]>
  }




  export type ItemSpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSpellWhereInput
    orderBy?: ItemSpellOrderByWithAggregationInput | ItemSpellOrderByWithAggregationInput[]
    by: ItemSpellScalarFieldEnum[] | ItemSpellScalarFieldEnum
    having?: ItemSpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemSpellCountAggregateInputType | true
    _avg?: ItemSpellAvgAggregateInputType
    _sum?: ItemSpellSumAggregateInputType
    _min?: ItemSpellMinAggregateInputType
    _max?: ItemSpellMaxAggregateInputType
  }

  export type ItemSpellGroupByOutputType = {
    id: number
    itemId: number
    spellId: number
    _count: ItemSpellCountAggregateOutputType | null
    _avg: ItemSpellAvgAggregateOutputType | null
    _sum: ItemSpellSumAggregateOutputType | null
    _min: ItemSpellMinAggregateOutputType | null
    _max: ItemSpellMaxAggregateOutputType | null
  }

  type GetItemSpellGroupByPayload<T extends ItemSpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemSpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemSpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemSpellGroupByOutputType[P]>
            : GetScalarType<T[P], ItemSpellGroupByOutputType[P]>
        }
      >
    >


  export type ItemSpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    spellId?: boolean
    Item?: boolean | ItemDefaultArgs<ExtArgs>
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSpell"]>

  export type ItemSpellSelectScalar = {
    id?: boolean
    itemId?: boolean
    spellId?: boolean
  }

  export type ItemSpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Item?: boolean | ItemDefaultArgs<ExtArgs>
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $ItemSpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemSpell"
    objects: {
      Item: Prisma.$ItemPayload<ExtArgs>
      Spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      spellId: number
    }, ExtArgs["result"]["itemSpell"]>
    composites: {}
  }


  type ItemSpellGetPayload<S extends boolean | null | undefined | ItemSpellDefaultArgs> = $Result.GetResult<Prisma.$ItemSpellPayload, S>

  type ItemSpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemSpellFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ItemSpellCountAggregateInputType | true
    }

  export interface ItemSpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemSpell'], meta: { name: 'ItemSpell' } }
    /**
     * Find zero or one ItemSpell that matches the filter.
     * @param {ItemSpellFindUniqueArgs} args - Arguments to find a ItemSpell
     * @example
     * // Get one ItemSpell
     * const itemSpell = await prisma.itemSpell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemSpellFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemSpellFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemSpell that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemSpellFindUniqueOrThrowArgs} args - Arguments to find a ItemSpell
     * @example
     * // Get one ItemSpell
     * const itemSpell = await prisma.itemSpell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemSpellFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemSpellFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemSpell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSpellFindFirstArgs} args - Arguments to find a ItemSpell
     * @example
     * // Get one ItemSpell
     * const itemSpell = await prisma.itemSpell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemSpellFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemSpellFindFirstArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemSpell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSpellFindFirstOrThrowArgs} args - Arguments to find a ItemSpell
     * @example
     * // Get one ItemSpell
     * const itemSpell = await prisma.itemSpell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemSpellFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemSpellFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSpellFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemSpells
     * const itemSpells = await prisma.itemSpell.findMany()
     * 
     * // Get first 10 ItemSpells
     * const itemSpells = await prisma.itemSpell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemSpellWithIdOnly = await prisma.itemSpell.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemSpellFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemSpellFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemSpell.
     * @param {ItemSpellCreateArgs} args - Arguments to create a ItemSpell.
     * @example
     * // Create one ItemSpell
     * const ItemSpell = await prisma.itemSpell.create({
     *   data: {
     *     // ... data to create a ItemSpell
     *   }
     * })
     * 
    **/
    create<T extends ItemSpellCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemSpellCreateArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemSpells.
     *     @param {ItemSpellCreateManyArgs} args - Arguments to create many ItemSpells.
     *     @example
     *     // Create many ItemSpells
     *     const itemSpell = await prisma.itemSpell.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemSpellCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemSpellCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemSpell.
     * @param {ItemSpellDeleteArgs} args - Arguments to delete one ItemSpell.
     * @example
     * // Delete one ItemSpell
     * const ItemSpell = await prisma.itemSpell.delete({
     *   where: {
     *     // ... filter to delete one ItemSpell
     *   }
     * })
     * 
    **/
    delete<T extends ItemSpellDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemSpellDeleteArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemSpell.
     * @param {ItemSpellUpdateArgs} args - Arguments to update one ItemSpell.
     * @example
     * // Update one ItemSpell
     * const itemSpell = await prisma.itemSpell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemSpellUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemSpellUpdateArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemSpells.
     * @param {ItemSpellDeleteManyArgs} args - Arguments to filter ItemSpells to delete.
     * @example
     * // Delete a few ItemSpells
     * const { count } = await prisma.itemSpell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemSpellDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemSpellDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemSpells
     * const itemSpell = await prisma.itemSpell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemSpellUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemSpellUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemSpell.
     * @param {ItemSpellUpsertArgs} args - Arguments to update or create a ItemSpell.
     * @example
     * // Update or create a ItemSpell
     * const itemSpell = await prisma.itemSpell.upsert({
     *   create: {
     *     // ... data to create a ItemSpell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemSpell we want to update
     *   }
     * })
    **/
    upsert<T extends ItemSpellUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemSpellUpsertArgs<ExtArgs>>
    ): Prisma__ItemSpellClient<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSpellCountArgs} args - Arguments to filter ItemSpells to count.
     * @example
     * // Count the number of ItemSpells
     * const count = await prisma.itemSpell.count({
     *   where: {
     *     // ... the filter for the ItemSpells we want to count
     *   }
     * })
    **/
    count<T extends ItemSpellCountArgs>(
      args?: Subset<T, ItemSpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemSpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemSpellAggregateArgs>(args: Subset<T, ItemSpellAggregateArgs>): Prisma.PrismaPromise<GetItemSpellAggregateType<T>>

    /**
     * Group by ItemSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemSpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemSpellGroupByArgs['orderBy'] }
        : { orderBy?: ItemSpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemSpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemSpell model
   */
  readonly fields: ItemSpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemSpell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemSpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemSpell model
   */ 
  interface ItemSpellFieldRefs {
    readonly id: FieldRef<"ItemSpell", 'Int'>
    readonly itemId: FieldRef<"ItemSpell", 'Int'>
    readonly spellId: FieldRef<"ItemSpell", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ItemSpell findUnique
   */
  export type ItemSpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * Filter, which ItemSpell to fetch.
     */
    where: ItemSpellWhereUniqueInput
  }


  /**
   * ItemSpell findUniqueOrThrow
   */
  export type ItemSpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * Filter, which ItemSpell to fetch.
     */
    where: ItemSpellWhereUniqueInput
  }


  /**
   * ItemSpell findFirst
   */
  export type ItemSpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * Filter, which ItemSpell to fetch.
     */
    where?: ItemSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSpells to fetch.
     */
    orderBy?: ItemSpellOrderByWithRelationInput | ItemSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSpells.
     */
    cursor?: ItemSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSpells.
     */
    distinct?: ItemSpellScalarFieldEnum | ItemSpellScalarFieldEnum[]
  }


  /**
   * ItemSpell findFirstOrThrow
   */
  export type ItemSpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * Filter, which ItemSpell to fetch.
     */
    where?: ItemSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSpells to fetch.
     */
    orderBy?: ItemSpellOrderByWithRelationInput | ItemSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSpells.
     */
    cursor?: ItemSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSpells.
     */
    distinct?: ItemSpellScalarFieldEnum | ItemSpellScalarFieldEnum[]
  }


  /**
   * ItemSpell findMany
   */
  export type ItemSpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * Filter, which ItemSpells to fetch.
     */
    where?: ItemSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSpells to fetch.
     */
    orderBy?: ItemSpellOrderByWithRelationInput | ItemSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemSpells.
     */
    cursor?: ItemSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSpells.
     */
    skip?: number
    distinct?: ItemSpellScalarFieldEnum | ItemSpellScalarFieldEnum[]
  }


  /**
   * ItemSpell create
   */
  export type ItemSpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemSpell.
     */
    data: XOR<ItemSpellCreateInput, ItemSpellUncheckedCreateInput>
  }


  /**
   * ItemSpell createMany
   */
  export type ItemSpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemSpells.
     */
    data: ItemSpellCreateManyInput | ItemSpellCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemSpell update
   */
  export type ItemSpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemSpell.
     */
    data: XOR<ItemSpellUpdateInput, ItemSpellUncheckedUpdateInput>
    /**
     * Choose, which ItemSpell to update.
     */
    where: ItemSpellWhereUniqueInput
  }


  /**
   * ItemSpell updateMany
   */
  export type ItemSpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemSpells.
     */
    data: XOR<ItemSpellUpdateManyMutationInput, ItemSpellUncheckedUpdateManyInput>
    /**
     * Filter which ItemSpells to update
     */
    where?: ItemSpellWhereInput
  }


  /**
   * ItemSpell upsert
   */
  export type ItemSpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemSpell to update in case it exists.
     */
    where: ItemSpellWhereUniqueInput
    /**
     * In case the ItemSpell found by the `where` argument doesn't exist, create a new ItemSpell with this data.
     */
    create: XOR<ItemSpellCreateInput, ItemSpellUncheckedCreateInput>
    /**
     * In case the ItemSpell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemSpellUpdateInput, ItemSpellUncheckedUpdateInput>
  }


  /**
   * ItemSpell delete
   */
  export type ItemSpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    /**
     * Filter which ItemSpell to delete.
     */
    where: ItemSpellWhereUniqueInput
  }


  /**
   * ItemSpell deleteMany
   */
  export type ItemSpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSpells to delete
     */
    where?: ItemSpellWhereInput
  }


  /**
   * ItemSpell without action
   */
  export type ItemSpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
  }



  /**
   * Model Spell
   */

  export type AggregateSpell = {
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  export type SpellAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    levelRequirement: number | null
  }

  export type SpellSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    levelRequirement: number | null
  }

  export type SpellMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    words: string | null
    levelRequirement: number | null
  }

  export type SpellMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    words: string | null
    levelRequirement: number | null
  }

  export type SpellCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    modifiedDate: number
    modifiedBy: number
    name: number
    description: number
    notes: number
    words: number
    levelRequirement: number
    _all: number
  }


  export type SpellAvgAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    levelRequirement?: true
  }

  export type SpellSumAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    levelRequirement?: true
  }

  export type SpellMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    words?: true
    levelRequirement?: true
  }

  export type SpellMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    words?: true
    levelRequirement?: true
  }

  export type SpellCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    words?: true
    levelRequirement?: true
    _all?: true
  }

  export type SpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spell to aggregate.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spells
    **/
    _count?: true | SpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellMaxAggregateInputType
  }

  export type GetSpellAggregateType<T extends SpellAggregateArgs> = {
        [P in keyof T & keyof AggregateSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpell[P]>
      : GetScalarType<T[P], AggregateSpell[P]>
  }




  export type SpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithAggregationInput | SpellOrderByWithAggregationInput[]
    by: SpellScalarFieldEnum[] | SpellScalarFieldEnum
    having?: SpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellCountAggregateInputType | true
    _avg?: SpellAvgAggregateInputType
    _sum?: SpellSumAggregateInputType
    _min?: SpellMinAggregateInputType
    _max?: SpellMaxAggregateInputType
  }

  export type SpellGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    modifiedDate: Date
    modifiedBy: number
    name: string
    description: string | null
    notes: string | null
    words: string | null
    levelRequirement: number | null
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  type GetSpellGroupByPayload<T extends SpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellGroupByOutputType[P]>
            : GetScalarType<T[P], SpellGroupByOutputType[P]>
        }
      >
    >


  export type SpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    words?: boolean
    levelRequirement?: boolean
    ItemSpell?: boolean | Spell$ItemSpellArgs<ExtArgs>
    CreatedSpells?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedSpells?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Spell$StatModiferArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spell"]>

  export type SpellSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    words?: boolean
    levelRequirement?: boolean
  }

  export type SpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ItemSpell?: boolean | Spell$ItemSpellArgs<ExtArgs>
    CreatedSpells?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedSpells?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Spell$StatModiferArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Spell"
    objects: {
      ItemSpell: Prisma.$ItemSpellPayload<ExtArgs>[]
      CreatedSpells: Prisma.$AccountPayload<ExtArgs>
      ModifiedSpells: Prisma.$AccountPayload<ExtArgs>
      StatModifer: Prisma.$StatModiferPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      modifiedDate: Date
      modifiedBy: number
      name: string
      description: string | null
      notes: string | null
      words: string | null
      levelRequirement: number | null
    }, ExtArgs["result"]["spell"]>
    composites: {}
  }


  type SpellGetPayload<S extends boolean | null | undefined | SpellDefaultArgs> = $Result.GetResult<Prisma.$SpellPayload, S>

  type SpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SpellCountAggregateInputType | true
    }

  export interface SpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Spell'], meta: { name: 'Spell' } }
    /**
     * Find zero or one Spell that matches the filter.
     * @param {SpellFindUniqueArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Spell that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellFindUniqueOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Spell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindFirstArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Spell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Spells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spells
     * const spells = await prisma.spell.findMany()
     * 
     * // Get first 10 Spells
     * const spells = await prisma.spell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellWithIdOnly = await prisma.spell.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Spell.
     * @param {SpellCreateArgs} args - Arguments to create a Spell.
     * @example
     * // Create one Spell
     * const Spell = await prisma.spell.create({
     *   data: {
     *     // ... data to create a Spell
     *   }
     * })
     * 
    **/
    create<T extends SpellCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellCreateArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Spells.
     *     @param {SpellCreateManyArgs} args - Arguments to create many Spells.
     *     @example
     *     // Create many Spells
     *     const spell = await prisma.spell.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Spell.
     * @param {SpellDeleteArgs} args - Arguments to delete one Spell.
     * @example
     * // Delete one Spell
     * const Spell = await prisma.spell.delete({
     *   where: {
     *     // ... filter to delete one Spell
     *   }
     * })
     * 
    **/
    delete<T extends SpellDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellDeleteArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Spell.
     * @param {SpellUpdateArgs} args - Arguments to update one Spell.
     * @example
     * // Update one Spell
     * const spell = await prisma.spell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellUpdateArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Spells.
     * @param {SpellDeleteManyArgs} args - Arguments to filter Spells to delete.
     * @example
     * // Delete a few Spells
     * const { count } = await prisma.spell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spells
     * const spell = await prisma.spell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spell.
     * @param {SpellUpsertArgs} args - Arguments to update or create a Spell.
     * @example
     * // Update or create a Spell
     * const spell = await prisma.spell.upsert({
     *   create: {
     *     // ... data to create a Spell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spell we want to update
     *   }
     * })
    **/
    upsert<T extends SpellUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellUpsertArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellCountArgs} args - Arguments to filter Spells to count.
     * @example
     * // Count the number of Spells
     * const count = await prisma.spell.count({
     *   where: {
     *     // ... the filter for the Spells we want to count
     *   }
     * })
    **/
    count<T extends SpellCountArgs>(
      args?: Subset<T, SpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellAggregateArgs>(args: Subset<T, SpellAggregateArgs>): Prisma.PrismaPromise<GetSpellAggregateType<T>>

    /**
     * Group by Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellGroupByArgs['orderBy'] }
        : { orderBy?: SpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Spell model
   */
  readonly fields: SpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Spell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ItemSpell<T extends Spell$ItemSpellArgs<ExtArgs> = {}>(args?: Subset<T, Spell$ItemSpellArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    CreatedSpells<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ModifiedSpells<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    StatModifer<T extends Spell$StatModiferArgs<ExtArgs> = {}>(args?: Subset<T, Spell$StatModiferArgs<ExtArgs>>): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Spell model
   */ 
  interface SpellFieldRefs {
    readonly id: FieldRef<"Spell", 'Int'>
    readonly createdDate: FieldRef<"Spell", 'DateTime'>
    readonly createdBy: FieldRef<"Spell", 'Int'>
    readonly modifiedDate: FieldRef<"Spell", 'DateTime'>
    readonly modifiedBy: FieldRef<"Spell", 'Int'>
    readonly name: FieldRef<"Spell", 'String'>
    readonly description: FieldRef<"Spell", 'String'>
    readonly notes: FieldRef<"Spell", 'String'>
    readonly words: FieldRef<"Spell", 'String'>
    readonly levelRequirement: FieldRef<"Spell", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Spell findUnique
   */
  export type SpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell findUniqueOrThrow
   */
  export type SpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell findFirst
   */
  export type SpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Spell findFirstOrThrow
   */
  export type SpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Spell findMany
   */
  export type SpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spells to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Spell create
   */
  export type SpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to create a Spell.
     */
    data: XOR<SpellCreateInput, SpellUncheckedCreateInput>
  }


  /**
   * Spell createMany
   */
  export type SpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spells.
     */
    data: SpellCreateManyInput | SpellCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Spell update
   */
  export type SpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to update a Spell.
     */
    data: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
    /**
     * Choose, which Spell to update.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell updateMany
   */
  export type SpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spells.
     */
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyInput>
    /**
     * Filter which Spells to update
     */
    where?: SpellWhereInput
  }


  /**
   * Spell upsert
   */
  export type SpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The filter to search for the Spell to update in case it exists.
     */
    where: SpellWhereUniqueInput
    /**
     * In case the Spell found by the `where` argument doesn't exist, create a new Spell with this data.
     */
    create: XOR<SpellCreateInput, SpellUncheckedCreateInput>
    /**
     * In case the Spell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
  }


  /**
   * Spell delete
   */
  export type SpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter which Spell to delete.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell deleteMany
   */
  export type SpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spells to delete
     */
    where?: SpellWhereInput
  }


  /**
   * Spell.ItemSpell
   */
  export type Spell$ItemSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSpell
     */
    select?: ItemSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemSpellInclude<ExtArgs> | null
    where?: ItemSpellWhereInput
    orderBy?: ItemSpellOrderByWithRelationInput | ItemSpellOrderByWithRelationInput[]
    cursor?: ItemSpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSpellScalarFieldEnum | ItemSpellScalarFieldEnum[]
  }


  /**
   * Spell.StatModifer
   */
  export type Spell$StatModiferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    where?: StatModiferWhereInput
  }


  /**
   * Spell without action
   */
  export type SpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
  }



  /**
   * Model Potion
   */

  export type AggregatePotion = {
    _count: PotionCountAggregateOutputType | null
    _avg: PotionAvgAggregateOutputType | null
    _sum: PotionSumAggregateOutputType | null
    _min: PotionMinAggregateOutputType | null
    _max: PotionMaxAggregateOutputType | null
  }

  export type PotionAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    duration: number | null
  }

  export type PotionSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    duration: number | null
  }

  export type PotionMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    duration: number | null
  }

  export type PotionMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    duration: number | null
  }

  export type PotionCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    modifiedDate: number
    modifiedBy: number
    name: number
    description: number
    notes: number
    duration: number
    _all: number
  }


  export type PotionAvgAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    duration?: true
  }

  export type PotionSumAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    duration?: true
  }

  export type PotionMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    duration?: true
  }

  export type PotionMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    duration?: true
  }

  export type PotionCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    duration?: true
    _all?: true
  }

  export type PotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Potion to aggregate.
     */
    where?: PotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potions to fetch.
     */
    orderBy?: PotionOrderByWithRelationInput | PotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Potions
    **/
    _count?: true | PotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PotionMaxAggregateInputType
  }

  export type GetPotionAggregateType<T extends PotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePotion[P]>
      : GetScalarType<T[P], AggregatePotion[P]>
  }




  export type PotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PotionWhereInput
    orderBy?: PotionOrderByWithAggregationInput | PotionOrderByWithAggregationInput[]
    by: PotionScalarFieldEnum[] | PotionScalarFieldEnum
    having?: PotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PotionCountAggregateInputType | true
    _avg?: PotionAvgAggregateInputType
    _sum?: PotionSumAggregateInputType
    _min?: PotionMinAggregateInputType
    _max?: PotionMaxAggregateInputType
  }

  export type PotionGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    modifiedDate: Date
    modifiedBy: number
    name: string
    description: string | null
    notes: string | null
    duration: number | null
    _count: PotionCountAggregateOutputType | null
    _avg: PotionAvgAggregateOutputType | null
    _sum: PotionSumAggregateOutputType | null
    _min: PotionMinAggregateOutputType | null
    _max: PotionMaxAggregateOutputType | null
  }

  type GetPotionGroupByPayload<T extends PotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PotionGroupByOutputType[P]>
            : GetScalarType<T[P], PotionGroupByOutputType[P]>
        }
      >
    >


  export type PotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    duration?: boolean
    CreatedPotions?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedPotions?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Potion$StatModiferArgs<ExtArgs>
  }, ExtArgs["result"]["potion"]>

  export type PotionSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    duration?: boolean
  }

  export type PotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedPotions?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedPotions?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Potion$StatModiferArgs<ExtArgs>
  }


  export type $PotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Potion"
    objects: {
      CreatedPotions: Prisma.$AccountPayload<ExtArgs>
      ModifiedPotions: Prisma.$AccountPayload<ExtArgs>
      StatModifer: Prisma.$StatModiferPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      modifiedDate: Date
      modifiedBy: number
      name: string
      description: string | null
      notes: string | null
      duration: number | null
    }, ExtArgs["result"]["potion"]>
    composites: {}
  }


  type PotionGetPayload<S extends boolean | null | undefined | PotionDefaultArgs> = $Result.GetResult<Prisma.$PotionPayload, S>

  type PotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PotionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PotionCountAggregateInputType | true
    }

  export interface PotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Potion'], meta: { name: 'Potion' } }
    /**
     * Find zero or one Potion that matches the filter.
     * @param {PotionFindUniqueArgs} args - Arguments to find a Potion
     * @example
     * // Get one Potion
     * const potion = await prisma.potion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PotionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PotionFindUniqueArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Potion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PotionFindUniqueOrThrowArgs} args - Arguments to find a Potion
     * @example
     * // Get one Potion
     * const potion = await prisma.potion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PotionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PotionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Potion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotionFindFirstArgs} args - Arguments to find a Potion
     * @example
     * // Get one Potion
     * const potion = await prisma.potion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PotionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PotionFindFirstArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Potion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotionFindFirstOrThrowArgs} args - Arguments to find a Potion
     * @example
     * // Get one Potion
     * const potion = await prisma.potion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PotionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PotionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Potions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Potions
     * const potions = await prisma.potion.findMany()
     * 
     * // Get first 10 Potions
     * const potions = await prisma.potion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const potionWithIdOnly = await prisma.potion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PotionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PotionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Potion.
     * @param {PotionCreateArgs} args - Arguments to create a Potion.
     * @example
     * // Create one Potion
     * const Potion = await prisma.potion.create({
     *   data: {
     *     // ... data to create a Potion
     *   }
     * })
     * 
    **/
    create<T extends PotionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PotionCreateArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Potions.
     *     @param {PotionCreateManyArgs} args - Arguments to create many Potions.
     *     @example
     *     // Create many Potions
     *     const potion = await prisma.potion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PotionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PotionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Potion.
     * @param {PotionDeleteArgs} args - Arguments to delete one Potion.
     * @example
     * // Delete one Potion
     * const Potion = await prisma.potion.delete({
     *   where: {
     *     // ... filter to delete one Potion
     *   }
     * })
     * 
    **/
    delete<T extends PotionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PotionDeleteArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Potion.
     * @param {PotionUpdateArgs} args - Arguments to update one Potion.
     * @example
     * // Update one Potion
     * const potion = await prisma.potion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PotionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PotionUpdateArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Potions.
     * @param {PotionDeleteManyArgs} args - Arguments to filter Potions to delete.
     * @example
     * // Delete a few Potions
     * const { count } = await prisma.potion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PotionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PotionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Potions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Potions
     * const potion = await prisma.potion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PotionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PotionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Potion.
     * @param {PotionUpsertArgs} args - Arguments to update or create a Potion.
     * @example
     * // Update or create a Potion
     * const potion = await prisma.potion.upsert({
     *   create: {
     *     // ... data to create a Potion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Potion we want to update
     *   }
     * })
    **/
    upsert<T extends PotionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PotionUpsertArgs<ExtArgs>>
    ): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Potions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotionCountArgs} args - Arguments to filter Potions to count.
     * @example
     * // Count the number of Potions
     * const count = await prisma.potion.count({
     *   where: {
     *     // ... the filter for the Potions we want to count
     *   }
     * })
    **/
    count<T extends PotionCountArgs>(
      args?: Subset<T, PotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Potion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PotionAggregateArgs>(args: Subset<T, PotionAggregateArgs>): Prisma.PrismaPromise<GetPotionAggregateType<T>>

    /**
     * Group by Potion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PotionGroupByArgs['orderBy'] }
        : { orderBy?: PotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Potion model
   */
  readonly fields: PotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Potion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CreatedPotions<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ModifiedPotions<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    StatModifer<T extends Potion$StatModiferArgs<ExtArgs> = {}>(args?: Subset<T, Potion$StatModiferArgs<ExtArgs>>): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Potion model
   */ 
  interface PotionFieldRefs {
    readonly id: FieldRef<"Potion", 'Int'>
    readonly createdDate: FieldRef<"Potion", 'DateTime'>
    readonly createdBy: FieldRef<"Potion", 'Int'>
    readonly modifiedDate: FieldRef<"Potion", 'DateTime'>
    readonly modifiedBy: FieldRef<"Potion", 'Int'>
    readonly name: FieldRef<"Potion", 'String'>
    readonly description: FieldRef<"Potion", 'String'>
    readonly notes: FieldRef<"Potion", 'String'>
    readonly duration: FieldRef<"Potion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Potion findUnique
   */
  export type PotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * Filter, which Potion to fetch.
     */
    where: PotionWhereUniqueInput
  }


  /**
   * Potion findUniqueOrThrow
   */
  export type PotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * Filter, which Potion to fetch.
     */
    where: PotionWhereUniqueInput
  }


  /**
   * Potion findFirst
   */
  export type PotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * Filter, which Potion to fetch.
     */
    where?: PotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potions to fetch.
     */
    orderBy?: PotionOrderByWithRelationInput | PotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Potions.
     */
    cursor?: PotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Potions.
     */
    distinct?: PotionScalarFieldEnum | PotionScalarFieldEnum[]
  }


  /**
   * Potion findFirstOrThrow
   */
  export type PotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * Filter, which Potion to fetch.
     */
    where?: PotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potions to fetch.
     */
    orderBy?: PotionOrderByWithRelationInput | PotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Potions.
     */
    cursor?: PotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Potions.
     */
    distinct?: PotionScalarFieldEnum | PotionScalarFieldEnum[]
  }


  /**
   * Potion findMany
   */
  export type PotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * Filter, which Potions to fetch.
     */
    where?: PotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potions to fetch.
     */
    orderBy?: PotionOrderByWithRelationInput | PotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Potions.
     */
    cursor?: PotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potions.
     */
    skip?: number
    distinct?: PotionScalarFieldEnum | PotionScalarFieldEnum[]
  }


  /**
   * Potion create
   */
  export type PotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Potion.
     */
    data: XOR<PotionCreateInput, PotionUncheckedCreateInput>
  }


  /**
   * Potion createMany
   */
  export type PotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Potions.
     */
    data: PotionCreateManyInput | PotionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Potion update
   */
  export type PotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Potion.
     */
    data: XOR<PotionUpdateInput, PotionUncheckedUpdateInput>
    /**
     * Choose, which Potion to update.
     */
    where: PotionWhereUniqueInput
  }


  /**
   * Potion updateMany
   */
  export type PotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Potions.
     */
    data: XOR<PotionUpdateManyMutationInput, PotionUncheckedUpdateManyInput>
    /**
     * Filter which Potions to update
     */
    where?: PotionWhereInput
  }


  /**
   * Potion upsert
   */
  export type PotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Potion to update in case it exists.
     */
    where: PotionWhereUniqueInput
    /**
     * In case the Potion found by the `where` argument doesn't exist, create a new Potion with this data.
     */
    create: XOR<PotionCreateInput, PotionUncheckedCreateInput>
    /**
     * In case the Potion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PotionUpdateInput, PotionUncheckedUpdateInput>
  }


  /**
   * Potion delete
   */
  export type PotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    /**
     * Filter which Potion to delete.
     */
    where: PotionWhereUniqueInput
  }


  /**
   * Potion deleteMany
   */
  export type PotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Potions to delete
     */
    where?: PotionWhereInput
  }


  /**
   * Potion.StatModifer
   */
  export type Potion$StatModiferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    where?: StatModiferWhereInput
  }


  /**
   * Potion without action
   */
  export type PotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
  }



  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    levelRequirement: number | null
  }

  export type SkillSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    levelRequirement: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    trainable: boolean | null
    levelRequirement: number | null
  }

  export type SkillMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    trainable: boolean | null
    levelRequirement: number | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    modifiedDate: number
    modifiedBy: number
    name: number
    description: number
    notes: number
    trainable: number
    levelRequirement: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    levelRequirement?: true
  }

  export type SkillSumAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    levelRequirement?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    trainable?: true
    levelRequirement?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    trainable?: true
    levelRequirement?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    trainable?: true
    levelRequirement?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    modifiedDate: Date
    modifiedBy: number
    name: string
    description: string | null
    notes: string | null
    trainable: boolean | null
    levelRequirement: number
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    trainable?: boolean
    levelRequirement?: boolean
    CreatedSkills?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedSkills?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Skill$StatModiferArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    trainable?: boolean
    levelRequirement?: boolean
  }

  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedSkills?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedSkills?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Skill$StatModiferArgs<ExtArgs>
  }


  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      CreatedSkills: Prisma.$AccountPayload<ExtArgs>
      ModifiedSkills: Prisma.$AccountPayload<ExtArgs>
      StatModifer: Prisma.$StatModiferPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      modifiedDate: Date
      modifiedBy: number
      name: string
      description: string | null
      notes: string | null
      trainable: boolean | null
      levelRequirement: number
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }


  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Skill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
    **/
    create<T extends SkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCreateArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Skills.
     *     @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     *     @example
     *     // Create many Skills
     *     const skill = await prisma.skill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
    **/
    delete<T extends SkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
    **/
    upsert<T extends SkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CreatedSkills<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ModifiedSkills<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    StatModifer<T extends Skill$StatModiferArgs<ExtArgs> = {}>(args?: Subset<T, Skill$StatModiferArgs<ExtArgs>>): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'Int'>
    readonly createdDate: FieldRef<"Skill", 'DateTime'>
    readonly createdBy: FieldRef<"Skill", 'Int'>
    readonly modifiedDate: FieldRef<"Skill", 'DateTime'>
    readonly modifiedBy: FieldRef<"Skill", 'Int'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly notes: FieldRef<"Skill", 'String'>
    readonly trainable: FieldRef<"Skill", 'Boolean'>
    readonly levelRequirement: FieldRef<"Skill", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }


  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
  }


  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }


  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
  }


  /**
   * Skill.StatModifer
   */
  export type Skill$StatModiferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    where?: StatModiferWhereInput
  }


  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
  }



  /**
   * Model Ability
   */

  export type AggregateAbility = {
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  export type AbilityAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    firstRankPoints: number | null
    secondRankPoints: number | null
    thirdRankPoints: number | null
    fourthRankPoints: number | null
    fifthRankPoints: number | null
    sixthRankPoints: number | null
  }

  export type AbilitySumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    firstRankPoints: number | null
    secondRankPoints: number | null
    thirdRankPoints: number | null
    fourthRankPoints: number | null
    fifthRankPoints: number | null
    sixthRankPoints: number | null
  }

  export type AbilityMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    firstRankPoints: number | null
    secondRankPoints: number | null
    thirdRankPoints: number | null
    fourthRankPoints: number | null
    fifthRankPoints: number | null
    sixthRankPoints: number | null
  }

  export type AbilityMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    firstRankPoints: number | null
    secondRankPoints: number | null
    thirdRankPoints: number | null
    fourthRankPoints: number | null
    fifthRankPoints: number | null
    sixthRankPoints: number | null
  }

  export type AbilityCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    modifiedDate: number
    modifiedBy: number
    name: number
    description: number
    notes: number
    firstRankPoints: number
    secondRankPoints: number
    thirdRankPoints: number
    fourthRankPoints: number
    fifthRankPoints: number
    sixthRankPoints: number
    _all: number
  }


  export type AbilityAvgAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    firstRankPoints?: true
    secondRankPoints?: true
    thirdRankPoints?: true
    fourthRankPoints?: true
    fifthRankPoints?: true
    sixthRankPoints?: true
  }

  export type AbilitySumAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    firstRankPoints?: true
    secondRankPoints?: true
    thirdRankPoints?: true
    fourthRankPoints?: true
    fifthRankPoints?: true
    sixthRankPoints?: true
  }

  export type AbilityMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    firstRankPoints?: true
    secondRankPoints?: true
    thirdRankPoints?: true
    fourthRankPoints?: true
    fifthRankPoints?: true
    sixthRankPoints?: true
  }

  export type AbilityMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    firstRankPoints?: true
    secondRankPoints?: true
    thirdRankPoints?: true
    fourthRankPoints?: true
    fifthRankPoints?: true
    sixthRankPoints?: true
  }

  export type AbilityCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    firstRankPoints?: true
    secondRankPoints?: true
    thirdRankPoints?: true
    fourthRankPoints?: true
    fifthRankPoints?: true
    sixthRankPoints?: true
    _all?: true
  }

  export type AbilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ability to aggregate.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Abilities
    **/
    _count?: true | AbilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbilityMaxAggregateInputType
  }

  export type GetAbilityAggregateType<T extends AbilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAbility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbility[P]>
      : GetScalarType<T[P], AggregateAbility[P]>
  }




  export type AbilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbilityWhereInput
    orderBy?: AbilityOrderByWithAggregationInput | AbilityOrderByWithAggregationInput[]
    by: AbilityScalarFieldEnum[] | AbilityScalarFieldEnum
    having?: AbilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbilityCountAggregateInputType | true
    _avg?: AbilityAvgAggregateInputType
    _sum?: AbilitySumAggregateInputType
    _min?: AbilityMinAggregateInputType
    _max?: AbilityMaxAggregateInputType
  }

  export type AbilityGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    modifiedDate: Date
    modifiedBy: number
    name: string
    description: string | null
    notes: string | null
    firstRankPoints: number | null
    secondRankPoints: number | null
    thirdRankPoints: number | null
    fourthRankPoints: number | null
    fifthRankPoints: number | null
    sixthRankPoints: number | null
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  type GetAbilityGroupByPayload<T extends AbilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbilityGroupByOutputType[P]>
            : GetScalarType<T[P], AbilityGroupByOutputType[P]>
        }
      >
    >


  export type AbilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    firstRankPoints?: boolean
    secondRankPoints?: boolean
    thirdRankPoints?: boolean
    fourthRankPoints?: boolean
    fifthRankPoints?: boolean
    sixthRankPoints?: boolean
    CreatedAbilities?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedAbilities?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Ability$StatModiferArgs<ExtArgs>
  }, ExtArgs["result"]["ability"]>

  export type AbilitySelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    firstRankPoints?: boolean
    secondRankPoints?: boolean
    thirdRankPoints?: boolean
    fourthRankPoints?: boolean
    fifthRankPoints?: boolean
    sixthRankPoints?: boolean
  }

  export type AbilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedAbilities?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedAbilities?: boolean | AccountDefaultArgs<ExtArgs>
    StatModifer?: boolean | Ability$StatModiferArgs<ExtArgs>
  }


  export type $AbilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ability"
    objects: {
      CreatedAbilities: Prisma.$AccountPayload<ExtArgs>
      ModifiedAbilities: Prisma.$AccountPayload<ExtArgs>
      StatModifer: Prisma.$StatModiferPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      modifiedDate: Date
      modifiedBy: number
      name: string
      description: string | null
      notes: string | null
      firstRankPoints: number | null
      secondRankPoints: number | null
      thirdRankPoints: number | null
      fourthRankPoints: number | null
      fifthRankPoints: number | null
      sixthRankPoints: number | null
    }, ExtArgs["result"]["ability"]>
    composites: {}
  }


  type AbilityGetPayload<S extends boolean | null | undefined | AbilityDefaultArgs> = $Result.GetResult<Prisma.$AbilityPayload, S>

  type AbilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AbilityFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AbilityCountAggregateInputType | true
    }

  export interface AbilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ability'], meta: { name: 'Ability' } }
    /**
     * Find zero or one Ability that matches the filter.
     * @param {AbilityFindUniqueArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AbilityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AbilityFindUniqueArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ability that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AbilityFindUniqueOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AbilityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AbilityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindFirstArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AbilityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AbilityFindFirstArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindFirstOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AbilityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AbilityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Abilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abilities
     * const abilities = await prisma.ability.findMany()
     * 
     * // Get first 10 Abilities
     * const abilities = await prisma.ability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abilityWithIdOnly = await prisma.ability.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AbilityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AbilityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ability.
     * @param {AbilityCreateArgs} args - Arguments to create a Ability.
     * @example
     * // Create one Ability
     * const Ability = await prisma.ability.create({
     *   data: {
     *     // ... data to create a Ability
     *   }
     * })
     * 
    **/
    create<T extends AbilityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AbilityCreateArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Abilities.
     *     @param {AbilityCreateManyArgs} args - Arguments to create many Abilities.
     *     @example
     *     // Create many Abilities
     *     const ability = await prisma.ability.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AbilityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AbilityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ability.
     * @param {AbilityDeleteArgs} args - Arguments to delete one Ability.
     * @example
     * // Delete one Ability
     * const Ability = await prisma.ability.delete({
     *   where: {
     *     // ... filter to delete one Ability
     *   }
     * })
     * 
    **/
    delete<T extends AbilityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AbilityDeleteArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ability.
     * @param {AbilityUpdateArgs} args - Arguments to update one Ability.
     * @example
     * // Update one Ability
     * const ability = await prisma.ability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AbilityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AbilityUpdateArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Abilities.
     * @param {AbilityDeleteManyArgs} args - Arguments to filter Abilities to delete.
     * @example
     * // Delete a few Abilities
     * const { count } = await prisma.ability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AbilityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AbilityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abilities
     * const ability = await prisma.ability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AbilityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AbilityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ability.
     * @param {AbilityUpsertArgs} args - Arguments to update or create a Ability.
     * @example
     * // Update or create a Ability
     * const ability = await prisma.ability.upsert({
     *   create: {
     *     // ... data to create a Ability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ability we want to update
     *   }
     * })
    **/
    upsert<T extends AbilityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AbilityUpsertArgs<ExtArgs>>
    ): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityCountArgs} args - Arguments to filter Abilities to count.
     * @example
     * // Count the number of Abilities
     * const count = await prisma.ability.count({
     *   where: {
     *     // ... the filter for the Abilities we want to count
     *   }
     * })
    **/
    count<T extends AbilityCountArgs>(
      args?: Subset<T, AbilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbilityAggregateArgs>(args: Subset<T, AbilityAggregateArgs>): Prisma.PrismaPromise<GetAbilityAggregateType<T>>

    /**
     * Group by Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbilityGroupByArgs['orderBy'] }
        : { orderBy?: AbilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ability model
   */
  readonly fields: AbilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CreatedAbilities<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ModifiedAbilities<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    StatModifer<T extends Ability$StatModiferArgs<ExtArgs> = {}>(args?: Subset<T, Ability$StatModiferArgs<ExtArgs>>): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ability model
   */ 
  interface AbilityFieldRefs {
    readonly id: FieldRef<"Ability", 'Int'>
    readonly createdDate: FieldRef<"Ability", 'DateTime'>
    readonly createdBy: FieldRef<"Ability", 'Int'>
    readonly modifiedDate: FieldRef<"Ability", 'DateTime'>
    readonly modifiedBy: FieldRef<"Ability", 'Int'>
    readonly name: FieldRef<"Ability", 'String'>
    readonly description: FieldRef<"Ability", 'String'>
    readonly notes: FieldRef<"Ability", 'String'>
    readonly firstRankPoints: FieldRef<"Ability", 'Int'>
    readonly secondRankPoints: FieldRef<"Ability", 'Int'>
    readonly thirdRankPoints: FieldRef<"Ability", 'Int'>
    readonly fourthRankPoints: FieldRef<"Ability", 'Int'>
    readonly fifthRankPoints: FieldRef<"Ability", 'Int'>
    readonly sixthRankPoints: FieldRef<"Ability", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Ability findUnique
   */
  export type AbilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where: AbilityWhereUniqueInput
  }


  /**
   * Ability findUniqueOrThrow
   */
  export type AbilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where: AbilityWhereUniqueInput
  }


  /**
   * Ability findFirst
   */
  export type AbilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }


  /**
   * Ability findFirstOrThrow
   */
  export type AbilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }


  /**
   * Ability findMany
   */
  export type AbilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Abilities to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }


  /**
   * Ability create
   */
  export type AbilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Ability.
     */
    data: XOR<AbilityCreateInput, AbilityUncheckedCreateInput>
  }


  /**
   * Ability createMany
   */
  export type AbilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Abilities.
     */
    data: AbilityCreateManyInput | AbilityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ability update
   */
  export type AbilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Ability.
     */
    data: XOR<AbilityUpdateInput, AbilityUncheckedUpdateInput>
    /**
     * Choose, which Ability to update.
     */
    where: AbilityWhereUniqueInput
  }


  /**
   * Ability updateMany
   */
  export type AbilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Abilities.
     */
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyInput>
    /**
     * Filter which Abilities to update
     */
    where?: AbilityWhereInput
  }


  /**
   * Ability upsert
   */
  export type AbilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Ability to update in case it exists.
     */
    where: AbilityWhereUniqueInput
    /**
     * In case the Ability found by the `where` argument doesn't exist, create a new Ability with this data.
     */
    create: XOR<AbilityCreateInput, AbilityUncheckedCreateInput>
    /**
     * In case the Ability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbilityUpdateInput, AbilityUncheckedUpdateInput>
  }


  /**
   * Ability delete
   */
  export type AbilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter which Ability to delete.
     */
    where: AbilityWhereUniqueInput
  }


  /**
   * Ability deleteMany
   */
  export type AbilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abilities to delete
     */
    where?: AbilityWhereInput
  }


  /**
   * Ability.StatModifer
   */
  export type Ability$StatModiferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    where?: StatModiferWhereInput
  }


  /**
   * Ability without action
   */
  export type AbilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
  }



  /**
   * Model Quest
   */

  export type AggregateQuest = {
    _count: QuestCountAggregateOutputType | null
    _avg: QuestAvgAggregateOutputType | null
    _sum: QuestSumAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  export type QuestAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    experience: number | null
  }

  export type QuestSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    modifiedBy: number | null
    experience: number | null
  }

  export type QuestMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    whoises: string | null
    pretitles: string | null
    post_titles: string | null
    experience: number | null
  }

  export type QuestMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    modifiedDate: Date | null
    modifiedBy: number | null
    name: string | null
    description: string | null
    notes: string | null
    whoises: string | null
    pretitles: string | null
    post_titles: string | null
    experience: number | null
  }

  export type QuestCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    modifiedDate: number
    modifiedBy: number
    name: number
    description: number
    notes: number
    whoises: number
    pretitles: number
    post_titles: number
    experience: number
    _all: number
  }


  export type QuestAvgAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    experience?: true
  }

  export type QuestSumAggregateInputType = {
    id?: true
    createdBy?: true
    modifiedBy?: true
    experience?: true
  }

  export type QuestMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    whoises?: true
    pretitles?: true
    post_titles?: true
    experience?: true
  }

  export type QuestMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    whoises?: true
    pretitles?: true
    post_titles?: true
    experience?: true
  }

  export type QuestCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    modifiedDate?: true
    modifiedBy?: true
    name?: true
    description?: true
    notes?: true
    whoises?: true
    pretitles?: true
    post_titles?: true
    experience?: true
    _all?: true
  }

  export type QuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quest to aggregate.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quests
    **/
    _count?: true | QuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestMaxAggregateInputType
  }

  export type GetQuestAggregateType<T extends QuestAggregateArgs> = {
        [P in keyof T & keyof AggregateQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuest[P]>
      : GetScalarType<T[P], AggregateQuest[P]>
  }




  export type QuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithAggregationInput | QuestOrderByWithAggregationInput[]
    by: QuestScalarFieldEnum[] | QuestScalarFieldEnum
    having?: QuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestCountAggregateInputType | true
    _avg?: QuestAvgAggregateInputType
    _sum?: QuestSumAggregateInputType
    _min?: QuestMinAggregateInputType
    _max?: QuestMaxAggregateInputType
  }

  export type QuestGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    modifiedDate: Date
    modifiedBy: number
    name: string
    description: string | null
    notes: string | null
    whoises: string | null
    pretitles: string | null
    post_titles: string | null
    experience: number | null
    _count: QuestCountAggregateOutputType | null
    _avg: QuestAvgAggregateOutputType | null
    _sum: QuestSumAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  type GetQuestGroupByPayload<T extends QuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestGroupByOutputType[P]>
            : GetScalarType<T[P], QuestGroupByOutputType[P]>
        }
      >
    >


  export type QuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    whoises?: boolean
    pretitles?: boolean
    post_titles?: boolean
    experience?: boolean
    CreatedQuests?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedQuests?: boolean | AccountDefaultArgs<ExtArgs>
    CharacterQuest?: boolean | Quest$CharacterQuestArgs<ExtArgs>
    StatModifer?: boolean | Quest$StatModiferArgs<ExtArgs>
    QuestTagSource?: boolean | Quest$QuestTagSourceArgs<ExtArgs>
    _count?: boolean | QuestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    modifiedDate?: boolean
    modifiedBy?: boolean
    name?: boolean
    description?: boolean
    notes?: boolean
    whoises?: boolean
    pretitles?: boolean
    post_titles?: boolean
    experience?: boolean
  }

  export type QuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedQuests?: boolean | AccountDefaultArgs<ExtArgs>
    ModifiedQuests?: boolean | AccountDefaultArgs<ExtArgs>
    CharacterQuest?: boolean | Quest$CharacterQuestArgs<ExtArgs>
    StatModifer?: boolean | Quest$StatModiferArgs<ExtArgs>
    QuestTagSource?: boolean | Quest$QuestTagSourceArgs<ExtArgs>
    _count?: boolean | QuestCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $QuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quest"
    objects: {
      CreatedQuests: Prisma.$AccountPayload<ExtArgs>
      ModifiedQuests: Prisma.$AccountPayload<ExtArgs>
      CharacterQuest: Prisma.$CharacterQuestPayload<ExtArgs>[]
      StatModifer: Prisma.$StatModiferPayload<ExtArgs> | null
      QuestTagSource: Prisma.$AppliedTagPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      modifiedDate: Date
      modifiedBy: number
      name: string
      description: string | null
      notes: string | null
      whoises: string | null
      pretitles: string | null
      post_titles: string | null
      experience: number | null
    }, ExtArgs["result"]["quest"]>
    composites: {}
  }


  type QuestGetPayload<S extends boolean | null | undefined | QuestDefaultArgs> = $Result.GetResult<Prisma.$QuestPayload, S>

  type QuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: QuestCountAggregateInputType | true
    }

  export interface QuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quest'], meta: { name: 'Quest' } }
    /**
     * Find zero or one Quest that matches the filter.
     * @param {QuestFindUniqueArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuestFindUniqueArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Quest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestFindUniqueOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Quest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestFindFirstArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Quest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quest.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questWithIdOnly = await prisma.quest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Quest.
     * @param {QuestCreateArgs} args - Arguments to create a Quest.
     * @example
     * // Create one Quest
     * const Quest = await prisma.quest.create({
     *   data: {
     *     // ... data to create a Quest
     *   }
     * })
     * 
    **/
    create<T extends QuestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestCreateArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Quests.
     *     @param {QuestCreateManyArgs} args - Arguments to create many Quests.
     *     @example
     *     // Create many Quests
     *     const quest = await prisma.quest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quest.
     * @param {QuestDeleteArgs} args - Arguments to delete one Quest.
     * @example
     * // Delete one Quest
     * const Quest = await prisma.quest.delete({
     *   where: {
     *     // ... filter to delete one Quest
     *   }
     * })
     * 
    **/
    delete<T extends QuestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuestDeleteArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Quest.
     * @param {QuestUpdateArgs} args - Arguments to update one Quest.
     * @example
     * // Update one Quest
     * const quest = await prisma.quest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestUpdateArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Quests.
     * @param {QuestDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quest.
     * @param {QuestUpsertArgs} args - Arguments to update or create a Quest.
     * @example
     * // Update or create a Quest
     * const quest = await prisma.quest.upsert({
     *   create: {
     *     // ... data to create a Quest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quest we want to update
     *   }
     * })
    **/
    upsert<T extends QuestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuestUpsertArgs<ExtArgs>>
    ): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quest.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends QuestCountArgs>(
      args?: Subset<T, QuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestAggregateArgs>(args: Subset<T, QuestAggregateArgs>): Prisma.PrismaPromise<GetQuestAggregateType<T>>

    /**
     * Group by Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestGroupByArgs['orderBy'] }
        : { orderBy?: QuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quest model
   */
  readonly fields: QuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CreatedQuests<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ModifiedQuests<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    CharacterQuest<T extends Quest$CharacterQuestArgs<ExtArgs> = {}>(args?: Subset<T, Quest$CharacterQuestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterQuestPayload<ExtArgs>, T, 'findMany'> | Null>;

    StatModifer<T extends Quest$StatModiferArgs<ExtArgs> = {}>(args?: Subset<T, Quest$StatModiferArgs<ExtArgs>>): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    QuestTagSource<T extends Quest$QuestTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, Quest$QuestTagSourceArgs<ExtArgs>>): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Quest model
   */ 
  interface QuestFieldRefs {
    readonly id: FieldRef<"Quest", 'Int'>
    readonly createdDate: FieldRef<"Quest", 'DateTime'>
    readonly createdBy: FieldRef<"Quest", 'Int'>
    readonly modifiedDate: FieldRef<"Quest", 'DateTime'>
    readonly modifiedBy: FieldRef<"Quest", 'Int'>
    readonly name: FieldRef<"Quest", 'String'>
    readonly description: FieldRef<"Quest", 'String'>
    readonly notes: FieldRef<"Quest", 'String'>
    readonly whoises: FieldRef<"Quest", 'String'>
    readonly pretitles: FieldRef<"Quest", 'String'>
    readonly post_titles: FieldRef<"Quest", 'String'>
    readonly experience: FieldRef<"Quest", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Quest findUnique
   */
  export type QuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }


  /**
   * Quest findUniqueOrThrow
   */
  export type QuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }


  /**
   * Quest findFirst
   */
  export type QuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }


  /**
   * Quest findFirstOrThrow
   */
  export type QuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }


  /**
   * Quest findMany
   */
  export type QuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }


  /**
   * Quest create
   */
  export type QuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Quest.
     */
    data: XOR<QuestCreateInput, QuestUncheckedCreateInput>
  }


  /**
   * Quest createMany
   */
  export type QuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Quest update
   */
  export type QuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Quest.
     */
    data: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
    /**
     * Choose, which Quest to update.
     */
    where: QuestWhereUniqueInput
  }


  /**
   * Quest updateMany
   */
  export type QuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
  }


  /**
   * Quest upsert
   */
  export type QuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Quest to update in case it exists.
     */
    where: QuestWhereUniqueInput
    /**
     * In case the Quest found by the `where` argument doesn't exist, create a new Quest with this data.
     */
    create: XOR<QuestCreateInput, QuestUncheckedCreateInput>
    /**
     * In case the Quest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
  }


  /**
   * Quest delete
   */
  export type QuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter which Quest to delete.
     */
    where: QuestWhereUniqueInput
  }


  /**
   * Quest deleteMany
   */
  export type QuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to delete
     */
    where?: QuestWhereInput
  }


  /**
   * Quest.CharacterQuest
   */
  export type Quest$CharacterQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterQuest
     */
    select?: CharacterQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterQuestInclude<ExtArgs> | null
    where?: CharacterQuestWhereInput
    orderBy?: CharacterQuestOrderByWithRelationInput | CharacterQuestOrderByWithRelationInput[]
    cursor?: CharacterQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterQuestScalarFieldEnum | CharacterQuestScalarFieldEnum[]
  }


  /**
   * Quest.StatModifer
   */
  export type Quest$StatModiferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    where?: StatModiferWhereInput
  }


  /**
   * Quest.QuestTagSource
   */
  export type Quest$QuestTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    where?: AppliedTagWhereInput
  }


  /**
   * Quest without action
   */
  export type QuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
  }



  /**
   * Model StatModifer
   */

  export type AggregateStatModifer = {
    _count: StatModiferCountAggregateOutputType | null
    _avg: StatModiferAvgAggregateOutputType | null
    _sum: StatModiferSumAggregateOutputType | null
    _min: StatModiferMinAggregateOutputType | null
    _max: StatModiferMaxAggregateOutputType | null
  }

  export type StatModiferAvgAggregateOutputType = {
    id: number | null
    sourceId: number | null
    hp: number | null
    mv: number | null
    ma: number | null
    ac: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    hpRegen: number | null
    mvRegen: number | null
    maRegen: number | null
    damroll: number | null
    hitroll: number | null
    mitigation: number | null
    spellDam: number | null
    spellCrit: number | null
    spellRedux: number | null
    concentration: number | null
    shotAccuracy: number | null
    bonusAccuracy: number | null
    ammoCapacity: number | null
    parry: number | null
    strCap: number | null
    minCap: number | null
    dexCap: number | null
    conCap: number | null
    perCap: number | null
    spiCap: number | null
  }

  export type StatModiferSumAggregateOutputType = {
    id: number | null
    sourceId: number | null
    hp: number | null
    mv: number | null
    ma: number | null
    ac: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    hpRegen: number | null
    mvRegen: number | null
    maRegen: number | null
    damroll: number | null
    hitroll: number | null
    mitigation: number | null
    spellDam: number | null
    spellCrit: number | null
    spellRedux: number | null
    concentration: number | null
    shotAccuracy: number | null
    bonusAccuracy: number | null
    ammoCapacity: number | null
    parry: number | null
    strCap: number | null
    minCap: number | null
    dexCap: number | null
    conCap: number | null
    perCap: number | null
    spiCap: number | null
  }

  export type StatModiferMinAggregateOutputType = {
    id: number | null
    type: $Enums.StatModifierType | null
    sourceId: number | null
    hp: number | null
    mv: number | null
    ma: number | null
    ac: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    hpRegen: number | null
    mvRegen: number | null
    maRegen: number | null
    damroll: number | null
    hitroll: number | null
    mitigation: number | null
    spellDam: number | null
    spellCrit: number | null
    spellRedux: number | null
    concentration: number | null
    shotAccuracy: number | null
    bonusAccuracy: number | null
    ammoCapacity: number | null
    parry: number | null
    strCap: number | null
    minCap: number | null
    dexCap: number | null
    conCap: number | null
    perCap: number | null
    spiCap: number | null
  }

  export type StatModiferMaxAggregateOutputType = {
    id: number | null
    type: $Enums.StatModifierType | null
    sourceId: number | null
    hp: number | null
    mv: number | null
    ma: number | null
    ac: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    hpRegen: number | null
    mvRegen: number | null
    maRegen: number | null
    damroll: number | null
    hitroll: number | null
    mitigation: number | null
    spellDam: number | null
    spellCrit: number | null
    spellRedux: number | null
    concentration: number | null
    shotAccuracy: number | null
    bonusAccuracy: number | null
    ammoCapacity: number | null
    parry: number | null
    strCap: number | null
    minCap: number | null
    dexCap: number | null
    conCap: number | null
    perCap: number | null
    spiCap: number | null
  }

  export type StatModiferCountAggregateOutputType = {
    id: number
    type: number
    sourceId: number
    hp: number
    mv: number
    ma: number
    ac: number
    str: number
    min: number
    dex: number
    con: number
    per: number
    spi: number
    hpRegen: number
    mvRegen: number
    maRegen: number
    damroll: number
    hitroll: number
    mitigation: number
    spellDam: number
    spellCrit: number
    spellRedux: number
    concentration: number
    shotAccuracy: number
    bonusAccuracy: number
    ammoCapacity: number
    parry: number
    strCap: number
    minCap: number
    dexCap: number
    conCap: number
    perCap: number
    spiCap: number
    _all: number
  }


  export type StatModiferAvgAggregateInputType = {
    id?: true
    sourceId?: true
    hp?: true
    mv?: true
    ma?: true
    ac?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    hpRegen?: true
    mvRegen?: true
    maRegen?: true
    damroll?: true
    hitroll?: true
    mitigation?: true
    spellDam?: true
    spellCrit?: true
    spellRedux?: true
    concentration?: true
    shotAccuracy?: true
    bonusAccuracy?: true
    ammoCapacity?: true
    parry?: true
    strCap?: true
    minCap?: true
    dexCap?: true
    conCap?: true
    perCap?: true
    spiCap?: true
  }

  export type StatModiferSumAggregateInputType = {
    id?: true
    sourceId?: true
    hp?: true
    mv?: true
    ma?: true
    ac?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    hpRegen?: true
    mvRegen?: true
    maRegen?: true
    damroll?: true
    hitroll?: true
    mitigation?: true
    spellDam?: true
    spellCrit?: true
    spellRedux?: true
    concentration?: true
    shotAccuracy?: true
    bonusAccuracy?: true
    ammoCapacity?: true
    parry?: true
    strCap?: true
    minCap?: true
    dexCap?: true
    conCap?: true
    perCap?: true
    spiCap?: true
  }

  export type StatModiferMinAggregateInputType = {
    id?: true
    type?: true
    sourceId?: true
    hp?: true
    mv?: true
    ma?: true
    ac?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    hpRegen?: true
    mvRegen?: true
    maRegen?: true
    damroll?: true
    hitroll?: true
    mitigation?: true
    spellDam?: true
    spellCrit?: true
    spellRedux?: true
    concentration?: true
    shotAccuracy?: true
    bonusAccuracy?: true
    ammoCapacity?: true
    parry?: true
    strCap?: true
    minCap?: true
    dexCap?: true
    conCap?: true
    perCap?: true
    spiCap?: true
  }

  export type StatModiferMaxAggregateInputType = {
    id?: true
    type?: true
    sourceId?: true
    hp?: true
    mv?: true
    ma?: true
    ac?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    hpRegen?: true
    mvRegen?: true
    maRegen?: true
    damroll?: true
    hitroll?: true
    mitigation?: true
    spellDam?: true
    spellCrit?: true
    spellRedux?: true
    concentration?: true
    shotAccuracy?: true
    bonusAccuracy?: true
    ammoCapacity?: true
    parry?: true
    strCap?: true
    minCap?: true
    dexCap?: true
    conCap?: true
    perCap?: true
    spiCap?: true
  }

  export type StatModiferCountAggregateInputType = {
    id?: true
    type?: true
    sourceId?: true
    hp?: true
    mv?: true
    ma?: true
    ac?: true
    str?: true
    min?: true
    dex?: true
    con?: true
    per?: true
    spi?: true
    hpRegen?: true
    mvRegen?: true
    maRegen?: true
    damroll?: true
    hitroll?: true
    mitigation?: true
    spellDam?: true
    spellCrit?: true
    spellRedux?: true
    concentration?: true
    shotAccuracy?: true
    bonusAccuracy?: true
    ammoCapacity?: true
    parry?: true
    strCap?: true
    minCap?: true
    dexCap?: true
    conCap?: true
    perCap?: true
    spiCap?: true
    _all?: true
  }

  export type StatModiferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatModifer to aggregate.
     */
    where?: StatModiferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatModifers to fetch.
     */
    orderBy?: StatModiferOrderByWithRelationInput | StatModiferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatModiferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatModifers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatModifers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatModifers
    **/
    _count?: true | StatModiferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatModiferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatModiferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatModiferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatModiferMaxAggregateInputType
  }

  export type GetStatModiferAggregateType<T extends StatModiferAggregateArgs> = {
        [P in keyof T & keyof AggregateStatModifer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatModifer[P]>
      : GetScalarType<T[P], AggregateStatModifer[P]>
  }




  export type StatModiferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatModiferWhereInput
    orderBy?: StatModiferOrderByWithAggregationInput | StatModiferOrderByWithAggregationInput[]
    by: StatModiferScalarFieldEnum[] | StatModiferScalarFieldEnum
    having?: StatModiferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatModiferCountAggregateInputType | true
    _avg?: StatModiferAvgAggregateInputType
    _sum?: StatModiferSumAggregateInputType
    _min?: StatModiferMinAggregateInputType
    _max?: StatModiferMaxAggregateInputType
  }

  export type StatModiferGroupByOutputType = {
    id: number
    type: $Enums.StatModifierType
    sourceId: number
    hp: number | null
    mv: number | null
    ma: number | null
    ac: number | null
    str: number | null
    min: number | null
    dex: number | null
    con: number | null
    per: number | null
    spi: number | null
    hpRegen: number | null
    mvRegen: number | null
    maRegen: number | null
    damroll: number | null
    hitroll: number | null
    mitigation: number | null
    spellDam: number | null
    spellCrit: number | null
    spellRedux: number | null
    concentration: number | null
    shotAccuracy: number | null
    bonusAccuracy: number | null
    ammoCapacity: number | null
    parry: number | null
    strCap: number | null
    minCap: number | null
    dexCap: number | null
    conCap: number | null
    perCap: number | null
    spiCap: number | null
    _count: StatModiferCountAggregateOutputType | null
    _avg: StatModiferAvgAggregateOutputType | null
    _sum: StatModiferSumAggregateOutputType | null
    _min: StatModiferMinAggregateOutputType | null
    _max: StatModiferMaxAggregateOutputType | null
  }

  type GetStatModiferGroupByPayload<T extends StatModiferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatModiferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatModiferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatModiferGroupByOutputType[P]>
            : GetScalarType<T[P], StatModiferGroupByOutputType[P]>
        }
      >
    >


  export type StatModiferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    sourceId?: boolean
    hp?: boolean
    mv?: boolean
    ma?: boolean
    ac?: boolean
    str?: boolean
    min?: boolean
    dex?: boolean
    con?: boolean
    per?: boolean
    spi?: boolean
    hpRegen?: boolean
    mvRegen?: boolean
    maRegen?: boolean
    damroll?: boolean
    hitroll?: boolean
    mitigation?: boolean
    spellDam?: boolean
    spellCrit?: boolean
    spellRedux?: boolean
    concentration?: boolean
    shotAccuracy?: boolean
    bonusAccuracy?: boolean
    ammoCapacity?: boolean
    parry?: boolean
    strCap?: boolean
    minCap?: boolean
    dexCap?: boolean
    conCap?: boolean
    perCap?: boolean
    spiCap?: boolean
    ItemSource?: boolean | StatModifer$ItemSourceArgs<ExtArgs>
    QuestSource?: boolean | StatModifer$QuestSourceArgs<ExtArgs>
    AbilitySource?: boolean | StatModifer$AbilitySourceArgs<ExtArgs>
    SkillSource?: boolean | StatModifer$SkillSourceArgs<ExtArgs>
    SpellSource?: boolean | StatModifer$SpellSourceArgs<ExtArgs>
    PotionSource?: boolean | StatModifer$PotionSourceArgs<ExtArgs>
  }, ExtArgs["result"]["statModifer"]>

  export type StatModiferSelectScalar = {
    id?: boolean
    type?: boolean
    sourceId?: boolean
    hp?: boolean
    mv?: boolean
    ma?: boolean
    ac?: boolean
    str?: boolean
    min?: boolean
    dex?: boolean
    con?: boolean
    per?: boolean
    spi?: boolean
    hpRegen?: boolean
    mvRegen?: boolean
    maRegen?: boolean
    damroll?: boolean
    hitroll?: boolean
    mitigation?: boolean
    spellDam?: boolean
    spellCrit?: boolean
    spellRedux?: boolean
    concentration?: boolean
    shotAccuracy?: boolean
    bonusAccuracy?: boolean
    ammoCapacity?: boolean
    parry?: boolean
    strCap?: boolean
    minCap?: boolean
    dexCap?: boolean
    conCap?: boolean
    perCap?: boolean
    spiCap?: boolean
  }

  export type StatModiferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ItemSource?: boolean | StatModifer$ItemSourceArgs<ExtArgs>
    QuestSource?: boolean | StatModifer$QuestSourceArgs<ExtArgs>
    AbilitySource?: boolean | StatModifer$AbilitySourceArgs<ExtArgs>
    SkillSource?: boolean | StatModifer$SkillSourceArgs<ExtArgs>
    SpellSource?: boolean | StatModifer$SpellSourceArgs<ExtArgs>
    PotionSource?: boolean | StatModifer$PotionSourceArgs<ExtArgs>
  }


  export type $StatModiferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatModifer"
    objects: {
      ItemSource: Prisma.$ItemPayload<ExtArgs> | null
      QuestSource: Prisma.$QuestPayload<ExtArgs> | null
      AbilitySource: Prisma.$AbilityPayload<ExtArgs> | null
      SkillSource: Prisma.$SkillPayload<ExtArgs> | null
      SpellSource: Prisma.$SpellPayload<ExtArgs> | null
      PotionSource: Prisma.$PotionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.StatModifierType
      sourceId: number
      hp: number | null
      mv: number | null
      ma: number | null
      ac: number | null
      str: number | null
      min: number | null
      dex: number | null
      con: number | null
      per: number | null
      spi: number | null
      hpRegen: number | null
      mvRegen: number | null
      maRegen: number | null
      damroll: number | null
      hitroll: number | null
      mitigation: number | null
      spellDam: number | null
      spellCrit: number | null
      spellRedux: number | null
      concentration: number | null
      shotAccuracy: number | null
      bonusAccuracy: number | null
      ammoCapacity: number | null
      parry: number | null
      strCap: number | null
      minCap: number | null
      dexCap: number | null
      conCap: number | null
      perCap: number | null
      spiCap: number | null
    }, ExtArgs["result"]["statModifer"]>
    composites: {}
  }


  type StatModiferGetPayload<S extends boolean | null | undefined | StatModiferDefaultArgs> = $Result.GetResult<Prisma.$StatModiferPayload, S>

  type StatModiferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatModiferFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StatModiferCountAggregateInputType | true
    }

  export interface StatModiferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatModifer'], meta: { name: 'StatModifer' } }
    /**
     * Find zero or one StatModifer that matches the filter.
     * @param {StatModiferFindUniqueArgs} args - Arguments to find a StatModifer
     * @example
     * // Get one StatModifer
     * const statModifer = await prisma.statModifer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatModiferFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StatModiferFindUniqueArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StatModifer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StatModiferFindUniqueOrThrowArgs} args - Arguments to find a StatModifer
     * @example
     * // Get one StatModifer
     * const statModifer = await prisma.statModifer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StatModiferFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatModiferFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StatModifer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatModiferFindFirstArgs} args - Arguments to find a StatModifer
     * @example
     * // Get one StatModifer
     * const statModifer = await prisma.statModifer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatModiferFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StatModiferFindFirstArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StatModifer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatModiferFindFirstOrThrowArgs} args - Arguments to find a StatModifer
     * @example
     * // Get one StatModifer
     * const statModifer = await prisma.statModifer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StatModiferFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatModiferFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StatModifers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatModiferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatModifers
     * const statModifers = await prisma.statModifer.findMany()
     * 
     * // Get first 10 StatModifers
     * const statModifers = await prisma.statModifer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statModiferWithIdOnly = await prisma.statModifer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatModiferFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatModiferFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StatModifer.
     * @param {StatModiferCreateArgs} args - Arguments to create a StatModifer.
     * @example
     * // Create one StatModifer
     * const StatModifer = await prisma.statModifer.create({
     *   data: {
     *     // ... data to create a StatModifer
     *   }
     * })
     * 
    **/
    create<T extends StatModiferCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StatModiferCreateArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StatModifers.
     *     @param {StatModiferCreateManyArgs} args - Arguments to create many StatModifers.
     *     @example
     *     // Create many StatModifers
     *     const statModifer = await prisma.statModifer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatModiferCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatModiferCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StatModifer.
     * @param {StatModiferDeleteArgs} args - Arguments to delete one StatModifer.
     * @example
     * // Delete one StatModifer
     * const StatModifer = await prisma.statModifer.delete({
     *   where: {
     *     // ... filter to delete one StatModifer
     *   }
     * })
     * 
    **/
    delete<T extends StatModiferDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StatModiferDeleteArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StatModifer.
     * @param {StatModiferUpdateArgs} args - Arguments to update one StatModifer.
     * @example
     * // Update one StatModifer
     * const statModifer = await prisma.statModifer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatModiferUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StatModiferUpdateArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StatModifers.
     * @param {StatModiferDeleteManyArgs} args - Arguments to filter StatModifers to delete.
     * @example
     * // Delete a few StatModifers
     * const { count } = await prisma.statModifer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatModiferDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatModiferDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatModifers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatModiferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatModifers
     * const statModifer = await prisma.statModifer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatModiferUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StatModiferUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatModifer.
     * @param {StatModiferUpsertArgs} args - Arguments to update or create a StatModifer.
     * @example
     * // Update or create a StatModifer
     * const statModifer = await prisma.statModifer.upsert({
     *   create: {
     *     // ... data to create a StatModifer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatModifer we want to update
     *   }
     * })
    **/
    upsert<T extends StatModiferUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StatModiferUpsertArgs<ExtArgs>>
    ): Prisma__StatModiferClient<$Result.GetResult<Prisma.$StatModiferPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StatModifers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatModiferCountArgs} args - Arguments to filter StatModifers to count.
     * @example
     * // Count the number of StatModifers
     * const count = await prisma.statModifer.count({
     *   where: {
     *     // ... the filter for the StatModifers we want to count
     *   }
     * })
    **/
    count<T extends StatModiferCountArgs>(
      args?: Subset<T, StatModiferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatModiferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatModifer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatModiferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatModiferAggregateArgs>(args: Subset<T, StatModiferAggregateArgs>): Prisma.PrismaPromise<GetStatModiferAggregateType<T>>

    /**
     * Group by StatModifer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatModiferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatModiferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatModiferGroupByArgs['orderBy'] }
        : { orderBy?: StatModiferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatModiferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatModiferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatModifer model
   */
  readonly fields: StatModiferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatModifer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatModiferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ItemSource<T extends StatModifer$ItemSourceArgs<ExtArgs> = {}>(args?: Subset<T, StatModifer$ItemSourceArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    QuestSource<T extends StatModifer$QuestSourceArgs<ExtArgs> = {}>(args?: Subset<T, StatModifer$QuestSourceArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    AbilitySource<T extends StatModifer$AbilitySourceArgs<ExtArgs> = {}>(args?: Subset<T, StatModifer$AbilitySourceArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    SkillSource<T extends StatModifer$SkillSourceArgs<ExtArgs> = {}>(args?: Subset<T, StatModifer$SkillSourceArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    SpellSource<T extends StatModifer$SpellSourceArgs<ExtArgs> = {}>(args?: Subset<T, StatModifer$SpellSourceArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    PotionSource<T extends StatModifer$PotionSourceArgs<ExtArgs> = {}>(args?: Subset<T, StatModifer$PotionSourceArgs<ExtArgs>>): Prisma__PotionClient<$Result.GetResult<Prisma.$PotionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StatModifer model
   */ 
  interface StatModiferFieldRefs {
    readonly id: FieldRef<"StatModifer", 'Int'>
    readonly type: FieldRef<"StatModifer", 'StatModifierType'>
    readonly sourceId: FieldRef<"StatModifer", 'Int'>
    readonly hp: FieldRef<"StatModifer", 'Int'>
    readonly mv: FieldRef<"StatModifer", 'Int'>
    readonly ma: FieldRef<"StatModifer", 'Int'>
    readonly ac: FieldRef<"StatModifer", 'Int'>
    readonly str: FieldRef<"StatModifer", 'Int'>
    readonly min: FieldRef<"StatModifer", 'Int'>
    readonly dex: FieldRef<"StatModifer", 'Int'>
    readonly con: FieldRef<"StatModifer", 'Int'>
    readonly per: FieldRef<"StatModifer", 'Int'>
    readonly spi: FieldRef<"StatModifer", 'Int'>
    readonly hpRegen: FieldRef<"StatModifer", 'Int'>
    readonly mvRegen: FieldRef<"StatModifer", 'Int'>
    readonly maRegen: FieldRef<"StatModifer", 'Int'>
    readonly damroll: FieldRef<"StatModifer", 'Int'>
    readonly hitroll: FieldRef<"StatModifer", 'Int'>
    readonly mitigation: FieldRef<"StatModifer", 'Int'>
    readonly spellDam: FieldRef<"StatModifer", 'Int'>
    readonly spellCrit: FieldRef<"StatModifer", 'Int'>
    readonly spellRedux: FieldRef<"StatModifer", 'Int'>
    readonly concentration: FieldRef<"StatModifer", 'Int'>
    readonly shotAccuracy: FieldRef<"StatModifer", 'Int'>
    readonly bonusAccuracy: FieldRef<"StatModifer", 'Int'>
    readonly ammoCapacity: FieldRef<"StatModifer", 'Int'>
    readonly parry: FieldRef<"StatModifer", 'Int'>
    readonly strCap: FieldRef<"StatModifer", 'Int'>
    readonly minCap: FieldRef<"StatModifer", 'Int'>
    readonly dexCap: FieldRef<"StatModifer", 'Int'>
    readonly conCap: FieldRef<"StatModifer", 'Int'>
    readonly perCap: FieldRef<"StatModifer", 'Int'>
    readonly spiCap: FieldRef<"StatModifer", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * StatModifer findUnique
   */
  export type StatModiferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * Filter, which StatModifer to fetch.
     */
    where: StatModiferWhereUniqueInput
  }


  /**
   * StatModifer findUniqueOrThrow
   */
  export type StatModiferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * Filter, which StatModifer to fetch.
     */
    where: StatModiferWhereUniqueInput
  }


  /**
   * StatModifer findFirst
   */
  export type StatModiferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * Filter, which StatModifer to fetch.
     */
    where?: StatModiferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatModifers to fetch.
     */
    orderBy?: StatModiferOrderByWithRelationInput | StatModiferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatModifers.
     */
    cursor?: StatModiferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatModifers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatModifers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatModifers.
     */
    distinct?: StatModiferScalarFieldEnum | StatModiferScalarFieldEnum[]
  }


  /**
   * StatModifer findFirstOrThrow
   */
  export type StatModiferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * Filter, which StatModifer to fetch.
     */
    where?: StatModiferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatModifers to fetch.
     */
    orderBy?: StatModiferOrderByWithRelationInput | StatModiferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatModifers.
     */
    cursor?: StatModiferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatModifers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatModifers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatModifers.
     */
    distinct?: StatModiferScalarFieldEnum | StatModiferScalarFieldEnum[]
  }


  /**
   * StatModifer findMany
   */
  export type StatModiferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * Filter, which StatModifers to fetch.
     */
    where?: StatModiferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatModifers to fetch.
     */
    orderBy?: StatModiferOrderByWithRelationInput | StatModiferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatModifers.
     */
    cursor?: StatModiferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatModifers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatModifers.
     */
    skip?: number
    distinct?: StatModiferScalarFieldEnum | StatModiferScalarFieldEnum[]
  }


  /**
   * StatModifer create
   */
  export type StatModiferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * The data needed to create a StatModifer.
     */
    data: XOR<StatModiferCreateInput, StatModiferUncheckedCreateInput>
  }


  /**
   * StatModifer createMany
   */
  export type StatModiferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatModifers.
     */
    data: StatModiferCreateManyInput | StatModiferCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StatModifer update
   */
  export type StatModiferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * The data needed to update a StatModifer.
     */
    data: XOR<StatModiferUpdateInput, StatModiferUncheckedUpdateInput>
    /**
     * Choose, which StatModifer to update.
     */
    where: StatModiferWhereUniqueInput
  }


  /**
   * StatModifer updateMany
   */
  export type StatModiferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatModifers.
     */
    data: XOR<StatModiferUpdateManyMutationInput, StatModiferUncheckedUpdateManyInput>
    /**
     * Filter which StatModifers to update
     */
    where?: StatModiferWhereInput
  }


  /**
   * StatModifer upsert
   */
  export type StatModiferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * The filter to search for the StatModifer to update in case it exists.
     */
    where: StatModiferWhereUniqueInput
    /**
     * In case the StatModifer found by the `where` argument doesn't exist, create a new StatModifer with this data.
     */
    create: XOR<StatModiferCreateInput, StatModiferUncheckedCreateInput>
    /**
     * In case the StatModifer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatModiferUpdateInput, StatModiferUncheckedUpdateInput>
  }


  /**
   * StatModifer delete
   */
  export type StatModiferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
    /**
     * Filter which StatModifer to delete.
     */
    where: StatModiferWhereUniqueInput
  }


  /**
   * StatModifer deleteMany
   */
  export type StatModiferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatModifers to delete
     */
    where?: StatModiferWhereInput
  }


  /**
   * StatModifer.ItemSource
   */
  export type StatModifer$ItemSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }


  /**
   * StatModifer.QuestSource
   */
  export type StatModifer$QuestSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
  }


  /**
   * StatModifer.AbilitySource
   */
  export type StatModifer$AbilitySourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AbilityInclude<ExtArgs> | null
    where?: AbilityWhereInput
  }


  /**
   * StatModifer.SkillSource
   */
  export type StatModifer$SkillSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
  }


  /**
   * StatModifer.SpellSource
   */
  export type StatModifer$SpellSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
  }


  /**
   * StatModifer.PotionSource
   */
  export type StatModifer$PotionSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potion
     */
    select?: PotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotionInclude<ExtArgs> | null
    where?: PotionWhereInput
  }


  /**
   * StatModifer without action
   */
  export type StatModiferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatModifer
     */
    select?: StatModiferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatModiferInclude<ExtArgs> | null
  }



  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type ArticleSumAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    authorId: number | null
    isProtected: boolean | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    authorId: number | null
    isProtected: boolean | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    createdDate: number
    authorId: number
    isProtected: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type ArticleSumAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    createdDate?: true
    authorId?: true
    isProtected?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    createdDate?: true
    authorId?: true
    isProtected?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    createdDate?: true
    authorId?: true
    isProtected?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: number
    createdDate: Date
    authorId: number
    isProtected: boolean
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    authorId?: boolean
    isProtected?: boolean
    Author?: boolean | AccountDefaultArgs<ExtArgs>
    ArticleContent?: boolean | Article$ArticleContentArgs<ExtArgs>
    ArticleTagSource?: boolean | Article$ArticleTagSourceArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    createdDate?: boolean
    authorId?: boolean
    isProtected?: boolean
  }

  export type ArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Author?: boolean | AccountDefaultArgs<ExtArgs>
    ArticleContent?: boolean | Article$ArticleContentArgs<ExtArgs>
    ArticleTagSource?: boolean | Article$ArticleTagSourceArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {
      Author: Prisma.$AccountPayload<ExtArgs>
      ArticleContent: Prisma.$ArticleVersionPayload<ExtArgs>[]
      ArticleTagSource: Prisma.$AppliedTagPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      authorId: number
      isProtected: boolean
    }, ExtArgs["result"]["article"]>
    composites: {}
  }


  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Article that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
    **/
    create<T extends ArticleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Articles.
     *     @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     *     @example
     *     // Create many Articles
     *     const article = await prisma.article.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
    **/
    delete<T extends ArticleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Author<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ArticleContent<T extends Article$ArticleContentArgs<ExtArgs> = {}>(args?: Subset<T, Article$ArticleContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'findMany'> | Null>;

    ArticleTagSource<T extends Article$ArticleTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, Article$ArticleTagSourceArgs<ExtArgs>>): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Article model
   */ 
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'Int'>
    readonly createdDate: FieldRef<"Article", 'DateTime'>
    readonly authorId: FieldRef<"Article", 'Int'>
    readonly isProtected: FieldRef<"Article", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }


  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }


  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }


  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }


  /**
   * Article.ArticleContent
   */
  export type Article$ArticleContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    where?: ArticleVersionWhereInput
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    cursor?: ArticleVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }


  /**
   * Article.ArticleTagSource
   */
  export type Article$ArticleTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    where?: AppliedTagWhereInput
  }


  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
  }



  /**
   * Model ArticleVersion
   */

  export type AggregateArticleVersion = {
    _count: ArticleVersionCountAggregateOutputType | null
    _avg: ArticleVersionAvgAggregateOutputType | null
    _sum: ArticleVersionSumAggregateOutputType | null
    _min: ArticleVersionMinAggregateOutputType | null
    _max: ArticleVersionMaxAggregateOutputType | null
  }

  export type ArticleVersionAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
    editorId: number | null
  }

  export type ArticleVersionSumAggregateOutputType = {
    id: number | null
    articleId: number | null
    editorId: number | null
  }

  export type ArticleVersionMinAggregateOutputType = {
    id: number | null
    articleId: number | null
    modifiedDate: Date | null
    editorId: number | null
    content: string | null
    isCurrent: boolean | null
    version: string | null
  }

  export type ArticleVersionMaxAggregateOutputType = {
    id: number | null
    articleId: number | null
    modifiedDate: Date | null
    editorId: number | null
    content: string | null
    isCurrent: boolean | null
    version: string | null
  }

  export type ArticleVersionCountAggregateOutputType = {
    id: number
    articleId: number
    modifiedDate: number
    editorId: number
    content: number
    isCurrent: number
    version: number
    _all: number
  }


  export type ArticleVersionAvgAggregateInputType = {
    id?: true
    articleId?: true
    editorId?: true
  }

  export type ArticleVersionSumAggregateInputType = {
    id?: true
    articleId?: true
    editorId?: true
  }

  export type ArticleVersionMinAggregateInputType = {
    id?: true
    articleId?: true
    modifiedDate?: true
    editorId?: true
    content?: true
    isCurrent?: true
    version?: true
  }

  export type ArticleVersionMaxAggregateInputType = {
    id?: true
    articleId?: true
    modifiedDate?: true
    editorId?: true
    content?: true
    isCurrent?: true
    version?: true
  }

  export type ArticleVersionCountAggregateInputType = {
    id?: true
    articleId?: true
    modifiedDate?: true
    editorId?: true
    content?: true
    isCurrent?: true
    version?: true
    _all?: true
  }

  export type ArticleVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleVersion to aggregate.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleVersions
    **/
    _count?: true | ArticleVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleVersionMaxAggregateInputType
  }

  export type GetArticleVersionAggregateType<T extends ArticleVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleVersion[P]>
      : GetScalarType<T[P], AggregateArticleVersion[P]>
  }




  export type ArticleVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleVersionWhereInput
    orderBy?: ArticleVersionOrderByWithAggregationInput | ArticleVersionOrderByWithAggregationInput[]
    by: ArticleVersionScalarFieldEnum[] | ArticleVersionScalarFieldEnum
    having?: ArticleVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleVersionCountAggregateInputType | true
    _avg?: ArticleVersionAvgAggregateInputType
    _sum?: ArticleVersionSumAggregateInputType
    _min?: ArticleVersionMinAggregateInputType
    _max?: ArticleVersionMaxAggregateInputType
  }

  export type ArticleVersionGroupByOutputType = {
    id: number
    articleId: number
    modifiedDate: Date
    editorId: number
    content: string
    isCurrent: boolean
    version: string | null
    _count: ArticleVersionCountAggregateOutputType | null
    _avg: ArticleVersionAvgAggregateOutputType | null
    _sum: ArticleVersionSumAggregateOutputType | null
    _min: ArticleVersionMinAggregateOutputType | null
    _max: ArticleVersionMaxAggregateOutputType | null
  }

  type GetArticleVersionGroupByPayload<T extends ArticleVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleVersionGroupByOutputType[P]>
        }
      >
    >


  export type ArticleVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    modifiedDate?: boolean
    editorId?: boolean
    content?: boolean
    isCurrent?: boolean
    version?: boolean
    Editor?: boolean | AccountDefaultArgs<ExtArgs>
    Article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleVersion"]>

  export type ArticleVersionSelectScalar = {
    id?: boolean
    articleId?: boolean
    modifiedDate?: boolean
    editorId?: boolean
    content?: boolean
    isCurrent?: boolean
    version?: boolean
  }

  export type ArticleVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Editor?: boolean | AccountDefaultArgs<ExtArgs>
    Article?: boolean | ArticleDefaultArgs<ExtArgs>
  }


  export type $ArticleVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleVersion"
    objects: {
      Editor: Prisma.$AccountPayload<ExtArgs>
      Article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      articleId: number
      modifiedDate: Date
      editorId: number
      content: string
      isCurrent: boolean
      version: string | null
    }, ExtArgs["result"]["articleVersion"]>
    composites: {}
  }


  type ArticleVersionGetPayload<S extends boolean | null | undefined | ArticleVersionDefaultArgs> = $Result.GetResult<Prisma.$ArticleVersionPayload, S>

  type ArticleVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleVersionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ArticleVersionCountAggregateInputType | true
    }

  export interface ArticleVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleVersion'], meta: { name: 'ArticleVersion' } }
    /**
     * Find zero or one ArticleVersion that matches the filter.
     * @param {ArticleVersionFindUniqueArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleVersionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleVersionFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ArticleVersion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleVersionFindUniqueOrThrowArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleVersionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleVersionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ArticleVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionFindFirstArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleVersionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleVersionFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ArticleVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionFindFirstOrThrowArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleVersionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleVersionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ArticleVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleVersions
     * const articleVersions = await prisma.articleVersion.findMany()
     * 
     * // Get first 10 ArticleVersions
     * const articleVersions = await prisma.articleVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleVersionWithIdOnly = await prisma.articleVersion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleVersionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleVersionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ArticleVersion.
     * @param {ArticleVersionCreateArgs} args - Arguments to create a ArticleVersion.
     * @example
     * // Create one ArticleVersion
     * const ArticleVersion = await prisma.articleVersion.create({
     *   data: {
     *     // ... data to create a ArticleVersion
     *   }
     * })
     * 
    **/
    create<T extends ArticleVersionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleVersionCreateArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ArticleVersions.
     *     @param {ArticleVersionCreateManyArgs} args - Arguments to create many ArticleVersions.
     *     @example
     *     // Create many ArticleVersions
     *     const articleVersion = await prisma.articleVersion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleVersionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleVersionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticleVersion.
     * @param {ArticleVersionDeleteArgs} args - Arguments to delete one ArticleVersion.
     * @example
     * // Delete one ArticleVersion
     * const ArticleVersion = await prisma.articleVersion.delete({
     *   where: {
     *     // ... filter to delete one ArticleVersion
     *   }
     * })
     * 
    **/
    delete<T extends ArticleVersionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleVersionDeleteArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ArticleVersion.
     * @param {ArticleVersionUpdateArgs} args - Arguments to update one ArticleVersion.
     * @example
     * // Update one ArticleVersion
     * const articleVersion = await prisma.articleVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleVersionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleVersionUpdateArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ArticleVersions.
     * @param {ArticleVersionDeleteManyArgs} args - Arguments to filter ArticleVersions to delete.
     * @example
     * // Delete a few ArticleVersions
     * const { count } = await prisma.articleVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleVersionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleVersionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleVersions
     * const articleVersion = await prisma.articleVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleVersionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleVersionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleVersion.
     * @param {ArticleVersionUpsertArgs} args - Arguments to update or create a ArticleVersion.
     * @example
     * // Update or create a ArticleVersion
     * const articleVersion = await prisma.articleVersion.upsert({
     *   create: {
     *     // ... data to create a ArticleVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleVersion we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleVersionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleVersionUpsertArgs<ExtArgs>>
    ): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ArticleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionCountArgs} args - Arguments to filter ArticleVersions to count.
     * @example
     * // Count the number of ArticleVersions
     * const count = await prisma.articleVersion.count({
     *   where: {
     *     // ... the filter for the ArticleVersions we want to count
     *   }
     * })
    **/
    count<T extends ArticleVersionCountArgs>(
      args?: Subset<T, ArticleVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleVersionAggregateArgs>(args: Subset<T, ArticleVersionAggregateArgs>): Prisma.PrismaPromise<GetArticleVersionAggregateType<T>>

    /**
     * Group by ArticleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleVersionGroupByArgs['orderBy'] }
        : { orderBy?: ArticleVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleVersion model
   */
  readonly fields: ArticleVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Editor<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ArticleVersion model
   */ 
  interface ArticleVersionFieldRefs {
    readonly id: FieldRef<"ArticleVersion", 'Int'>
    readonly articleId: FieldRef<"ArticleVersion", 'Int'>
    readonly modifiedDate: FieldRef<"ArticleVersion", 'DateTime'>
    readonly editorId: FieldRef<"ArticleVersion", 'Int'>
    readonly content: FieldRef<"ArticleVersion", 'String'>
    readonly isCurrent: FieldRef<"ArticleVersion", 'Boolean'>
    readonly version: FieldRef<"ArticleVersion", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ArticleVersion findUnique
   */
  export type ArticleVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where: ArticleVersionWhereUniqueInput
  }


  /**
   * ArticleVersion findUniqueOrThrow
   */
  export type ArticleVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where: ArticleVersionWhereUniqueInput
  }


  /**
   * ArticleVersion findFirst
   */
  export type ArticleVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleVersions.
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleVersions.
     */
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }


  /**
   * ArticleVersion findFirstOrThrow
   */
  export type ArticleVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleVersions.
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleVersions.
     */
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }


  /**
   * ArticleVersion findMany
   */
  export type ArticleVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersions to fetch.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleVersions.
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }


  /**
   * ArticleVersion create
   */
  export type ArticleVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleVersion.
     */
    data: XOR<ArticleVersionCreateInput, ArticleVersionUncheckedCreateInput>
  }


  /**
   * ArticleVersion createMany
   */
  export type ArticleVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleVersions.
     */
    data: ArticleVersionCreateManyInput | ArticleVersionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ArticleVersion update
   */
  export type ArticleVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleVersion.
     */
    data: XOR<ArticleVersionUpdateInput, ArticleVersionUncheckedUpdateInput>
    /**
     * Choose, which ArticleVersion to update.
     */
    where: ArticleVersionWhereUniqueInput
  }


  /**
   * ArticleVersion updateMany
   */
  export type ArticleVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleVersions.
     */
    data: XOR<ArticleVersionUpdateManyMutationInput, ArticleVersionUncheckedUpdateManyInput>
    /**
     * Filter which ArticleVersions to update
     */
    where?: ArticleVersionWhereInput
  }


  /**
   * ArticleVersion upsert
   */
  export type ArticleVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleVersion to update in case it exists.
     */
    where: ArticleVersionWhereUniqueInput
    /**
     * In case the ArticleVersion found by the `where` argument doesn't exist, create a new ArticleVersion with this data.
     */
    create: XOR<ArticleVersionCreateInput, ArticleVersionUncheckedCreateInput>
    /**
     * In case the ArticleVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleVersionUpdateInput, ArticleVersionUncheckedUpdateInput>
  }


  /**
   * ArticleVersion delete
   */
  export type ArticleVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter which ArticleVersion to delete.
     */
    where: ArticleVersionWhereUniqueInput
  }


  /**
   * ArticleVersion deleteMany
   */
  export type ArticleVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleVersions to delete
     */
    where?: ArticleVersionWhereInput
  }


  /**
   * ArticleVersion without action
   */
  export type ArticleVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleVersionInclude<ExtArgs> | null
  }



  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    tag: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    tag: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    tag: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    tag?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    tag?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    tag?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    tag: string
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    tag?: boolean
    Creator?: boolean | AccountDefaultArgs<ExtArgs>
    AppliedTag?: boolean | Tag$AppliedTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    tag?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Creator?: boolean | AccountDefaultArgs<ExtArgs>
    AppliedTag?: boolean | Tag$AppliedTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      Creator: Prisma.$AccountPayload<ExtArgs>
      AppliedTag: Prisma.$AppliedTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      tag: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }


  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Creator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    AppliedTag<T extends Tag$AppliedTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$AppliedTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly createdDate: FieldRef<"Tag", 'DateTime'>
    readonly createdBy: FieldRef<"Tag", 'Int'>
    readonly tag: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag.AppliedTag
   */
  export type Tag$AppliedTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    where?: AppliedTagWhereInput
    orderBy?: AppliedTagOrderByWithRelationInput | AppliedTagOrderByWithRelationInput[]
    cursor?: AppliedTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppliedTagScalarFieldEnum | AppliedTagScalarFieldEnum[]
  }


  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
  }



  /**
   * Model AppliedTag
   */

  export type AggregateAppliedTag = {
    _count: AppliedTagCountAggregateOutputType | null
    _avg: AppliedTagAvgAggregateOutputType | null
    _sum: AppliedTagSumAggregateOutputType | null
    _min: AppliedTagMinAggregateOutputType | null
    _max: AppliedTagMaxAggregateOutputType | null
  }

  export type AppliedTagAvgAggregateOutputType = {
    id: number | null
    sourceId: number | null
    tagId: number | null
  }

  export type AppliedTagSumAggregateOutputType = {
    id: number | null
    sourceId: number | null
    tagId: number | null
  }

  export type AppliedTagMinAggregateOutputType = {
    id: number | null
    typeId: $Enums.TagType | null
    sourceId: number | null
    tagId: number | null
  }

  export type AppliedTagMaxAggregateOutputType = {
    id: number | null
    typeId: $Enums.TagType | null
    sourceId: number | null
    tagId: number | null
  }

  export type AppliedTagCountAggregateOutputType = {
    id: number
    typeId: number
    sourceId: number
    tagId: number
    _all: number
  }


  export type AppliedTagAvgAggregateInputType = {
    id?: true
    sourceId?: true
    tagId?: true
  }

  export type AppliedTagSumAggregateInputType = {
    id?: true
    sourceId?: true
    tagId?: true
  }

  export type AppliedTagMinAggregateInputType = {
    id?: true
    typeId?: true
    sourceId?: true
    tagId?: true
  }

  export type AppliedTagMaxAggregateInputType = {
    id?: true
    typeId?: true
    sourceId?: true
    tagId?: true
  }

  export type AppliedTagCountAggregateInputType = {
    id?: true
    typeId?: true
    sourceId?: true
    tagId?: true
    _all?: true
  }

  export type AppliedTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppliedTag to aggregate.
     */
    where?: AppliedTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppliedTags to fetch.
     */
    orderBy?: AppliedTagOrderByWithRelationInput | AppliedTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppliedTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppliedTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppliedTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppliedTags
    **/
    _count?: true | AppliedTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppliedTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppliedTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppliedTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppliedTagMaxAggregateInputType
  }

  export type GetAppliedTagAggregateType<T extends AppliedTagAggregateArgs> = {
        [P in keyof T & keyof AggregateAppliedTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppliedTag[P]>
      : GetScalarType<T[P], AggregateAppliedTag[P]>
  }




  export type AppliedTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppliedTagWhereInput
    orderBy?: AppliedTagOrderByWithAggregationInput | AppliedTagOrderByWithAggregationInput[]
    by: AppliedTagScalarFieldEnum[] | AppliedTagScalarFieldEnum
    having?: AppliedTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppliedTagCountAggregateInputType | true
    _avg?: AppliedTagAvgAggregateInputType
    _sum?: AppliedTagSumAggregateInputType
    _min?: AppliedTagMinAggregateInputType
    _max?: AppliedTagMaxAggregateInputType
  }

  export type AppliedTagGroupByOutputType = {
    id: number
    typeId: $Enums.TagType
    sourceId: number | null
    tagId: number
    _count: AppliedTagCountAggregateOutputType | null
    _avg: AppliedTagAvgAggregateOutputType | null
    _sum: AppliedTagSumAggregateOutputType | null
    _min: AppliedTagMinAggregateOutputType | null
    _max: AppliedTagMaxAggregateOutputType | null
  }

  type GetAppliedTagGroupByPayload<T extends AppliedTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppliedTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppliedTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppliedTagGroupByOutputType[P]>
            : GetScalarType<T[P], AppliedTagGroupByOutputType[P]>
        }
      >
    >


  export type AppliedTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeId?: boolean
    sourceId?: boolean
    tagId?: boolean
    Tag?: boolean | TagDefaultArgs<ExtArgs>
    ArticleTagSource?: boolean | AppliedTag$ArticleTagSourceArgs<ExtArgs>
    ItemTagSource?: boolean | AppliedTag$ItemTagSourceArgs<ExtArgs>
    MobTagSource?: boolean | AppliedTag$MobTagSourceArgs<ExtArgs>
    QuestTagSource?: boolean | AppliedTag$QuestTagSourceArgs<ExtArgs>
  }, ExtArgs["result"]["appliedTag"]>

  export type AppliedTagSelectScalar = {
    id?: boolean
    typeId?: boolean
    sourceId?: boolean
    tagId?: boolean
  }

  export type AppliedTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tag?: boolean | TagDefaultArgs<ExtArgs>
    ArticleTagSource?: boolean | AppliedTag$ArticleTagSourceArgs<ExtArgs>
    ItemTagSource?: boolean | AppliedTag$ItemTagSourceArgs<ExtArgs>
    MobTagSource?: boolean | AppliedTag$MobTagSourceArgs<ExtArgs>
    QuestTagSource?: boolean | AppliedTag$QuestTagSourceArgs<ExtArgs>
  }


  export type $AppliedTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppliedTag"
    objects: {
      Tag: Prisma.$TagPayload<ExtArgs>
      ArticleTagSource: Prisma.$ArticlePayload<ExtArgs> | null
      ItemTagSource: Prisma.$ItemPayload<ExtArgs> | null
      MobTagSource: Prisma.$MobPayload<ExtArgs> | null
      QuestTagSource: Prisma.$QuestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeId: $Enums.TagType
      sourceId: number | null
      tagId: number
    }, ExtArgs["result"]["appliedTag"]>
    composites: {}
  }


  type AppliedTagGetPayload<S extends boolean | null | undefined | AppliedTagDefaultArgs> = $Result.GetResult<Prisma.$AppliedTagPayload, S>

  type AppliedTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppliedTagFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AppliedTagCountAggregateInputType | true
    }

  export interface AppliedTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppliedTag'], meta: { name: 'AppliedTag' } }
    /**
     * Find zero or one AppliedTag that matches the filter.
     * @param {AppliedTagFindUniqueArgs} args - Arguments to find a AppliedTag
     * @example
     * // Get one AppliedTag
     * const appliedTag = await prisma.appliedTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppliedTagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AppliedTagFindUniqueArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AppliedTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AppliedTagFindUniqueOrThrowArgs} args - Arguments to find a AppliedTag
     * @example
     * // Get one AppliedTag
     * const appliedTag = await prisma.appliedTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppliedTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppliedTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AppliedTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppliedTagFindFirstArgs} args - Arguments to find a AppliedTag
     * @example
     * // Get one AppliedTag
     * const appliedTag = await prisma.appliedTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppliedTagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AppliedTagFindFirstArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AppliedTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppliedTagFindFirstOrThrowArgs} args - Arguments to find a AppliedTag
     * @example
     * // Get one AppliedTag
     * const appliedTag = await prisma.appliedTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppliedTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppliedTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AppliedTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppliedTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppliedTags
     * const appliedTags = await prisma.appliedTag.findMany()
     * 
     * // Get first 10 AppliedTags
     * const appliedTags = await prisma.appliedTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appliedTagWithIdOnly = await prisma.appliedTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppliedTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppliedTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AppliedTag.
     * @param {AppliedTagCreateArgs} args - Arguments to create a AppliedTag.
     * @example
     * // Create one AppliedTag
     * const AppliedTag = await prisma.appliedTag.create({
     *   data: {
     *     // ... data to create a AppliedTag
     *   }
     * })
     * 
    **/
    create<T extends AppliedTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AppliedTagCreateArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AppliedTags.
     *     @param {AppliedTagCreateManyArgs} args - Arguments to create many AppliedTags.
     *     @example
     *     // Create many AppliedTags
     *     const appliedTag = await prisma.appliedTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppliedTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppliedTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppliedTag.
     * @param {AppliedTagDeleteArgs} args - Arguments to delete one AppliedTag.
     * @example
     * // Delete one AppliedTag
     * const AppliedTag = await prisma.appliedTag.delete({
     *   where: {
     *     // ... filter to delete one AppliedTag
     *   }
     * })
     * 
    **/
    delete<T extends AppliedTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AppliedTagDeleteArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AppliedTag.
     * @param {AppliedTagUpdateArgs} args - Arguments to update one AppliedTag.
     * @example
     * // Update one AppliedTag
     * const appliedTag = await prisma.appliedTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppliedTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AppliedTagUpdateArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AppliedTags.
     * @param {AppliedTagDeleteManyArgs} args - Arguments to filter AppliedTags to delete.
     * @example
     * // Delete a few AppliedTags
     * const { count } = await prisma.appliedTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppliedTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppliedTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppliedTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppliedTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppliedTags
     * const appliedTag = await prisma.appliedTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppliedTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AppliedTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppliedTag.
     * @param {AppliedTagUpsertArgs} args - Arguments to update or create a AppliedTag.
     * @example
     * // Update or create a AppliedTag
     * const appliedTag = await prisma.appliedTag.upsert({
     *   create: {
     *     // ... data to create a AppliedTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppliedTag we want to update
     *   }
     * })
    **/
    upsert<T extends AppliedTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AppliedTagUpsertArgs<ExtArgs>>
    ): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AppliedTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppliedTagCountArgs} args - Arguments to filter AppliedTags to count.
     * @example
     * // Count the number of AppliedTags
     * const count = await prisma.appliedTag.count({
     *   where: {
     *     // ... the filter for the AppliedTags we want to count
     *   }
     * })
    **/
    count<T extends AppliedTagCountArgs>(
      args?: Subset<T, AppliedTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppliedTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppliedTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppliedTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppliedTagAggregateArgs>(args: Subset<T, AppliedTagAggregateArgs>): Prisma.PrismaPromise<GetAppliedTagAggregateType<T>>

    /**
     * Group by AppliedTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppliedTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppliedTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppliedTagGroupByArgs['orderBy'] }
        : { orderBy?: AppliedTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppliedTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppliedTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppliedTag model
   */
  readonly fields: AppliedTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppliedTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppliedTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ArticleTagSource<T extends AppliedTag$ArticleTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, AppliedTag$ArticleTagSourceArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ItemTagSource<T extends AppliedTag$ItemTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, AppliedTag$ItemTagSourceArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    MobTagSource<T extends AppliedTag$MobTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, AppliedTag$MobTagSourceArgs<ExtArgs>>): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    QuestTagSource<T extends AppliedTag$QuestTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, AppliedTag$QuestTagSourceArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AppliedTag model
   */ 
  interface AppliedTagFieldRefs {
    readonly id: FieldRef<"AppliedTag", 'Int'>
    readonly typeId: FieldRef<"AppliedTag", 'TagType'>
    readonly sourceId: FieldRef<"AppliedTag", 'Int'>
    readonly tagId: FieldRef<"AppliedTag", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * AppliedTag findUnique
   */
  export type AppliedTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * Filter, which AppliedTag to fetch.
     */
    where: AppliedTagWhereUniqueInput
  }


  /**
   * AppliedTag findUniqueOrThrow
   */
  export type AppliedTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * Filter, which AppliedTag to fetch.
     */
    where: AppliedTagWhereUniqueInput
  }


  /**
   * AppliedTag findFirst
   */
  export type AppliedTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * Filter, which AppliedTag to fetch.
     */
    where?: AppliedTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppliedTags to fetch.
     */
    orderBy?: AppliedTagOrderByWithRelationInput | AppliedTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppliedTags.
     */
    cursor?: AppliedTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppliedTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppliedTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppliedTags.
     */
    distinct?: AppliedTagScalarFieldEnum | AppliedTagScalarFieldEnum[]
  }


  /**
   * AppliedTag findFirstOrThrow
   */
  export type AppliedTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * Filter, which AppliedTag to fetch.
     */
    where?: AppliedTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppliedTags to fetch.
     */
    orderBy?: AppliedTagOrderByWithRelationInput | AppliedTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppliedTags.
     */
    cursor?: AppliedTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppliedTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppliedTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppliedTags.
     */
    distinct?: AppliedTagScalarFieldEnum | AppliedTagScalarFieldEnum[]
  }


  /**
   * AppliedTag findMany
   */
  export type AppliedTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * Filter, which AppliedTags to fetch.
     */
    where?: AppliedTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppliedTags to fetch.
     */
    orderBy?: AppliedTagOrderByWithRelationInput | AppliedTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppliedTags.
     */
    cursor?: AppliedTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppliedTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppliedTags.
     */
    skip?: number
    distinct?: AppliedTagScalarFieldEnum | AppliedTagScalarFieldEnum[]
  }


  /**
   * AppliedTag create
   */
  export type AppliedTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * The data needed to create a AppliedTag.
     */
    data: XOR<AppliedTagCreateInput, AppliedTagUncheckedCreateInput>
  }


  /**
   * AppliedTag createMany
   */
  export type AppliedTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppliedTags.
     */
    data: AppliedTagCreateManyInput | AppliedTagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AppliedTag update
   */
  export type AppliedTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * The data needed to update a AppliedTag.
     */
    data: XOR<AppliedTagUpdateInput, AppliedTagUncheckedUpdateInput>
    /**
     * Choose, which AppliedTag to update.
     */
    where: AppliedTagWhereUniqueInput
  }


  /**
   * AppliedTag updateMany
   */
  export type AppliedTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppliedTags.
     */
    data: XOR<AppliedTagUpdateManyMutationInput, AppliedTagUncheckedUpdateManyInput>
    /**
     * Filter which AppliedTags to update
     */
    where?: AppliedTagWhereInput
  }


  /**
   * AppliedTag upsert
   */
  export type AppliedTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * The filter to search for the AppliedTag to update in case it exists.
     */
    where: AppliedTagWhereUniqueInput
    /**
     * In case the AppliedTag found by the `where` argument doesn't exist, create a new AppliedTag with this data.
     */
    create: XOR<AppliedTagCreateInput, AppliedTagUncheckedCreateInput>
    /**
     * In case the AppliedTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppliedTagUpdateInput, AppliedTagUncheckedUpdateInput>
  }


  /**
   * AppliedTag delete
   */
  export type AppliedTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    /**
     * Filter which AppliedTag to delete.
     */
    where: AppliedTagWhereUniqueInput
  }


  /**
   * AppliedTag deleteMany
   */
  export type AppliedTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppliedTags to delete
     */
    where?: AppliedTagWhereInput
  }


  /**
   * AppliedTag.ArticleTagSource
   */
  export type AppliedTag$ArticleTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
  }


  /**
   * AppliedTag.ItemTagSource
   */
  export type AppliedTag$ItemTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }


  /**
   * AppliedTag.MobTagSource
   */
  export type AppliedTag$MobTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    where?: MobWhereInput
  }


  /**
   * AppliedTag.QuestTagSource
   */
  export type AppliedTag$QuestTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
  }


  /**
   * AppliedTag without action
   */
  export type AppliedTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
  }



  /**
   * Model Mob
   */

  export type AggregateMob = {
    _count: MobCountAggregateOutputType | null
    _avg: MobAvgAggregateOutputType | null
    _sum: MobSumAggregateOutputType | null
    _min: MobMinAggregateOutputType | null
    _max: MobMaxAggregateOutputType | null
  }

  export type MobAvgAggregateOutputType = {
    id: number | null
    mudId: number | null
    areaId: number | null
    level: number | null
    experience: number | null
    gold: number | null
  }

  export type MobSumAggregateOutputType = {
    id: number | null
    mudId: number | null
    areaId: number | null
    level: number | null
    experience: number | null
    gold: number | null
  }

  export type MobMinAggregateOutputType = {
    id: number | null
    mudId: number | null
    areaId: number | null
    shortDescription: string | null
    longDescription: string | null
    level: number | null
    isAggressive: boolean | null
    experience: number | null
    gold: number | null
  }

  export type MobMaxAggregateOutputType = {
    id: number | null
    mudId: number | null
    areaId: number | null
    shortDescription: string | null
    longDescription: string | null
    level: number | null
    isAggressive: boolean | null
    experience: number | null
    gold: number | null
  }

  export type MobCountAggregateOutputType = {
    id: number
    mudId: number
    areaId: number
    shortDescription: number
    longDescription: number
    level: number
    isAggressive: number
    experience: number
    gold: number
    _all: number
  }


  export type MobAvgAggregateInputType = {
    id?: true
    mudId?: true
    areaId?: true
    level?: true
    experience?: true
    gold?: true
  }

  export type MobSumAggregateInputType = {
    id?: true
    mudId?: true
    areaId?: true
    level?: true
    experience?: true
    gold?: true
  }

  export type MobMinAggregateInputType = {
    id?: true
    mudId?: true
    areaId?: true
    shortDescription?: true
    longDescription?: true
    level?: true
    isAggressive?: true
    experience?: true
    gold?: true
  }

  export type MobMaxAggregateInputType = {
    id?: true
    mudId?: true
    areaId?: true
    shortDescription?: true
    longDescription?: true
    level?: true
    isAggressive?: true
    experience?: true
    gold?: true
  }

  export type MobCountAggregateInputType = {
    id?: true
    mudId?: true
    areaId?: true
    shortDescription?: true
    longDescription?: true
    level?: true
    isAggressive?: true
    experience?: true
    gold?: true
    _all?: true
  }

  export type MobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mob to aggregate.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mobs
    **/
    _count?: true | MobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobMaxAggregateInputType
  }

  export type GetMobAggregateType<T extends MobAggregateArgs> = {
        [P in keyof T & keyof AggregateMob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMob[P]>
      : GetScalarType<T[P], AggregateMob[P]>
  }




  export type MobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobWhereInput
    orderBy?: MobOrderByWithAggregationInput | MobOrderByWithAggregationInput[]
    by: MobScalarFieldEnum[] | MobScalarFieldEnum
    having?: MobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobCountAggregateInputType | true
    _avg?: MobAvgAggregateInputType
    _sum?: MobSumAggregateInputType
    _min?: MobMinAggregateInputType
    _max?: MobMaxAggregateInputType
  }

  export type MobGroupByOutputType = {
    id: number
    mudId: number | null
    areaId: number | null
    shortDescription: string
    longDescription: string | null
    level: number | null
    isAggressive: boolean
    experience: number | null
    gold: number | null
    _count: MobCountAggregateOutputType | null
    _avg: MobAvgAggregateOutputType | null
    _sum: MobSumAggregateOutputType | null
    _min: MobMinAggregateOutputType | null
    _max: MobMaxAggregateOutputType | null
  }

  type GetMobGroupByPayload<T extends MobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobGroupByOutputType[P]>
            : GetScalarType<T[P], MobGroupByOutputType[P]>
        }
      >
    >


  export type MobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mudId?: boolean
    areaId?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    level?: boolean
    isAggressive?: boolean
    experience?: boolean
    gold?: boolean
    MobTagSource?: boolean | Mob$MobTagSourceArgs<ExtArgs>
    Area?: boolean | Mob$AreaArgs<ExtArgs>
  }, ExtArgs["result"]["mob"]>

  export type MobSelectScalar = {
    id?: boolean
    mudId?: boolean
    areaId?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    level?: boolean
    isAggressive?: boolean
    experience?: boolean
    gold?: boolean
  }

  export type MobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MobTagSource?: boolean | Mob$MobTagSourceArgs<ExtArgs>
    Area?: boolean | Mob$AreaArgs<ExtArgs>
  }


  export type $MobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mob"
    objects: {
      MobTagSource: Prisma.$AppliedTagPayload<ExtArgs> | null
      Area: Prisma.$AreaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mudId: number | null
      areaId: number | null
      shortDescription: string
      longDescription: string | null
      level: number | null
      isAggressive: boolean
      experience: number | null
      gold: number | null
    }, ExtArgs["result"]["mob"]>
    composites: {}
  }


  type MobGetPayload<S extends boolean | null | undefined | MobDefaultArgs> = $Result.GetResult<Prisma.$MobPayload, S>

  type MobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MobCountAggregateInputType | true
    }

  export interface MobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mob'], meta: { name: 'Mob' } }
    /**
     * Find zero or one Mob that matches the filter.
     * @param {MobFindUniqueArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobFindUniqueArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Mob that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobFindUniqueOrThrowArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Mob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobFindFirstArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindFirstArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Mob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobFindFirstOrThrowArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Mobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mobs
     * const mobs = await prisma.mob.findMany()
     * 
     * // Get first 10 Mobs
     * const mobs = await prisma.mob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobWithIdOnly = await prisma.mob.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Mob.
     * @param {MobCreateArgs} args - Arguments to create a Mob.
     * @example
     * // Create one Mob
     * const Mob = await prisma.mob.create({
     *   data: {
     *     // ... data to create a Mob
     *   }
     * })
     * 
    **/
    create<T extends MobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobCreateArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Mobs.
     *     @param {MobCreateManyArgs} args - Arguments to create many Mobs.
     *     @example
     *     // Create many Mobs
     *     const mob = await prisma.mob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mob.
     * @param {MobDeleteArgs} args - Arguments to delete one Mob.
     * @example
     * // Delete one Mob
     * const Mob = await prisma.mob.delete({
     *   where: {
     *     // ... filter to delete one Mob
     *   }
     * })
     * 
    **/
    delete<T extends MobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobDeleteArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Mob.
     * @param {MobUpdateArgs} args - Arguments to update one Mob.
     * @example
     * // Update one Mob
     * const mob = await prisma.mob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobUpdateArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Mobs.
     * @param {MobDeleteManyArgs} args - Arguments to filter Mobs to delete.
     * @example
     * // Delete a few Mobs
     * const { count } = await prisma.mob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mobs
     * const mob = await prisma.mob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mob.
     * @param {MobUpsertArgs} args - Arguments to update or create a Mob.
     * @example
     * // Update or create a Mob
     * const mob = await prisma.mob.upsert({
     *   create: {
     *     // ... data to create a Mob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mob we want to update
     *   }
     * })
    **/
    upsert<T extends MobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobUpsertArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCountArgs} args - Arguments to filter Mobs to count.
     * @example
     * // Count the number of Mobs
     * const count = await prisma.mob.count({
     *   where: {
     *     // ... the filter for the Mobs we want to count
     *   }
     * })
    **/
    count<T extends MobCountArgs>(
      args?: Subset<T, MobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobAggregateArgs>(args: Subset<T, MobAggregateArgs>): Prisma.PrismaPromise<GetMobAggregateType<T>>

    /**
     * Group by Mob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobGroupByArgs['orderBy'] }
        : { orderBy?: MobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mob model
   */
  readonly fields: MobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    MobTagSource<T extends Mob$MobTagSourceArgs<ExtArgs> = {}>(args?: Subset<T, Mob$MobTagSourceArgs<ExtArgs>>): Prisma__AppliedTagClient<$Result.GetResult<Prisma.$AppliedTagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Area<T extends Mob$AreaArgs<ExtArgs> = {}>(args?: Subset<T, Mob$AreaArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Mob model
   */ 
  interface MobFieldRefs {
    readonly id: FieldRef<"Mob", 'Int'>
    readonly mudId: FieldRef<"Mob", 'Int'>
    readonly areaId: FieldRef<"Mob", 'Int'>
    readonly shortDescription: FieldRef<"Mob", 'String'>
    readonly longDescription: FieldRef<"Mob", 'String'>
    readonly level: FieldRef<"Mob", 'Int'>
    readonly isAggressive: FieldRef<"Mob", 'Boolean'>
    readonly experience: FieldRef<"Mob", 'Int'>
    readonly gold: FieldRef<"Mob", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Mob findUnique
   */
  export type MobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob findUniqueOrThrow
   */
  export type MobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob findFirst
   */
  export type MobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mobs.
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mobs.
     */
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Mob findFirstOrThrow
   */
  export type MobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mobs.
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mobs.
     */
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Mob findMany
   */
  export type MobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mobs to fetch.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mobs.
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Mob create
   */
  export type MobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * The data needed to create a Mob.
     */
    data: XOR<MobCreateInput, MobUncheckedCreateInput>
  }


  /**
   * Mob createMany
   */
  export type MobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mobs.
     */
    data: MobCreateManyInput | MobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Mob update
   */
  export type MobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * The data needed to update a Mob.
     */
    data: XOR<MobUpdateInput, MobUncheckedUpdateInput>
    /**
     * Choose, which Mob to update.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob updateMany
   */
  export type MobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mobs.
     */
    data: XOR<MobUpdateManyMutationInput, MobUncheckedUpdateManyInput>
    /**
     * Filter which Mobs to update
     */
    where?: MobWhereInput
  }


  /**
   * Mob upsert
   */
  export type MobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * The filter to search for the Mob to update in case it exists.
     */
    where: MobWhereUniqueInput
    /**
     * In case the Mob found by the `where` argument doesn't exist, create a new Mob with this data.
     */
    create: XOR<MobCreateInput, MobUncheckedCreateInput>
    /**
     * In case the Mob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobUpdateInput, MobUncheckedUpdateInput>
  }


  /**
   * Mob delete
   */
  export type MobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter which Mob to delete.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob deleteMany
   */
  export type MobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mobs to delete
     */
    where?: MobWhereInput
  }


  /**
   * Mob.MobTagSource
   */
  export type Mob$MobTagSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppliedTag
     */
    select?: AppliedTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppliedTagInclude<ExtArgs> | null
    where?: AppliedTagWhereInput
  }


  /**
   * Mob.Area
   */
  export type Mob$AreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
  }


  /**
   * Mob without action
   */
  export type MobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
  }



  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    id: number | null
    mudId: number | null
    authorId: number | null
  }

  export type AreaSumAggregateOutputType = {
    id: number | null
    mudId: number | null
    authorId: number | null
  }

  export type AreaMinAggregateOutputType = {
    id: number | null
    mudId: number | null
    name: string | null
    authorId: number | null
    releaseDate: Date | null
  }

  export type AreaMaxAggregateOutputType = {
    id: number | null
    mudId: number | null
    name: string | null
    authorId: number | null
    releaseDate: Date | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    mudId: number
    name: number
    authorId: number
    releaseDate: number
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    id?: true
    mudId?: true
    authorId?: true
  }

  export type AreaSumAggregateInputType = {
    id?: true
    mudId?: true
    authorId?: true
  }

  export type AreaMinAggregateInputType = {
    id?: true
    mudId?: true
    name?: true
    authorId?: true
    releaseDate?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    mudId?: true
    name?: true
    authorId?: true
    releaseDate?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    mudId?: true
    name?: true
    authorId?: true
    releaseDate?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _avg?: AreaAvgAggregateInputType
    _sum?: AreaSumAggregateInputType
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: number
    mudId: number | null
    name: string
    authorId: number | null
    releaseDate: Date | null
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mudId?: boolean
    name?: boolean
    authorId?: boolean
    releaseDate?: boolean
    Author?: boolean | Area$AuthorArgs<ExtArgs>
    Mob?: boolean | Area$MobArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    mudId?: boolean
    name?: boolean
    authorId?: boolean
    releaseDate?: boolean
  }

  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Author?: boolean | Area$AuthorArgs<ExtArgs>
    Mob?: boolean | Area$MobArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      Author: Prisma.$AccountPayload<ExtArgs> | null
      Mob: Prisma.$MobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mudId: number | null
      name: string
      authorId: number | null
      releaseDate: Date | null
    }, ExtArgs["result"]["area"]>
    composites: {}
  }


  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AreaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Area that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AreaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AreaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
    **/
    create<T extends AreaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AreaCreateArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Areas.
     *     @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     *     @example
     *     // Create many Areas
     *     const area = await prisma.area.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AreaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
    **/
    delete<T extends AreaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AreaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AreaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AreaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
    **/
    upsert<T extends AreaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Author<T extends Area$AuthorArgs<ExtArgs> = {}>(args?: Subset<T, Area$AuthorArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Mob<T extends Area$MobArgs<ExtArgs> = {}>(args?: Subset<T, Area$MobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Area model
   */ 
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'Int'>
    readonly mudId: FieldRef<"Area", 'Int'>
    readonly name: FieldRef<"Area", 'String'>
    readonly authorId: FieldRef<"Area", 'Int'>
    readonly releaseDate: FieldRef<"Area", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }


  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }


  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }


  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }


  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }


  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }


  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }


  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
  }


  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }


  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }


  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
  }


  /**
   * Area.Author
   */
  export type Area$AuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }


  /**
   * Area.Mob
   */
  export type Area$MobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    where?: MobWhereInput
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    cursor?: MobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AreaInclude<ExtArgs> | null
  }



  /**
   * Model ChangeLog
   */

  export type AggregateChangeLog = {
    _count: ChangeLogCountAggregateOutputType | null
    _avg: ChangeLogAvgAggregateOutputType | null
    _sum: ChangeLogSumAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  export type ChangeLogAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type ChangeLogSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type ChangeLogMinAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    content: string | null
    version: string | null
    releaseDate: Date | null
  }

  export type ChangeLogMaxAggregateOutputType = {
    id: number | null
    createdDate: Date | null
    createdBy: number | null
    content: string | null
    version: string | null
    releaseDate: Date | null
  }

  export type ChangeLogCountAggregateOutputType = {
    id: number
    createdDate: number
    createdBy: number
    content: number
    version: number
    releaseDate: number
    _all: number
  }


  export type ChangeLogAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type ChangeLogSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type ChangeLogMinAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    content?: true
    version?: true
    releaseDate?: true
  }

  export type ChangeLogMaxAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    content?: true
    version?: true
    releaseDate?: true
  }

  export type ChangeLogCountAggregateInputType = {
    id?: true
    createdDate?: true
    createdBy?: true
    content?: true
    version?: true
    releaseDate?: true
    _all?: true
  }

  export type ChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLog to aggregate.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeLogs
    **/
    _count?: true | ChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeLogMaxAggregateInputType
  }

  export type GetChangeLogAggregateType<T extends ChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeLog[P]>
      : GetScalarType<T[P], AggregateChangeLog[P]>
  }




  export type ChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithAggregationInput | ChangeLogOrderByWithAggregationInput[]
    by: ChangeLogScalarFieldEnum[] | ChangeLogScalarFieldEnum
    having?: ChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeLogCountAggregateInputType | true
    _avg?: ChangeLogAvgAggregateInputType
    _sum?: ChangeLogSumAggregateInputType
    _min?: ChangeLogMinAggregateInputType
    _max?: ChangeLogMaxAggregateInputType
  }

  export type ChangeLogGroupByOutputType = {
    id: number
    createdDate: Date
    createdBy: number
    content: string | null
    version: string | null
    releaseDate: Date | null
    _count: ChangeLogCountAggregateOutputType | null
    _avg: ChangeLogAvgAggregateOutputType | null
    _sum: ChangeLogSumAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  type GetChangeLogGroupByPayload<T extends ChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type ChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    content?: boolean
    version?: boolean
    releaseDate?: boolean
    Creator?: boolean | ChangeLog$CreatorArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectScalar = {
    id?: boolean
    createdDate?: boolean
    createdBy?: boolean
    content?: boolean
    version?: boolean
    releaseDate?: boolean
  }

  export type ChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Creator?: boolean | ChangeLog$CreatorArgs<ExtArgs>
  }


  export type $ChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeLog"
    objects: {
      Creator: Prisma.$AccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdDate: Date
      createdBy: number
      content: string | null
      version: string | null
      releaseDate: Date | null
    }, ExtArgs["result"]["changeLog"]>
    composites: {}
  }


  type ChangeLogGetPayload<S extends boolean | null | undefined | ChangeLogDefaultArgs> = $Result.GetResult<Prisma.$ChangeLogPayload, S>

  type ChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChangeLogFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ChangeLogCountAggregateInputType | true
    }

  export interface ChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeLog'], meta: { name: 'ChangeLog' } }
    /**
     * Find zero or one ChangeLog that matches the filter.
     * @param {ChangeLogFindUniqueArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChangeLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogFindUniqueArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChangeLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChangeLogFindUniqueOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChangeLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChangeLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindFirstArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChangeLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany()
     * 
     * // Get first 10 ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChangeLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChangeLog.
     * @param {ChangeLogCreateArgs} args - Arguments to create a ChangeLog.
     * @example
     * // Create one ChangeLog
     * const ChangeLog = await prisma.changeLog.create({
     *   data: {
     *     // ... data to create a ChangeLog
     *   }
     * })
     * 
    **/
    create<T extends ChangeLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogCreateArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChangeLogs.
     *     @param {ChangeLogCreateManyArgs} args - Arguments to create many ChangeLogs.
     *     @example
     *     // Create many ChangeLogs
     *     const changeLog = await prisma.changeLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChangeLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChangeLog.
     * @param {ChangeLogDeleteArgs} args - Arguments to delete one ChangeLog.
     * @example
     * // Delete one ChangeLog
     * const ChangeLog = await prisma.changeLog.delete({
     *   where: {
     *     // ... filter to delete one ChangeLog
     *   }
     * })
     * 
    **/
    delete<T extends ChangeLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogDeleteArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChangeLog.
     * @param {ChangeLogUpdateArgs} args - Arguments to update one ChangeLog.
     * @example
     * // Update one ChangeLog
     * const changeLog = await prisma.changeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChangeLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogUpdateArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChangeLogs.
     * @param {ChangeLogDeleteManyArgs} args - Arguments to filter ChangeLogs to delete.
     * @example
     * // Delete a few ChangeLogs
     * const { count } = await prisma.changeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChangeLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeLogs
     * const changeLog = await prisma.changeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChangeLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChangeLog.
     * @param {ChangeLogUpsertArgs} args - Arguments to update or create a ChangeLog.
     * @example
     * // Update or create a ChangeLog
     * const changeLog = await prisma.changeLog.upsert({
     *   create: {
     *     // ... data to create a ChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeLog we want to update
     *   }
     * })
    **/
    upsert<T extends ChangeLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogUpsertArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogCountArgs} args - Arguments to filter ChangeLogs to count.
     * @example
     * // Count the number of ChangeLogs
     * const count = await prisma.changeLog.count({
     *   where: {
     *     // ... the filter for the ChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends ChangeLogCountArgs>(
      args?: Subset<T, ChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeLogAggregateArgs>(args: Subset<T, ChangeLogAggregateArgs>): Prisma.PrismaPromise<GetChangeLogAggregateType<T>>

    /**
     * Group by ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: ChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeLog model
   */
  readonly fields: ChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Creator<T extends ChangeLog$CreatorArgs<ExtArgs> = {}>(args?: Subset<T, ChangeLog$CreatorArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ChangeLog model
   */ 
  interface ChangeLogFieldRefs {
    readonly id: FieldRef<"ChangeLog", 'Int'>
    readonly createdDate: FieldRef<"ChangeLog", 'DateTime'>
    readonly createdBy: FieldRef<"ChangeLog", 'Int'>
    readonly content: FieldRef<"ChangeLog", 'String'>
    readonly version: FieldRef<"ChangeLog", 'String'>
    readonly releaseDate: FieldRef<"ChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ChangeLog findUnique
   */
  export type ChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog findUniqueOrThrow
   */
  export type ChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog findFirst
   */
  export type ChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * ChangeLog findFirstOrThrow
   */
  export type ChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * ChangeLog findMany
   */
  export type ChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLogs to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * ChangeLog create
   */
  export type ChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeLog.
     */
    data: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
  }


  /**
   * ChangeLog createMany
   */
  export type ChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeLogs.
     */
    data: ChangeLogCreateManyInput | ChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ChangeLog update
   */
  export type ChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeLog.
     */
    data: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
    /**
     * Choose, which ChangeLog to update.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog updateMany
   */
  export type ChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeLogs.
     */
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ChangeLogs to update
     */
    where?: ChangeLogWhereInput
  }


  /**
   * ChangeLog upsert
   */
  export type ChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeLog to update in case it exists.
     */
    where: ChangeLogWhereUniqueInput
    /**
     * In case the ChangeLog found by the `where` argument doesn't exist, create a new ChangeLog with this data.
     */
    create: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
    /**
     * In case the ChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
  }


  /**
   * ChangeLog delete
   */
  export type ChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter which ChangeLog to delete.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog deleteMany
   */
  export type ChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLogs to delete
     */
    where?: ChangeLogWhereInput
  }


  /**
   * ChangeLog.Creator
   */
  export type ChangeLog$CreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }


  /**
   * ChangeLog without action
   */
  export type ChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    mudId: 'mudId',
    createdDate: 'createdDate',
    modifiedDate: 'modifiedDate',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    preferences: 'preferences',
    roles: 'roles'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountNotificationScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    notificationId: 'notificationId',
    read: 'read',
    readDate: 'readDate'
  };

  export type AccountNotificationScalarFieldEnum = (typeof AccountNotificationScalarFieldEnum)[keyof typeof AccountNotificationScalarFieldEnum]


  export const AccountPasswordScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    passwordHash: 'passwordHash'
  };

  export type AccountPasswordScalarFieldEnum = (typeof AccountPasswordScalarFieldEnum)[keyof typeof AccountPasswordScalarFieldEnum]


  export const NetworkHistoryScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    createdDate: 'createdDate',
    loginDate: 'loginDate',
    ipAddress: 'ipAddress'
  };

  export type NetworkHistoryScalarFieldEnum = (typeof NetworkHistoryScalarFieldEnum)[keyof typeof NetworkHistoryScalarFieldEnum]


  export const NetworkBlacklistScalarFieldEnum: {
    id: 'id',
    networkHistoryId: 'networkHistoryId',
    issueDate: 'issueDate',
    termDate: 'termDate',
    issuer: 'issuer'
  };

  export type NetworkBlacklistScalarFieldEnum = (typeof NetworkBlacklistScalarFieldEnum)[keyof typeof NetworkBlacklistScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    type: 'type',
    title: 'title',
    description: 'description',
    content: 'content'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    mudId: 'mudId',
    accountId: 'accountId',
    createdDate: 'createdDate',
    modifiedDate: 'modifiedDate',
    name: 'name',
    description: 'description',
    level: 'level'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const CharacterVersionScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    equipmentId: 'equipmentId',
    statsId: 'statsId',
    createdDate: 'createdDate',
    modifiedDate: 'modifiedDate',
    version: 'version',
    hometown: 'hometown',
    characterEquipmentId: 'characterEquipmentId'
  };

  export type CharacterVersionScalarFieldEnum = (typeof CharacterVersionScalarFieldEnum)[keyof typeof CharacterVersionScalarFieldEnum]


  export const CharacterStatScalarFieldEnum: {
    id: 'id',
    characterVersionId: 'characterVersionId',
    str: 'str',
    min: 'min',
    dex: 'dex',
    con: 'con',
    per: 'per',
    spi: 'spi',
    strSwap: 'strSwap',
    minSwap: 'minSwap',
    dexSwap: 'dexSwap',
    conSwap: 'conSwap',
    perSwap: 'perSwap',
    spiSwap: 'spiSwap'
  };

  export type CharacterStatScalarFieldEnum = (typeof CharacterStatScalarFieldEnum)[keyof typeof CharacterStatScalarFieldEnum]


  export const CharacterQuestScalarFieldEnum: {
    id: 'id',
    characterVersionId: 'characterVersionId',
    questId: 'questId'
  };

  export type CharacterQuestScalarFieldEnum = (typeof CharacterQuestScalarFieldEnum)[keyof typeof CharacterQuestScalarFieldEnum]


  export const CharacterEquipmentScalarFieldEnum: {
    id: 'id',
    light: 'light',
    finger1: 'finger1',
    finger2: 'finger2',
    neck1: 'neck1',
    neck2: 'neck2',
    body: 'body',
    head: 'head',
    hands: 'hands',
    feet: 'feet',
    face: 'face',
    arms: 'arms',
    legs: 'legs',
    about: 'about',
    waist: 'waist',
    wrist1: 'wrist1',
    wrist2: 'wrist2',
    wield: 'wield',
    hold1: 'hold1',
    hold2: 'hold2',
    hold3: 'hold3',
    ear1: 'ear1',
    ear2: 'ear2',
    arm: 'arm',
    amulet: 'amulet',
    aux: 'aux'
  };

  export type CharacterEquipmentScalarFieldEnum = (typeof CharacterEquipmentScalarFieldEnum)[keyof typeof CharacterEquipmentScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    modifiedDate: 'modifiedDate',
    modifiedBy: 'modifiedBy',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    timer: 'timer',
    align: 'align',
    rent: 'rent',
    preservable: 'preservable',
    netStat: 'netStat',
    notes: 'notes',
    weight: 'weight',
    slots: 'slots',
    isBonded: 'isBonded',
    isCastable: 'isCastable',
    isHeroic: 'isHeroic',
    isLevelRequired: 'isLevelRequired',
    isLight: 'isLight',
    isLimited: 'isLimited',
    isSoulbound: 'isSoulbound',
    isUnique: 'isUnique'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemWeaponScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    quality: 'quality',
    speed: 'speed',
    isHoldable: 'isHoldable',
    isTwoHanded: 'isTwoHanded',
    ammoCapacity: 'ammoCapacity',
    ammoTypeId: 'ammoTypeId',
    shotAccuracy: 'shotAccuracy',
    maxDamage: 'maxDamage',
    minDamage: 'minDamage',
    avgDamage: 'avgDamage',
    stat: 'stat',
    type: 'type'
  };

  export type ItemWeaponScalarFieldEnum = (typeof ItemWeaponScalarFieldEnum)[keyof typeof ItemWeaponScalarFieldEnum]


  export const ItemSpellScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    spellId: 'spellId'
  };

  export type ItemSpellScalarFieldEnum = (typeof ItemSpellScalarFieldEnum)[keyof typeof ItemSpellScalarFieldEnum]


  export const SpellScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    modifiedDate: 'modifiedDate',
    modifiedBy: 'modifiedBy',
    name: 'name',
    description: 'description',
    notes: 'notes',
    words: 'words',
    levelRequirement: 'levelRequirement'
  };

  export type SpellScalarFieldEnum = (typeof SpellScalarFieldEnum)[keyof typeof SpellScalarFieldEnum]


  export const PotionScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    modifiedDate: 'modifiedDate',
    modifiedBy: 'modifiedBy',
    name: 'name',
    description: 'description',
    notes: 'notes',
    duration: 'duration'
  };

  export type PotionScalarFieldEnum = (typeof PotionScalarFieldEnum)[keyof typeof PotionScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    modifiedDate: 'modifiedDate',
    modifiedBy: 'modifiedBy',
    name: 'name',
    description: 'description',
    notes: 'notes',
    trainable: 'trainable',
    levelRequirement: 'levelRequirement'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const AbilityScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    modifiedDate: 'modifiedDate',
    modifiedBy: 'modifiedBy',
    name: 'name',
    description: 'description',
    notes: 'notes',
    firstRankPoints: 'firstRankPoints',
    secondRankPoints: 'secondRankPoints',
    thirdRankPoints: 'thirdRankPoints',
    fourthRankPoints: 'fourthRankPoints',
    fifthRankPoints: 'fifthRankPoints',
    sixthRankPoints: 'sixthRankPoints'
  };

  export type AbilityScalarFieldEnum = (typeof AbilityScalarFieldEnum)[keyof typeof AbilityScalarFieldEnum]


  export const QuestScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    modifiedDate: 'modifiedDate',
    modifiedBy: 'modifiedBy',
    name: 'name',
    description: 'description',
    notes: 'notes',
    whoises: 'whoises',
    pretitles: 'pretitles',
    post_titles: 'post_titles',
    experience: 'experience'
  };

  export type QuestScalarFieldEnum = (typeof QuestScalarFieldEnum)[keyof typeof QuestScalarFieldEnum]


  export const StatModiferScalarFieldEnum: {
    id: 'id',
    type: 'type',
    sourceId: 'sourceId',
    hp: 'hp',
    mv: 'mv',
    ma: 'ma',
    ac: 'ac',
    str: 'str',
    min: 'min',
    dex: 'dex',
    con: 'con',
    per: 'per',
    spi: 'spi',
    hpRegen: 'hpRegen',
    mvRegen: 'mvRegen',
    maRegen: 'maRegen',
    damroll: 'damroll',
    hitroll: 'hitroll',
    mitigation: 'mitigation',
    spellDam: 'spellDam',
    spellCrit: 'spellCrit',
    spellRedux: 'spellRedux',
    concentration: 'concentration',
    shotAccuracy: 'shotAccuracy',
    bonusAccuracy: 'bonusAccuracy',
    ammoCapacity: 'ammoCapacity',
    parry: 'parry',
    strCap: 'strCap',
    minCap: 'minCap',
    dexCap: 'dexCap',
    conCap: 'conCap',
    perCap: 'perCap',
    spiCap: 'spiCap'
  };

  export type StatModiferScalarFieldEnum = (typeof StatModiferScalarFieldEnum)[keyof typeof StatModiferScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    authorId: 'authorId',
    isProtected: 'isProtected'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const ArticleVersionScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    modifiedDate: 'modifiedDate',
    editorId: 'editorId',
    content: 'content',
    isCurrent: 'isCurrent',
    version: 'version'
  };

  export type ArticleVersionScalarFieldEnum = (typeof ArticleVersionScalarFieldEnum)[keyof typeof ArticleVersionScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    tag: 'tag'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const AppliedTagScalarFieldEnum: {
    id: 'id',
    typeId: 'typeId',
    sourceId: 'sourceId',
    tagId: 'tagId'
  };

  export type AppliedTagScalarFieldEnum = (typeof AppliedTagScalarFieldEnum)[keyof typeof AppliedTagScalarFieldEnum]


  export const MobScalarFieldEnum: {
    id: 'id',
    mudId: 'mudId',
    areaId: 'areaId',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    level: 'level',
    isAggressive: 'isAggressive',
    experience: 'experience',
    gold: 'gold'
  };

  export type MobScalarFieldEnum = (typeof MobScalarFieldEnum)[keyof typeof MobScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    mudId: 'mudId',
    name: 'name',
    authorId: 'authorId',
    releaseDate: 'releaseDate'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const ChangeLogScalarFieldEnum: {
    id: 'id',
    createdDate: 'createdDate',
    createdBy: 'createdBy',
    content: 'content',
    version: 'version',
    releaseDate: 'releaseDate'
  };

  export type ChangeLogScalarFieldEnum = (typeof ChangeLogScalarFieldEnum)[keyof typeof ChangeLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'Align'
   */
  export type EnumAlignFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Align'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'WeaponStat'
   */
  export type EnumWeaponStatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponStat'>
    


  /**
   * Reference to a field of type 'WeaponType'
   */
  export type EnumWeaponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponType'>
    


  /**
   * Reference to a field of type 'StatModifierType'
   */
  export type EnumStatModifierTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatModifierType'>
    


  /**
   * Reference to a field of type 'TagType'
   */
  export type EnumTagTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagType'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    mudId?: StringNullableFilter<"Account"> | string | null
    createdDate?: DateTimeFilter<"Account"> | Date | string
    modifiedDate?: DateTimeFilter<"Account"> | Date | string
    firstName?: StringNullableFilter<"Account"> | string | null
    lastName?: StringNullableFilter<"Account"> | string | null
    email?: StringFilter<"Account"> | string
    preferences?: JsonNullableFilter<"Account">
    roles?: JsonNullableFilter<"Account">
    AccountNotification?: AccountNotificationListRelationFilter
    AccountPassword?: AccountPasswordListRelationFilter
    Character?: CharacterListRelationFilter
    NetworkHistory?: NetworkHistoryListRelationFilter
    NetworkBlacklist?: NetworkBlacklistListRelationFilter
    Notification?: NotificationListRelationFilter
    CreatedItems?: ItemListRelationFilter
    ModifiedItems?: ItemListRelationFilter
    CreatedSpells?: SpellListRelationFilter
    ModifiedSpells?: SpellListRelationFilter
    CreatedPotions?: PotionListRelationFilter
    ModifiedPotions?: PotionListRelationFilter
    CreatedSkills?: SkillListRelationFilter
    ModifiedSkills?: SkillListRelationFilter
    CreatedAbilities?: AbilityListRelationFilter
    ModifiedAbilities?: AbilityListRelationFilter
    CreatedQuests?: QuestListRelationFilter
    ModifiedQuests?: QuestListRelationFilter
    Article?: ArticleListRelationFilter
    ArticleVersion?: ArticleVersionListRelationFilter
    Tag?: TagListRelationFilter
    Area?: AreaListRelationFilter
    ChangeLog?: ChangeLogListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    preferences?: SortOrderInput | SortOrder
    roles?: SortOrderInput | SortOrder
    AccountNotification?: AccountNotificationOrderByRelationAggregateInput
    AccountPassword?: AccountPasswordOrderByRelationAggregateInput
    Character?: CharacterOrderByRelationAggregateInput
    NetworkHistory?: NetworkHistoryOrderByRelationAggregateInput
    NetworkBlacklist?: NetworkBlacklistOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    CreatedItems?: ItemOrderByRelationAggregateInput
    ModifiedItems?: ItemOrderByRelationAggregateInput
    CreatedSpells?: SpellOrderByRelationAggregateInput
    ModifiedSpells?: SpellOrderByRelationAggregateInput
    CreatedPotions?: PotionOrderByRelationAggregateInput
    ModifiedPotions?: PotionOrderByRelationAggregateInput
    CreatedSkills?: SkillOrderByRelationAggregateInput
    ModifiedSkills?: SkillOrderByRelationAggregateInput
    CreatedAbilities?: AbilityOrderByRelationAggregateInput
    ModifiedAbilities?: AbilityOrderByRelationAggregateInput
    CreatedQuests?: QuestOrderByRelationAggregateInput
    ModifiedQuests?: QuestOrderByRelationAggregateInput
    Article?: ArticleOrderByRelationAggregateInput
    ArticleVersion?: ArticleVersionOrderByRelationAggregateInput
    Tag?: TagOrderByRelationAggregateInput
    Area?: AreaOrderByRelationAggregateInput
    ChangeLog?: ChangeLogOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    mudId?: StringNullableFilter<"Account"> | string | null
    createdDate?: DateTimeFilter<"Account"> | Date | string
    modifiedDate?: DateTimeFilter<"Account"> | Date | string
    firstName?: StringNullableFilter<"Account"> | string | null
    lastName?: StringNullableFilter<"Account"> | string | null
    preferences?: JsonNullableFilter<"Account">
    roles?: JsonNullableFilter<"Account">
    AccountNotification?: AccountNotificationListRelationFilter
    AccountPassword?: AccountPasswordListRelationFilter
    Character?: CharacterListRelationFilter
    NetworkHistory?: NetworkHistoryListRelationFilter
    NetworkBlacklist?: NetworkBlacklistListRelationFilter
    Notification?: NotificationListRelationFilter
    CreatedItems?: ItemListRelationFilter
    ModifiedItems?: ItemListRelationFilter
    CreatedSpells?: SpellListRelationFilter
    ModifiedSpells?: SpellListRelationFilter
    CreatedPotions?: PotionListRelationFilter
    ModifiedPotions?: PotionListRelationFilter
    CreatedSkills?: SkillListRelationFilter
    ModifiedSkills?: SkillListRelationFilter
    CreatedAbilities?: AbilityListRelationFilter
    ModifiedAbilities?: AbilityListRelationFilter
    CreatedQuests?: QuestListRelationFilter
    ModifiedQuests?: QuestListRelationFilter
    Article?: ArticleListRelationFilter
    ArticleVersion?: ArticleVersionListRelationFilter
    Tag?: TagListRelationFilter
    Area?: AreaListRelationFilter
    ChangeLog?: ChangeLogListRelationFilter
  }, "id" | "email">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    preferences?: SortOrderInput | SortOrder
    roles?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    mudId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdDate?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    modifiedDate?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    firstName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    email?: StringWithAggregatesFilter<"Account"> | string
    preferences?: JsonNullableWithAggregatesFilter<"Account">
    roles?: JsonNullableWithAggregatesFilter<"Account">
  }

  export type AccountNotificationWhereInput = {
    AND?: AccountNotificationWhereInput | AccountNotificationWhereInput[]
    OR?: AccountNotificationWhereInput[]
    NOT?: AccountNotificationWhereInput | AccountNotificationWhereInput[]
    id?: IntFilter<"AccountNotification"> | number
    accountId?: IntFilter<"AccountNotification"> | number
    notificationId?: IntFilter<"AccountNotification"> | number
    read?: BoolNullableFilter<"AccountNotification"> | boolean | null
    readDate?: DateTimeNullableFilter<"AccountNotification"> | Date | string | null
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type AccountNotificationOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    notificationId?: SortOrder
    read?: SortOrderInput | SortOrder
    readDate?: SortOrderInput | SortOrder
    Account?: AccountOrderByWithRelationInput
  }

  export type AccountNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountNotificationWhereInput | AccountNotificationWhereInput[]
    OR?: AccountNotificationWhereInput[]
    NOT?: AccountNotificationWhereInput | AccountNotificationWhereInput[]
    accountId?: IntFilter<"AccountNotification"> | number
    notificationId?: IntFilter<"AccountNotification"> | number
    read?: BoolNullableFilter<"AccountNotification"> | boolean | null
    readDate?: DateTimeNullableFilter<"AccountNotification"> | Date | string | null
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type AccountNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    notificationId?: SortOrder
    read?: SortOrderInput | SortOrder
    readDate?: SortOrderInput | SortOrder
    _count?: AccountNotificationCountOrderByAggregateInput
    _avg?: AccountNotificationAvgOrderByAggregateInput
    _max?: AccountNotificationMaxOrderByAggregateInput
    _min?: AccountNotificationMinOrderByAggregateInput
    _sum?: AccountNotificationSumOrderByAggregateInput
  }

  export type AccountNotificationScalarWhereWithAggregatesInput = {
    AND?: AccountNotificationScalarWhereWithAggregatesInput | AccountNotificationScalarWhereWithAggregatesInput[]
    OR?: AccountNotificationScalarWhereWithAggregatesInput[]
    NOT?: AccountNotificationScalarWhereWithAggregatesInput | AccountNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountNotification"> | number
    accountId?: IntWithAggregatesFilter<"AccountNotification"> | number
    notificationId?: IntWithAggregatesFilter<"AccountNotification"> | number
    read?: BoolNullableWithAggregatesFilter<"AccountNotification"> | boolean | null
    readDate?: DateTimeNullableWithAggregatesFilter<"AccountNotification"> | Date | string | null
  }

  export type AccountPasswordWhereInput = {
    AND?: AccountPasswordWhereInput | AccountPasswordWhereInput[]
    OR?: AccountPasswordWhereInput[]
    NOT?: AccountPasswordWhereInput | AccountPasswordWhereInput[]
    id?: IntFilter<"AccountPassword"> | number
    accountId?: IntFilter<"AccountPassword"> | number
    passwordHash?: StringFilter<"AccountPassword"> | string
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type AccountPasswordOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    passwordHash?: SortOrder
    Account?: AccountOrderByWithRelationInput
  }

  export type AccountPasswordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountPasswordWhereInput | AccountPasswordWhereInput[]
    OR?: AccountPasswordWhereInput[]
    NOT?: AccountPasswordWhereInput | AccountPasswordWhereInput[]
    accountId?: IntFilter<"AccountPassword"> | number
    passwordHash?: StringFilter<"AccountPassword"> | string
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type AccountPasswordOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    passwordHash?: SortOrder
    _count?: AccountPasswordCountOrderByAggregateInput
    _avg?: AccountPasswordAvgOrderByAggregateInput
    _max?: AccountPasswordMaxOrderByAggregateInput
    _min?: AccountPasswordMinOrderByAggregateInput
    _sum?: AccountPasswordSumOrderByAggregateInput
  }

  export type AccountPasswordScalarWhereWithAggregatesInput = {
    AND?: AccountPasswordScalarWhereWithAggregatesInput | AccountPasswordScalarWhereWithAggregatesInput[]
    OR?: AccountPasswordScalarWhereWithAggregatesInput[]
    NOT?: AccountPasswordScalarWhereWithAggregatesInput | AccountPasswordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountPassword"> | number
    accountId?: IntWithAggregatesFilter<"AccountPassword"> | number
    passwordHash?: StringWithAggregatesFilter<"AccountPassword"> | string
  }

  export type NetworkHistoryWhereInput = {
    AND?: NetworkHistoryWhereInput | NetworkHistoryWhereInput[]
    OR?: NetworkHistoryWhereInput[]
    NOT?: NetworkHistoryWhereInput | NetworkHistoryWhereInput[]
    id?: IntFilter<"NetworkHistory"> | number
    accountId?: IntFilter<"NetworkHistory"> | number
    createdDate?: DateTimeFilter<"NetworkHistory"> | Date | string
    loginDate?: DateTimeFilter<"NetworkHistory"> | Date | string
    ipAddress?: StringFilter<"NetworkHistory"> | string
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
    NetworkBlacklist?: NetworkBlacklistListRelationFilter
  }

  export type NetworkHistoryOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    loginDate?: SortOrder
    ipAddress?: SortOrder
    Account?: AccountOrderByWithRelationInput
    NetworkBlacklist?: NetworkBlacklistOrderByRelationAggregateInput
  }

  export type NetworkHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NetworkHistoryWhereInput | NetworkHistoryWhereInput[]
    OR?: NetworkHistoryWhereInput[]
    NOT?: NetworkHistoryWhereInput | NetworkHistoryWhereInput[]
    accountId?: IntFilter<"NetworkHistory"> | number
    createdDate?: DateTimeFilter<"NetworkHistory"> | Date | string
    loginDate?: DateTimeFilter<"NetworkHistory"> | Date | string
    ipAddress?: StringFilter<"NetworkHistory"> | string
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
    NetworkBlacklist?: NetworkBlacklistListRelationFilter
  }, "id">

  export type NetworkHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    loginDate?: SortOrder
    ipAddress?: SortOrder
    _count?: NetworkHistoryCountOrderByAggregateInput
    _avg?: NetworkHistoryAvgOrderByAggregateInput
    _max?: NetworkHistoryMaxOrderByAggregateInput
    _min?: NetworkHistoryMinOrderByAggregateInput
    _sum?: NetworkHistorySumOrderByAggregateInput
  }

  export type NetworkHistoryScalarWhereWithAggregatesInput = {
    AND?: NetworkHistoryScalarWhereWithAggregatesInput | NetworkHistoryScalarWhereWithAggregatesInput[]
    OR?: NetworkHistoryScalarWhereWithAggregatesInput[]
    NOT?: NetworkHistoryScalarWhereWithAggregatesInput | NetworkHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NetworkHistory"> | number
    accountId?: IntWithAggregatesFilter<"NetworkHistory"> | number
    createdDate?: DateTimeWithAggregatesFilter<"NetworkHistory"> | Date | string
    loginDate?: DateTimeWithAggregatesFilter<"NetworkHistory"> | Date | string
    ipAddress?: StringWithAggregatesFilter<"NetworkHistory"> | string
  }

  export type NetworkBlacklistWhereInput = {
    AND?: NetworkBlacklistWhereInput | NetworkBlacklistWhereInput[]
    OR?: NetworkBlacklistWhereInput[]
    NOT?: NetworkBlacklistWhereInput | NetworkBlacklistWhereInput[]
    id?: IntFilter<"NetworkBlacklist"> | number
    networkHistoryId?: IntFilter<"NetworkBlacklist"> | number
    issueDate?: DateTimeFilter<"NetworkBlacklist"> | Date | string
    termDate?: DateTimeFilter<"NetworkBlacklist"> | Date | string
    issuer?: IntFilter<"NetworkBlacklist"> | number
    NetworkHistory?: XOR<NetworkHistoryRelationFilter, NetworkHistoryWhereInput>
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type NetworkBlacklistOrderByWithRelationInput = {
    id?: SortOrder
    networkHistoryId?: SortOrder
    issueDate?: SortOrder
    termDate?: SortOrder
    issuer?: SortOrder
    NetworkHistory?: NetworkHistoryOrderByWithRelationInput
    Account?: AccountOrderByWithRelationInput
  }

  export type NetworkBlacklistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NetworkBlacklistWhereInput | NetworkBlacklistWhereInput[]
    OR?: NetworkBlacklistWhereInput[]
    NOT?: NetworkBlacklistWhereInput | NetworkBlacklistWhereInput[]
    networkHistoryId?: IntFilter<"NetworkBlacklist"> | number
    issueDate?: DateTimeFilter<"NetworkBlacklist"> | Date | string
    termDate?: DateTimeFilter<"NetworkBlacklist"> | Date | string
    issuer?: IntFilter<"NetworkBlacklist"> | number
    NetworkHistory?: XOR<NetworkHistoryRelationFilter, NetworkHistoryWhereInput>
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type NetworkBlacklistOrderByWithAggregationInput = {
    id?: SortOrder
    networkHistoryId?: SortOrder
    issueDate?: SortOrder
    termDate?: SortOrder
    issuer?: SortOrder
    _count?: NetworkBlacklistCountOrderByAggregateInput
    _avg?: NetworkBlacklistAvgOrderByAggregateInput
    _max?: NetworkBlacklistMaxOrderByAggregateInput
    _min?: NetworkBlacklistMinOrderByAggregateInput
    _sum?: NetworkBlacklistSumOrderByAggregateInput
  }

  export type NetworkBlacklistScalarWhereWithAggregatesInput = {
    AND?: NetworkBlacklistScalarWhereWithAggregatesInput | NetworkBlacklistScalarWhereWithAggregatesInput[]
    OR?: NetworkBlacklistScalarWhereWithAggregatesInput[]
    NOT?: NetworkBlacklistScalarWhereWithAggregatesInput | NetworkBlacklistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NetworkBlacklist"> | number
    networkHistoryId?: IntWithAggregatesFilter<"NetworkBlacklist"> | number
    issueDate?: DateTimeWithAggregatesFilter<"NetworkBlacklist"> | Date | string
    termDate?: DateTimeWithAggregatesFilter<"NetworkBlacklist"> | Date | string
    issuer?: IntWithAggregatesFilter<"NetworkBlacklist"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    createdDate?: DateTimeFilter<"Notification"> | Date | string
    createdBy?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    content?: StringNullableFilter<"Notification"> | string | null
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    Account?: AccountOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    createdDate?: DateTimeFilter<"Notification"> | Date | string
    createdBy?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    content?: StringNullableFilter<"Notification"> | string | null
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Notification"> | number
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    description?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    content?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: IntFilter<"Character"> | number
    mudId?: IntNullableFilter<"Character"> | number | null
    accountId?: IntFilter<"Character"> | number
    createdDate?: DateTimeFilter<"Character"> | Date | string
    modifiedDate?: DateTimeFilter<"Character"> | Date | string
    name?: StringFilter<"Character"> | string
    description?: StringNullableFilter<"Character"> | string | null
    level?: IntNullableFilter<"Character"> | number | null
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
    CharacterVersion?: CharacterVersionListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    Account?: AccountOrderByWithRelationInput
    CharacterVersion?: CharacterVersionOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    mudId?: IntNullableFilter<"Character"> | number | null
    accountId?: IntFilter<"Character"> | number
    createdDate?: DateTimeFilter<"Character"> | Date | string
    modifiedDate?: DateTimeFilter<"Character"> | Date | string
    name?: StringFilter<"Character"> | string
    description?: StringNullableFilter<"Character"> | string | null
    level?: IntNullableFilter<"Character"> | number | null
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
    CharacterVersion?: CharacterVersionListRelationFilter
  }, "id">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Character"> | number
    mudId?: IntNullableWithAggregatesFilter<"Character"> | number | null
    accountId?: IntWithAggregatesFilter<"Character"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    modifiedDate?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    name?: StringWithAggregatesFilter<"Character"> | string
    description?: StringNullableWithAggregatesFilter<"Character"> | string | null
    level?: IntNullableWithAggregatesFilter<"Character"> | number | null
  }

  export type CharacterVersionWhereInput = {
    AND?: CharacterVersionWhereInput | CharacterVersionWhereInput[]
    OR?: CharacterVersionWhereInput[]
    NOT?: CharacterVersionWhereInput | CharacterVersionWhereInput[]
    id?: IntFilter<"CharacterVersion"> | number
    characterId?: IntFilter<"CharacterVersion"> | number
    equipmentId?: IntFilter<"CharacterVersion"> | number
    statsId?: IntFilter<"CharacterVersion"> | number
    createdDate?: DateTimeFilter<"CharacterVersion"> | Date | string
    modifiedDate?: DateTimeFilter<"CharacterVersion"> | Date | string
    version?: StringFilter<"CharacterVersion"> | string
    hometown?: StringNullableFilter<"CharacterVersion"> | string | null
    characterEquipmentId?: IntNullableFilter<"CharacterVersion"> | number | null
    Character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    CharacterStat?: XOR<CharacterStatNullableRelationFilter, CharacterStatWhereInput> | null
    CharacterQuest?: CharacterQuestListRelationFilter
    CharacterEquipment?: XOR<CharacterEquipmentNullableRelationFilter, CharacterEquipmentWhereInput> | null
  }

  export type CharacterVersionOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    equipmentId?: SortOrder
    statsId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    version?: SortOrder
    hometown?: SortOrderInput | SortOrder
    characterEquipmentId?: SortOrderInput | SortOrder
    Character?: CharacterOrderByWithRelationInput
    CharacterStat?: CharacterStatOrderByWithRelationInput
    CharacterQuest?: CharacterQuestOrderByRelationAggregateInput
    CharacterEquipment?: CharacterEquipmentOrderByWithRelationInput
  }

  export type CharacterVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CharacterVersionWhereInput | CharacterVersionWhereInput[]
    OR?: CharacterVersionWhereInput[]
    NOT?: CharacterVersionWhereInput | CharacterVersionWhereInput[]
    characterId?: IntFilter<"CharacterVersion"> | number
    equipmentId?: IntFilter<"CharacterVersion"> | number
    statsId?: IntFilter<"CharacterVersion"> | number
    createdDate?: DateTimeFilter<"CharacterVersion"> | Date | string
    modifiedDate?: DateTimeFilter<"CharacterVersion"> | Date | string
    version?: StringFilter<"CharacterVersion"> | string
    hometown?: StringNullableFilter<"CharacterVersion"> | string | null
    characterEquipmentId?: IntNullableFilter<"CharacterVersion"> | number | null
    Character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    CharacterStat?: XOR<CharacterStatNullableRelationFilter, CharacterStatWhereInput> | null
    CharacterQuest?: CharacterQuestListRelationFilter
    CharacterEquipment?: XOR<CharacterEquipmentNullableRelationFilter, CharacterEquipmentWhereInput> | null
  }, "id">

  export type CharacterVersionOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    equipmentId?: SortOrder
    statsId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    version?: SortOrder
    hometown?: SortOrderInput | SortOrder
    characterEquipmentId?: SortOrderInput | SortOrder
    _count?: CharacterVersionCountOrderByAggregateInput
    _avg?: CharacterVersionAvgOrderByAggregateInput
    _max?: CharacterVersionMaxOrderByAggregateInput
    _min?: CharacterVersionMinOrderByAggregateInput
    _sum?: CharacterVersionSumOrderByAggregateInput
  }

  export type CharacterVersionScalarWhereWithAggregatesInput = {
    AND?: CharacterVersionScalarWhereWithAggregatesInput | CharacterVersionScalarWhereWithAggregatesInput[]
    OR?: CharacterVersionScalarWhereWithAggregatesInput[]
    NOT?: CharacterVersionScalarWhereWithAggregatesInput | CharacterVersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CharacterVersion"> | number
    characterId?: IntWithAggregatesFilter<"CharacterVersion"> | number
    equipmentId?: IntWithAggregatesFilter<"CharacterVersion"> | number
    statsId?: IntWithAggregatesFilter<"CharacterVersion"> | number
    createdDate?: DateTimeWithAggregatesFilter<"CharacterVersion"> | Date | string
    modifiedDate?: DateTimeWithAggregatesFilter<"CharacterVersion"> | Date | string
    version?: StringWithAggregatesFilter<"CharacterVersion"> | string
    hometown?: StringNullableWithAggregatesFilter<"CharacterVersion"> | string | null
    characterEquipmentId?: IntNullableWithAggregatesFilter<"CharacterVersion"> | number | null
  }

  export type CharacterStatWhereInput = {
    AND?: CharacterStatWhereInput | CharacterStatWhereInput[]
    OR?: CharacterStatWhereInput[]
    NOT?: CharacterStatWhereInput | CharacterStatWhereInput[]
    id?: IntFilter<"CharacterStat"> | number
    characterVersionId?: IntFilter<"CharacterStat"> | number
    str?: IntNullableFilter<"CharacterStat"> | number | null
    min?: IntNullableFilter<"CharacterStat"> | number | null
    dex?: IntNullableFilter<"CharacterStat"> | number | null
    con?: IntNullableFilter<"CharacterStat"> | number | null
    per?: IntNullableFilter<"CharacterStat"> | number | null
    spi?: IntNullableFilter<"CharacterStat"> | number | null
    strSwap?: IntNullableFilter<"CharacterStat"> | number | null
    minSwap?: IntNullableFilter<"CharacterStat"> | number | null
    dexSwap?: IntNullableFilter<"CharacterStat"> | number | null
    conSwap?: IntNullableFilter<"CharacterStat"> | number | null
    perSwap?: IntNullableFilter<"CharacterStat"> | number | null
    spiSwap?: IntNullableFilter<"CharacterStat"> | number | null
    CharacterVersion?: XOR<CharacterVersionRelationFilter, CharacterVersionWhereInput>
  }

  export type CharacterStatOrderByWithRelationInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    str?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    dex?: SortOrderInput | SortOrder
    con?: SortOrderInput | SortOrder
    per?: SortOrderInput | SortOrder
    spi?: SortOrderInput | SortOrder
    strSwap?: SortOrderInput | SortOrder
    minSwap?: SortOrderInput | SortOrder
    dexSwap?: SortOrderInput | SortOrder
    conSwap?: SortOrderInput | SortOrder
    perSwap?: SortOrderInput | SortOrder
    spiSwap?: SortOrderInput | SortOrder
    CharacterVersion?: CharacterVersionOrderByWithRelationInput
  }

  export type CharacterStatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    characterVersionId?: number
    AND?: CharacterStatWhereInput | CharacterStatWhereInput[]
    OR?: CharacterStatWhereInput[]
    NOT?: CharacterStatWhereInput | CharacterStatWhereInput[]
    str?: IntNullableFilter<"CharacterStat"> | number | null
    min?: IntNullableFilter<"CharacterStat"> | number | null
    dex?: IntNullableFilter<"CharacterStat"> | number | null
    con?: IntNullableFilter<"CharacterStat"> | number | null
    per?: IntNullableFilter<"CharacterStat"> | number | null
    spi?: IntNullableFilter<"CharacterStat"> | number | null
    strSwap?: IntNullableFilter<"CharacterStat"> | number | null
    minSwap?: IntNullableFilter<"CharacterStat"> | number | null
    dexSwap?: IntNullableFilter<"CharacterStat"> | number | null
    conSwap?: IntNullableFilter<"CharacterStat"> | number | null
    perSwap?: IntNullableFilter<"CharacterStat"> | number | null
    spiSwap?: IntNullableFilter<"CharacterStat"> | number | null
    CharacterVersion?: XOR<CharacterVersionRelationFilter, CharacterVersionWhereInput>
  }, "id" | "characterVersionId">

  export type CharacterStatOrderByWithAggregationInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    str?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    dex?: SortOrderInput | SortOrder
    con?: SortOrderInput | SortOrder
    per?: SortOrderInput | SortOrder
    spi?: SortOrderInput | SortOrder
    strSwap?: SortOrderInput | SortOrder
    minSwap?: SortOrderInput | SortOrder
    dexSwap?: SortOrderInput | SortOrder
    conSwap?: SortOrderInput | SortOrder
    perSwap?: SortOrderInput | SortOrder
    spiSwap?: SortOrderInput | SortOrder
    _count?: CharacterStatCountOrderByAggregateInput
    _avg?: CharacterStatAvgOrderByAggregateInput
    _max?: CharacterStatMaxOrderByAggregateInput
    _min?: CharacterStatMinOrderByAggregateInput
    _sum?: CharacterStatSumOrderByAggregateInput
  }

  export type CharacterStatScalarWhereWithAggregatesInput = {
    AND?: CharacterStatScalarWhereWithAggregatesInput | CharacterStatScalarWhereWithAggregatesInput[]
    OR?: CharacterStatScalarWhereWithAggregatesInput[]
    NOT?: CharacterStatScalarWhereWithAggregatesInput | CharacterStatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CharacterStat"> | number
    characterVersionId?: IntWithAggregatesFilter<"CharacterStat"> | number
    str?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    min?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    dex?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    con?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    per?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    spi?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    strSwap?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    minSwap?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    dexSwap?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    conSwap?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    perSwap?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
    spiSwap?: IntNullableWithAggregatesFilter<"CharacterStat"> | number | null
  }

  export type CharacterQuestWhereInput = {
    AND?: CharacterQuestWhereInput | CharacterQuestWhereInput[]
    OR?: CharacterQuestWhereInput[]
    NOT?: CharacterQuestWhereInput | CharacterQuestWhereInput[]
    id?: IntFilter<"CharacterQuest"> | number
    characterVersionId?: IntFilter<"CharacterQuest"> | number
    questId?: IntFilter<"CharacterQuest"> | number
    CharacterVersion?: XOR<CharacterVersionRelationFilter, CharacterVersionWhereInput>
    Quest?: XOR<QuestRelationFilter, QuestWhereInput>
  }

  export type CharacterQuestOrderByWithRelationInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    questId?: SortOrder
    CharacterVersion?: CharacterVersionOrderByWithRelationInput
    Quest?: QuestOrderByWithRelationInput
  }

  export type CharacterQuestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CharacterQuestWhereInput | CharacterQuestWhereInput[]
    OR?: CharacterQuestWhereInput[]
    NOT?: CharacterQuestWhereInput | CharacterQuestWhereInput[]
    characterVersionId?: IntFilter<"CharacterQuest"> | number
    questId?: IntFilter<"CharacterQuest"> | number
    CharacterVersion?: XOR<CharacterVersionRelationFilter, CharacterVersionWhereInput>
    Quest?: XOR<QuestRelationFilter, QuestWhereInput>
  }, "id">

  export type CharacterQuestOrderByWithAggregationInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    questId?: SortOrder
    _count?: CharacterQuestCountOrderByAggregateInput
    _avg?: CharacterQuestAvgOrderByAggregateInput
    _max?: CharacterQuestMaxOrderByAggregateInput
    _min?: CharacterQuestMinOrderByAggregateInput
    _sum?: CharacterQuestSumOrderByAggregateInput
  }

  export type CharacterQuestScalarWhereWithAggregatesInput = {
    AND?: CharacterQuestScalarWhereWithAggregatesInput | CharacterQuestScalarWhereWithAggregatesInput[]
    OR?: CharacterQuestScalarWhereWithAggregatesInput[]
    NOT?: CharacterQuestScalarWhereWithAggregatesInput | CharacterQuestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CharacterQuest"> | number
    characterVersionId?: IntWithAggregatesFilter<"CharacterQuest"> | number
    questId?: IntWithAggregatesFilter<"CharacterQuest"> | number
  }

  export type CharacterEquipmentWhereInput = {
    AND?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    OR?: CharacterEquipmentWhereInput[]
    NOT?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    id?: IntFilter<"CharacterEquipment"> | number
    light?: IntNullableFilter<"CharacterEquipment"> | number | null
    finger1?: IntNullableFilter<"CharacterEquipment"> | number | null
    finger2?: IntNullableFilter<"CharacterEquipment"> | number | null
    neck1?: IntNullableFilter<"CharacterEquipment"> | number | null
    neck2?: IntNullableFilter<"CharacterEquipment"> | number | null
    body?: IntNullableFilter<"CharacterEquipment"> | number | null
    head?: IntNullableFilter<"CharacterEquipment"> | number | null
    hands?: IntNullableFilter<"CharacterEquipment"> | number | null
    feet?: IntNullableFilter<"CharacterEquipment"> | number | null
    face?: IntNullableFilter<"CharacterEquipment"> | number | null
    arms?: IntNullableFilter<"CharacterEquipment"> | number | null
    legs?: IntNullableFilter<"CharacterEquipment"> | number | null
    about?: IntNullableFilter<"CharacterEquipment"> | number | null
    waist?: IntNullableFilter<"CharacterEquipment"> | number | null
    wrist1?: IntNullableFilter<"CharacterEquipment"> | number | null
    wrist2?: IntNullableFilter<"CharacterEquipment"> | number | null
    wield?: IntNullableFilter<"CharacterEquipment"> | number | null
    hold1?: IntNullableFilter<"CharacterEquipment"> | number | null
    hold2?: IntNullableFilter<"CharacterEquipment"> | number | null
    hold3?: IntNullableFilter<"CharacterEquipment"> | number | null
    ear1?: IntNullableFilter<"CharacterEquipment"> | number | null
    ear2?: IntNullableFilter<"CharacterEquipment"> | number | null
    arm?: IntNullableFilter<"CharacterEquipment"> | number | null
    amulet?: IntNullableFilter<"CharacterEquipment"> | number | null
    aux?: IntNullableFilter<"CharacterEquipment"> | number | null
    CharacterVersion?: CharacterVersionListRelationFilter
  }

  export type CharacterEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    light?: SortOrderInput | SortOrder
    finger1?: SortOrderInput | SortOrder
    finger2?: SortOrderInput | SortOrder
    neck1?: SortOrderInput | SortOrder
    neck2?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    head?: SortOrderInput | SortOrder
    hands?: SortOrderInput | SortOrder
    feet?: SortOrderInput | SortOrder
    face?: SortOrderInput | SortOrder
    arms?: SortOrderInput | SortOrder
    legs?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    wrist1?: SortOrderInput | SortOrder
    wrist2?: SortOrderInput | SortOrder
    wield?: SortOrderInput | SortOrder
    hold1?: SortOrderInput | SortOrder
    hold2?: SortOrderInput | SortOrder
    hold3?: SortOrderInput | SortOrder
    ear1?: SortOrderInput | SortOrder
    ear2?: SortOrderInput | SortOrder
    arm?: SortOrderInput | SortOrder
    amulet?: SortOrderInput | SortOrder
    aux?: SortOrderInput | SortOrder
    CharacterVersion?: CharacterVersionOrderByRelationAggregateInput
  }

  export type CharacterEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    OR?: CharacterEquipmentWhereInput[]
    NOT?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    light?: IntNullableFilter<"CharacterEquipment"> | number | null
    finger1?: IntNullableFilter<"CharacterEquipment"> | number | null
    finger2?: IntNullableFilter<"CharacterEquipment"> | number | null
    neck1?: IntNullableFilter<"CharacterEquipment"> | number | null
    neck2?: IntNullableFilter<"CharacterEquipment"> | number | null
    body?: IntNullableFilter<"CharacterEquipment"> | number | null
    head?: IntNullableFilter<"CharacterEquipment"> | number | null
    hands?: IntNullableFilter<"CharacterEquipment"> | number | null
    feet?: IntNullableFilter<"CharacterEquipment"> | number | null
    face?: IntNullableFilter<"CharacterEquipment"> | number | null
    arms?: IntNullableFilter<"CharacterEquipment"> | number | null
    legs?: IntNullableFilter<"CharacterEquipment"> | number | null
    about?: IntNullableFilter<"CharacterEquipment"> | number | null
    waist?: IntNullableFilter<"CharacterEquipment"> | number | null
    wrist1?: IntNullableFilter<"CharacterEquipment"> | number | null
    wrist2?: IntNullableFilter<"CharacterEquipment"> | number | null
    wield?: IntNullableFilter<"CharacterEquipment"> | number | null
    hold1?: IntNullableFilter<"CharacterEquipment"> | number | null
    hold2?: IntNullableFilter<"CharacterEquipment"> | number | null
    hold3?: IntNullableFilter<"CharacterEquipment"> | number | null
    ear1?: IntNullableFilter<"CharacterEquipment"> | number | null
    ear2?: IntNullableFilter<"CharacterEquipment"> | number | null
    arm?: IntNullableFilter<"CharacterEquipment"> | number | null
    amulet?: IntNullableFilter<"CharacterEquipment"> | number | null
    aux?: IntNullableFilter<"CharacterEquipment"> | number | null
    CharacterVersion?: CharacterVersionListRelationFilter
  }, "id">

  export type CharacterEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    light?: SortOrderInput | SortOrder
    finger1?: SortOrderInput | SortOrder
    finger2?: SortOrderInput | SortOrder
    neck1?: SortOrderInput | SortOrder
    neck2?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    head?: SortOrderInput | SortOrder
    hands?: SortOrderInput | SortOrder
    feet?: SortOrderInput | SortOrder
    face?: SortOrderInput | SortOrder
    arms?: SortOrderInput | SortOrder
    legs?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    wrist1?: SortOrderInput | SortOrder
    wrist2?: SortOrderInput | SortOrder
    wield?: SortOrderInput | SortOrder
    hold1?: SortOrderInput | SortOrder
    hold2?: SortOrderInput | SortOrder
    hold3?: SortOrderInput | SortOrder
    ear1?: SortOrderInput | SortOrder
    ear2?: SortOrderInput | SortOrder
    arm?: SortOrderInput | SortOrder
    amulet?: SortOrderInput | SortOrder
    aux?: SortOrderInput | SortOrder
    _count?: CharacterEquipmentCountOrderByAggregateInput
    _avg?: CharacterEquipmentAvgOrderByAggregateInput
    _max?: CharacterEquipmentMaxOrderByAggregateInput
    _min?: CharacterEquipmentMinOrderByAggregateInput
    _sum?: CharacterEquipmentSumOrderByAggregateInput
  }

  export type CharacterEquipmentScalarWhereWithAggregatesInput = {
    AND?: CharacterEquipmentScalarWhereWithAggregatesInput | CharacterEquipmentScalarWhereWithAggregatesInput[]
    OR?: CharacterEquipmentScalarWhereWithAggregatesInput[]
    NOT?: CharacterEquipmentScalarWhereWithAggregatesInput | CharacterEquipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CharacterEquipment"> | number
    light?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    finger1?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    finger2?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    neck1?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    neck2?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    body?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    head?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    hands?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    feet?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    face?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    arms?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    legs?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    about?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    waist?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    wrist1?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    wrist2?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    wield?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    hold1?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    hold2?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    hold3?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    ear1?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    ear2?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    arm?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    amulet?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    aux?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: IntFilter<"Item"> | number
    createdDate?: DateTimeFilter<"Item"> | Date | string
    createdBy?: IntFilter<"Item"> | number
    modifiedDate?: DateTimeNullableFilter<"Item"> | Date | string | null
    modifiedBy?: IntNullableFilter<"Item"> | number | null
    shortDescription?: StringFilter<"Item"> | string
    longDescription?: StringNullableFilter<"Item"> | string | null
    timer?: IntNullableFilter<"Item"> | number | null
    align?: EnumAlignNullableFilter<"Item"> | $Enums.Align | null
    rent?: IntNullableFilter<"Item"> | number | null
    preservable?: BoolNullableFilter<"Item"> | boolean | null
    netStat?: IntNullableFilter<"Item"> | number | null
    notes?: StringNullableFilter<"Item"> | string | null
    weight?: FloatNullableFilter<"Item"> | number | null
    slots?: StringNullableFilter<"Item"> | string | null
    isBonded?: BoolNullableFilter<"Item"> | boolean | null
    isCastable?: BoolNullableFilter<"Item"> | boolean | null
    isHeroic?: BoolNullableFilter<"Item"> | boolean | null
    isLevelRequired?: BoolNullableFilter<"Item"> | boolean | null
    isLight?: BoolNullableFilter<"Item"> | boolean | null
    isLimited?: BoolNullableFilter<"Item"> | boolean | null
    isSoulbound?: BoolNullableFilter<"Item"> | boolean | null
    isUnique?: BoolNullableFilter<"Item"> | boolean | null
    CreatedItems?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedItems?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    ItemSpell?: ItemSpellListRelationFilter
    ItemWeapon?: XOR<ItemWeaponNullableRelationFilter, ItemWeaponWhereInput> | null
    AmmoItem?: ItemWeaponListRelationFilter
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
    ItemTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrderInput | SortOrder
    modifiedBy?: SortOrderInput | SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    timer?: SortOrderInput | SortOrder
    align?: SortOrderInput | SortOrder
    rent?: SortOrderInput | SortOrder
    preservable?: SortOrderInput | SortOrder
    netStat?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    slots?: SortOrderInput | SortOrder
    isBonded?: SortOrderInput | SortOrder
    isCastable?: SortOrderInput | SortOrder
    isHeroic?: SortOrderInput | SortOrder
    isLevelRequired?: SortOrderInput | SortOrder
    isLight?: SortOrderInput | SortOrder
    isLimited?: SortOrderInput | SortOrder
    isSoulbound?: SortOrderInput | SortOrder
    isUnique?: SortOrderInput | SortOrder
    CreatedItems?: AccountOrderByWithRelationInput
    ModifiedItems?: AccountOrderByWithRelationInput
    ItemSpell?: ItemSpellOrderByRelationAggregateInput
    ItemWeapon?: ItemWeaponOrderByWithRelationInput
    AmmoItem?: ItemWeaponOrderByRelationAggregateInput
    StatModifer?: StatModiferOrderByWithRelationInput
    ItemTagSource?: AppliedTagOrderByWithRelationInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    createdDate?: DateTimeFilter<"Item"> | Date | string
    createdBy?: IntFilter<"Item"> | number
    modifiedDate?: DateTimeNullableFilter<"Item"> | Date | string | null
    modifiedBy?: IntNullableFilter<"Item"> | number | null
    shortDescription?: StringFilter<"Item"> | string
    longDescription?: StringNullableFilter<"Item"> | string | null
    timer?: IntNullableFilter<"Item"> | number | null
    align?: EnumAlignNullableFilter<"Item"> | $Enums.Align | null
    rent?: IntNullableFilter<"Item"> | number | null
    preservable?: BoolNullableFilter<"Item"> | boolean | null
    netStat?: IntNullableFilter<"Item"> | number | null
    notes?: StringNullableFilter<"Item"> | string | null
    weight?: FloatNullableFilter<"Item"> | number | null
    slots?: StringNullableFilter<"Item"> | string | null
    isBonded?: BoolNullableFilter<"Item"> | boolean | null
    isCastable?: BoolNullableFilter<"Item"> | boolean | null
    isHeroic?: BoolNullableFilter<"Item"> | boolean | null
    isLevelRequired?: BoolNullableFilter<"Item"> | boolean | null
    isLight?: BoolNullableFilter<"Item"> | boolean | null
    isLimited?: BoolNullableFilter<"Item"> | boolean | null
    isSoulbound?: BoolNullableFilter<"Item"> | boolean | null
    isUnique?: BoolNullableFilter<"Item"> | boolean | null
    CreatedItems?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedItems?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    ItemSpell?: ItemSpellListRelationFilter
    ItemWeapon?: XOR<ItemWeaponNullableRelationFilter, ItemWeaponWhereInput> | null
    AmmoItem?: ItemWeaponListRelationFilter
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
    ItemTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrderInput | SortOrder
    modifiedBy?: SortOrderInput | SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    timer?: SortOrderInput | SortOrder
    align?: SortOrderInput | SortOrder
    rent?: SortOrderInput | SortOrder
    preservable?: SortOrderInput | SortOrder
    netStat?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    slots?: SortOrderInput | SortOrder
    isBonded?: SortOrderInput | SortOrder
    isCastable?: SortOrderInput | SortOrder
    isHeroic?: SortOrderInput | SortOrder
    isLevelRequired?: SortOrderInput | SortOrder
    isLight?: SortOrderInput | SortOrder
    isLimited?: SortOrderInput | SortOrder
    isSoulbound?: SortOrderInput | SortOrder
    isUnique?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Item"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Item"> | number
    modifiedDate?: DateTimeNullableWithAggregatesFilter<"Item"> | Date | string | null
    modifiedBy?: IntNullableWithAggregatesFilter<"Item"> | number | null
    shortDescription?: StringWithAggregatesFilter<"Item"> | string
    longDescription?: StringNullableWithAggregatesFilter<"Item"> | string | null
    timer?: IntNullableWithAggregatesFilter<"Item"> | number | null
    align?: EnumAlignNullableWithAggregatesFilter<"Item"> | $Enums.Align | null
    rent?: IntNullableWithAggregatesFilter<"Item"> | number | null
    preservable?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    netStat?: IntNullableWithAggregatesFilter<"Item"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Item"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"Item"> | number | null
    slots?: StringNullableWithAggregatesFilter<"Item"> | string | null
    isBonded?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    isCastable?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    isHeroic?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    isLevelRequired?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    isLight?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    isLimited?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    isSoulbound?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
    isUnique?: BoolNullableWithAggregatesFilter<"Item"> | boolean | null
  }

  export type ItemWeaponWhereInput = {
    AND?: ItemWeaponWhereInput | ItemWeaponWhereInput[]
    OR?: ItemWeaponWhereInput[]
    NOT?: ItemWeaponWhereInput | ItemWeaponWhereInput[]
    id?: IntFilter<"ItemWeapon"> | number
    itemId?: IntFilter<"ItemWeapon"> | number
    quality?: IntNullableFilter<"ItemWeapon"> | number | null
    speed?: IntNullableFilter<"ItemWeapon"> | number | null
    isHoldable?: BoolFilter<"ItemWeapon"> | boolean
    isTwoHanded?: BoolFilter<"ItemWeapon"> | boolean
    ammoCapacity?: IntNullableFilter<"ItemWeapon"> | number | null
    ammoTypeId?: IntFilter<"ItemWeapon"> | number
    shotAccuracy?: IntNullableFilter<"ItemWeapon"> | number | null
    maxDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    minDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    avgDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    stat?: EnumWeaponStatNullableFilter<"ItemWeapon"> | $Enums.WeaponStat | null
    type?: EnumWeaponTypeNullableFilter<"ItemWeapon"> | $Enums.WeaponType | null
    Item?: XOR<ItemRelationFilter, ItemWhereInput>
    AmmoItem?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type ItemWeaponOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    quality?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    isHoldable?: SortOrder
    isTwoHanded?: SortOrder
    ammoCapacity?: SortOrderInput | SortOrder
    ammoTypeId?: SortOrder
    shotAccuracy?: SortOrderInput | SortOrder
    maxDamage?: SortOrderInput | SortOrder
    minDamage?: SortOrderInput | SortOrder
    avgDamage?: SortOrderInput | SortOrder
    stat?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    Item?: ItemOrderByWithRelationInput
    AmmoItem?: ItemOrderByWithRelationInput
  }

  export type ItemWeaponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId?: number
    AND?: ItemWeaponWhereInput | ItemWeaponWhereInput[]
    OR?: ItemWeaponWhereInput[]
    NOT?: ItemWeaponWhereInput | ItemWeaponWhereInput[]
    quality?: IntNullableFilter<"ItemWeapon"> | number | null
    speed?: IntNullableFilter<"ItemWeapon"> | number | null
    isHoldable?: BoolFilter<"ItemWeapon"> | boolean
    isTwoHanded?: BoolFilter<"ItemWeapon"> | boolean
    ammoCapacity?: IntNullableFilter<"ItemWeapon"> | number | null
    ammoTypeId?: IntFilter<"ItemWeapon"> | number
    shotAccuracy?: IntNullableFilter<"ItemWeapon"> | number | null
    maxDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    minDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    avgDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    stat?: EnumWeaponStatNullableFilter<"ItemWeapon"> | $Enums.WeaponStat | null
    type?: EnumWeaponTypeNullableFilter<"ItemWeapon"> | $Enums.WeaponType | null
    Item?: XOR<ItemRelationFilter, ItemWhereInput>
    AmmoItem?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "id" | "itemId">

  export type ItemWeaponOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    quality?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    isHoldable?: SortOrder
    isTwoHanded?: SortOrder
    ammoCapacity?: SortOrderInput | SortOrder
    ammoTypeId?: SortOrder
    shotAccuracy?: SortOrderInput | SortOrder
    maxDamage?: SortOrderInput | SortOrder
    minDamage?: SortOrderInput | SortOrder
    avgDamage?: SortOrderInput | SortOrder
    stat?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: ItemWeaponCountOrderByAggregateInput
    _avg?: ItemWeaponAvgOrderByAggregateInput
    _max?: ItemWeaponMaxOrderByAggregateInput
    _min?: ItemWeaponMinOrderByAggregateInput
    _sum?: ItemWeaponSumOrderByAggregateInput
  }

  export type ItemWeaponScalarWhereWithAggregatesInput = {
    AND?: ItemWeaponScalarWhereWithAggregatesInput | ItemWeaponScalarWhereWithAggregatesInput[]
    OR?: ItemWeaponScalarWhereWithAggregatesInput[]
    NOT?: ItemWeaponScalarWhereWithAggregatesInput | ItemWeaponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemWeapon"> | number
    itemId?: IntWithAggregatesFilter<"ItemWeapon"> | number
    quality?: IntNullableWithAggregatesFilter<"ItemWeapon"> | number | null
    speed?: IntNullableWithAggregatesFilter<"ItemWeapon"> | number | null
    isHoldable?: BoolWithAggregatesFilter<"ItemWeapon"> | boolean
    isTwoHanded?: BoolWithAggregatesFilter<"ItemWeapon"> | boolean
    ammoCapacity?: IntNullableWithAggregatesFilter<"ItemWeapon"> | number | null
    ammoTypeId?: IntWithAggregatesFilter<"ItemWeapon"> | number
    shotAccuracy?: IntNullableWithAggregatesFilter<"ItemWeapon"> | number | null
    maxDamage?: IntNullableWithAggregatesFilter<"ItemWeapon"> | number | null
    minDamage?: IntNullableWithAggregatesFilter<"ItemWeapon"> | number | null
    avgDamage?: IntNullableWithAggregatesFilter<"ItemWeapon"> | number | null
    stat?: EnumWeaponStatNullableWithAggregatesFilter<"ItemWeapon"> | $Enums.WeaponStat | null
    type?: EnumWeaponTypeNullableWithAggregatesFilter<"ItemWeapon"> | $Enums.WeaponType | null
  }

  export type ItemSpellWhereInput = {
    AND?: ItemSpellWhereInput | ItemSpellWhereInput[]
    OR?: ItemSpellWhereInput[]
    NOT?: ItemSpellWhereInput | ItemSpellWhereInput[]
    id?: IntFilter<"ItemSpell"> | number
    itemId?: IntFilter<"ItemSpell"> | number
    spellId?: IntFilter<"ItemSpell"> | number
    Item?: XOR<ItemRelationFilter, ItemWhereInput>
    Spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type ItemSpellOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    spellId?: SortOrder
    Item?: ItemOrderByWithRelationInput
    Spell?: SpellOrderByWithRelationInput
  }

  export type ItemSpellWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemSpellWhereInput | ItemSpellWhereInput[]
    OR?: ItemSpellWhereInput[]
    NOT?: ItemSpellWhereInput | ItemSpellWhereInput[]
    itemId?: IntFilter<"ItemSpell"> | number
    spellId?: IntFilter<"ItemSpell"> | number
    Item?: XOR<ItemRelationFilter, ItemWhereInput>
    Spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id">

  export type ItemSpellOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    spellId?: SortOrder
    _count?: ItemSpellCountOrderByAggregateInput
    _avg?: ItemSpellAvgOrderByAggregateInput
    _max?: ItemSpellMaxOrderByAggregateInput
    _min?: ItemSpellMinOrderByAggregateInput
    _sum?: ItemSpellSumOrderByAggregateInput
  }

  export type ItemSpellScalarWhereWithAggregatesInput = {
    AND?: ItemSpellScalarWhereWithAggregatesInput | ItemSpellScalarWhereWithAggregatesInput[]
    OR?: ItemSpellScalarWhereWithAggregatesInput[]
    NOT?: ItemSpellScalarWhereWithAggregatesInput | ItemSpellScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemSpell"> | number
    itemId?: IntWithAggregatesFilter<"ItemSpell"> | number
    spellId?: IntWithAggregatesFilter<"ItemSpell"> | number
  }

  export type SpellWhereInput = {
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    id?: IntFilter<"Spell"> | number
    createdDate?: DateTimeFilter<"Spell"> | Date | string
    createdBy?: IntFilter<"Spell"> | number
    modifiedDate?: DateTimeFilter<"Spell"> | Date | string
    modifiedBy?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    description?: StringNullableFilter<"Spell"> | string | null
    notes?: StringNullableFilter<"Spell"> | string | null
    words?: StringNullableFilter<"Spell"> | string | null
    levelRequirement?: IntNullableFilter<"Spell"> | number | null
    ItemSpell?: ItemSpellListRelationFilter
    CreatedSpells?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedSpells?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }

  export type SpellOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    words?: SortOrderInput | SortOrder
    levelRequirement?: SortOrderInput | SortOrder
    ItemSpell?: ItemSpellOrderByRelationAggregateInput
    CreatedSpells?: AccountOrderByWithRelationInput
    ModifiedSpells?: AccountOrderByWithRelationInput
    StatModifer?: StatModiferOrderByWithRelationInput
  }

  export type SpellWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    createdDate?: DateTimeFilter<"Spell"> | Date | string
    createdBy?: IntFilter<"Spell"> | number
    modifiedDate?: DateTimeFilter<"Spell"> | Date | string
    modifiedBy?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    description?: StringNullableFilter<"Spell"> | string | null
    notes?: StringNullableFilter<"Spell"> | string | null
    words?: StringNullableFilter<"Spell"> | string | null
    levelRequirement?: IntNullableFilter<"Spell"> | number | null
    ItemSpell?: ItemSpellListRelationFilter
    CreatedSpells?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedSpells?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }, "id">

  export type SpellOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    words?: SortOrderInput | SortOrder
    levelRequirement?: SortOrderInput | SortOrder
    _count?: SpellCountOrderByAggregateInput
    _avg?: SpellAvgOrderByAggregateInput
    _max?: SpellMaxOrderByAggregateInput
    _min?: SpellMinOrderByAggregateInput
    _sum?: SpellSumOrderByAggregateInput
  }

  export type SpellScalarWhereWithAggregatesInput = {
    AND?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    OR?: SpellScalarWhereWithAggregatesInput[]
    NOT?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Spell"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Spell"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Spell"> | number
    modifiedDate?: DateTimeWithAggregatesFilter<"Spell"> | Date | string
    modifiedBy?: IntWithAggregatesFilter<"Spell"> | number
    name?: StringWithAggregatesFilter<"Spell"> | string
    description?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    words?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    levelRequirement?: IntNullableWithAggregatesFilter<"Spell"> | number | null
  }

  export type PotionWhereInput = {
    AND?: PotionWhereInput | PotionWhereInput[]
    OR?: PotionWhereInput[]
    NOT?: PotionWhereInput | PotionWhereInput[]
    id?: IntFilter<"Potion"> | number
    createdDate?: DateTimeFilter<"Potion"> | Date | string
    createdBy?: IntFilter<"Potion"> | number
    modifiedDate?: DateTimeFilter<"Potion"> | Date | string
    modifiedBy?: IntFilter<"Potion"> | number
    name?: StringFilter<"Potion"> | string
    description?: StringNullableFilter<"Potion"> | string | null
    notes?: StringNullableFilter<"Potion"> | string | null
    duration?: IntNullableFilter<"Potion"> | number | null
    CreatedPotions?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedPotions?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }

  export type PotionOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    CreatedPotions?: AccountOrderByWithRelationInput
    ModifiedPotions?: AccountOrderByWithRelationInput
    StatModifer?: StatModiferOrderByWithRelationInput
  }

  export type PotionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PotionWhereInput | PotionWhereInput[]
    OR?: PotionWhereInput[]
    NOT?: PotionWhereInput | PotionWhereInput[]
    createdDate?: DateTimeFilter<"Potion"> | Date | string
    createdBy?: IntFilter<"Potion"> | number
    modifiedDate?: DateTimeFilter<"Potion"> | Date | string
    modifiedBy?: IntFilter<"Potion"> | number
    name?: StringFilter<"Potion"> | string
    description?: StringNullableFilter<"Potion"> | string | null
    notes?: StringNullableFilter<"Potion"> | string | null
    duration?: IntNullableFilter<"Potion"> | number | null
    CreatedPotions?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedPotions?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }, "id">

  export type PotionOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    _count?: PotionCountOrderByAggregateInput
    _avg?: PotionAvgOrderByAggregateInput
    _max?: PotionMaxOrderByAggregateInput
    _min?: PotionMinOrderByAggregateInput
    _sum?: PotionSumOrderByAggregateInput
  }

  export type PotionScalarWhereWithAggregatesInput = {
    AND?: PotionScalarWhereWithAggregatesInput | PotionScalarWhereWithAggregatesInput[]
    OR?: PotionScalarWhereWithAggregatesInput[]
    NOT?: PotionScalarWhereWithAggregatesInput | PotionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Potion"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Potion"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Potion"> | number
    modifiedDate?: DateTimeWithAggregatesFilter<"Potion"> | Date | string
    modifiedBy?: IntWithAggregatesFilter<"Potion"> | number
    name?: StringWithAggregatesFilter<"Potion"> | string
    description?: StringNullableWithAggregatesFilter<"Potion"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Potion"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Potion"> | number | null
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: IntFilter<"Skill"> | number
    createdDate?: DateTimeFilter<"Skill"> | Date | string
    createdBy?: IntFilter<"Skill"> | number
    modifiedDate?: DateTimeFilter<"Skill"> | Date | string
    modifiedBy?: IntFilter<"Skill"> | number
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    notes?: StringNullableFilter<"Skill"> | string | null
    trainable?: BoolNullableFilter<"Skill"> | boolean | null
    levelRequirement?: IntFilter<"Skill"> | number
    CreatedSkills?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedSkills?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    trainable?: SortOrderInput | SortOrder
    levelRequirement?: SortOrder
    CreatedSkills?: AccountOrderByWithRelationInput
    ModifiedSkills?: AccountOrderByWithRelationInput
    StatModifer?: StatModiferOrderByWithRelationInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    createdDate?: DateTimeFilter<"Skill"> | Date | string
    createdBy?: IntFilter<"Skill"> | number
    modifiedDate?: DateTimeFilter<"Skill"> | Date | string
    modifiedBy?: IntFilter<"Skill"> | number
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    notes?: StringNullableFilter<"Skill"> | string | null
    trainable?: BoolNullableFilter<"Skill"> | boolean | null
    levelRequirement?: IntFilter<"Skill"> | number
    CreatedSkills?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedSkills?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }, "id">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    trainable?: SortOrderInput | SortOrder
    levelRequirement?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skill"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Skill"> | number
    modifiedDate?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    modifiedBy?: IntWithAggregatesFilter<"Skill"> | number
    name?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    trainable?: BoolNullableWithAggregatesFilter<"Skill"> | boolean | null
    levelRequirement?: IntWithAggregatesFilter<"Skill"> | number
  }

  export type AbilityWhereInput = {
    AND?: AbilityWhereInput | AbilityWhereInput[]
    OR?: AbilityWhereInput[]
    NOT?: AbilityWhereInput | AbilityWhereInput[]
    id?: IntFilter<"Ability"> | number
    createdDate?: DateTimeFilter<"Ability"> | Date | string
    createdBy?: IntFilter<"Ability"> | number
    modifiedDate?: DateTimeFilter<"Ability"> | Date | string
    modifiedBy?: IntFilter<"Ability"> | number
    name?: StringFilter<"Ability"> | string
    description?: StringNullableFilter<"Ability"> | string | null
    notes?: StringNullableFilter<"Ability"> | string | null
    firstRankPoints?: IntNullableFilter<"Ability"> | number | null
    secondRankPoints?: IntNullableFilter<"Ability"> | number | null
    thirdRankPoints?: IntNullableFilter<"Ability"> | number | null
    fourthRankPoints?: IntNullableFilter<"Ability"> | number | null
    fifthRankPoints?: IntNullableFilter<"Ability"> | number | null
    sixthRankPoints?: IntNullableFilter<"Ability"> | number | null
    CreatedAbilities?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedAbilities?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }

  export type AbilityOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    firstRankPoints?: SortOrderInput | SortOrder
    secondRankPoints?: SortOrderInput | SortOrder
    thirdRankPoints?: SortOrderInput | SortOrder
    fourthRankPoints?: SortOrderInput | SortOrder
    fifthRankPoints?: SortOrderInput | SortOrder
    sixthRankPoints?: SortOrderInput | SortOrder
    CreatedAbilities?: AccountOrderByWithRelationInput
    ModifiedAbilities?: AccountOrderByWithRelationInput
    StatModifer?: StatModiferOrderByWithRelationInput
  }

  export type AbilityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AbilityWhereInput | AbilityWhereInput[]
    OR?: AbilityWhereInput[]
    NOT?: AbilityWhereInput | AbilityWhereInput[]
    createdDate?: DateTimeFilter<"Ability"> | Date | string
    createdBy?: IntFilter<"Ability"> | number
    modifiedDate?: DateTimeFilter<"Ability"> | Date | string
    modifiedBy?: IntFilter<"Ability"> | number
    name?: StringFilter<"Ability"> | string
    description?: StringNullableFilter<"Ability"> | string | null
    notes?: StringNullableFilter<"Ability"> | string | null
    firstRankPoints?: IntNullableFilter<"Ability"> | number | null
    secondRankPoints?: IntNullableFilter<"Ability"> | number | null
    thirdRankPoints?: IntNullableFilter<"Ability"> | number | null
    fourthRankPoints?: IntNullableFilter<"Ability"> | number | null
    fifthRankPoints?: IntNullableFilter<"Ability"> | number | null
    sixthRankPoints?: IntNullableFilter<"Ability"> | number | null
    CreatedAbilities?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedAbilities?: XOR<AccountRelationFilter, AccountWhereInput>
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
  }, "id">

  export type AbilityOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    firstRankPoints?: SortOrderInput | SortOrder
    secondRankPoints?: SortOrderInput | SortOrder
    thirdRankPoints?: SortOrderInput | SortOrder
    fourthRankPoints?: SortOrderInput | SortOrder
    fifthRankPoints?: SortOrderInput | SortOrder
    sixthRankPoints?: SortOrderInput | SortOrder
    _count?: AbilityCountOrderByAggregateInput
    _avg?: AbilityAvgOrderByAggregateInput
    _max?: AbilityMaxOrderByAggregateInput
    _min?: AbilityMinOrderByAggregateInput
    _sum?: AbilitySumOrderByAggregateInput
  }

  export type AbilityScalarWhereWithAggregatesInput = {
    AND?: AbilityScalarWhereWithAggregatesInput | AbilityScalarWhereWithAggregatesInput[]
    OR?: AbilityScalarWhereWithAggregatesInput[]
    NOT?: AbilityScalarWhereWithAggregatesInput | AbilityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ability"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Ability"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Ability"> | number
    modifiedDate?: DateTimeWithAggregatesFilter<"Ability"> | Date | string
    modifiedBy?: IntWithAggregatesFilter<"Ability"> | number
    name?: StringWithAggregatesFilter<"Ability"> | string
    description?: StringNullableWithAggregatesFilter<"Ability"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Ability"> | string | null
    firstRankPoints?: IntNullableWithAggregatesFilter<"Ability"> | number | null
    secondRankPoints?: IntNullableWithAggregatesFilter<"Ability"> | number | null
    thirdRankPoints?: IntNullableWithAggregatesFilter<"Ability"> | number | null
    fourthRankPoints?: IntNullableWithAggregatesFilter<"Ability"> | number | null
    fifthRankPoints?: IntNullableWithAggregatesFilter<"Ability"> | number | null
    sixthRankPoints?: IntNullableWithAggregatesFilter<"Ability"> | number | null
  }

  export type QuestWhereInput = {
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    id?: IntFilter<"Quest"> | number
    createdDate?: DateTimeFilter<"Quest"> | Date | string
    createdBy?: IntFilter<"Quest"> | number
    modifiedDate?: DateTimeFilter<"Quest"> | Date | string
    modifiedBy?: IntFilter<"Quest"> | number
    name?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    notes?: StringNullableFilter<"Quest"> | string | null
    whoises?: StringNullableFilter<"Quest"> | string | null
    pretitles?: StringNullableFilter<"Quest"> | string | null
    post_titles?: StringNullableFilter<"Quest"> | string | null
    experience?: IntNullableFilter<"Quest"> | number | null
    CreatedQuests?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedQuests?: XOR<AccountRelationFilter, AccountWhereInput>
    CharacterQuest?: CharacterQuestListRelationFilter
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
    QuestTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
  }

  export type QuestOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    whoises?: SortOrderInput | SortOrder
    pretitles?: SortOrderInput | SortOrder
    post_titles?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    CreatedQuests?: AccountOrderByWithRelationInput
    ModifiedQuests?: AccountOrderByWithRelationInput
    CharacterQuest?: CharacterQuestOrderByRelationAggregateInput
    StatModifer?: StatModiferOrderByWithRelationInput
    QuestTagSource?: AppliedTagOrderByWithRelationInput
  }

  export type QuestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    createdDate?: DateTimeFilter<"Quest"> | Date | string
    createdBy?: IntFilter<"Quest"> | number
    modifiedDate?: DateTimeFilter<"Quest"> | Date | string
    modifiedBy?: IntFilter<"Quest"> | number
    name?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    notes?: StringNullableFilter<"Quest"> | string | null
    whoises?: StringNullableFilter<"Quest"> | string | null
    pretitles?: StringNullableFilter<"Quest"> | string | null
    post_titles?: StringNullableFilter<"Quest"> | string | null
    experience?: IntNullableFilter<"Quest"> | number | null
    CreatedQuests?: XOR<AccountRelationFilter, AccountWhereInput>
    ModifiedQuests?: XOR<AccountRelationFilter, AccountWhereInput>
    CharacterQuest?: CharacterQuestListRelationFilter
    StatModifer?: XOR<StatModiferNullableRelationFilter, StatModiferWhereInput> | null
    QuestTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
  }, "id">

  export type QuestOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    whoises?: SortOrderInput | SortOrder
    pretitles?: SortOrderInput | SortOrder
    post_titles?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    _count?: QuestCountOrderByAggregateInput
    _avg?: QuestAvgOrderByAggregateInput
    _max?: QuestMaxOrderByAggregateInput
    _min?: QuestMinOrderByAggregateInput
    _sum?: QuestSumOrderByAggregateInput
  }

  export type QuestScalarWhereWithAggregatesInput = {
    AND?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    OR?: QuestScalarWhereWithAggregatesInput[]
    NOT?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quest"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Quest"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Quest"> | number
    modifiedDate?: DateTimeWithAggregatesFilter<"Quest"> | Date | string
    modifiedBy?: IntWithAggregatesFilter<"Quest"> | number
    name?: StringWithAggregatesFilter<"Quest"> | string
    description?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    whoises?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    pretitles?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    post_titles?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    experience?: IntNullableWithAggregatesFilter<"Quest"> | number | null
  }

  export type StatModiferWhereInput = {
    AND?: StatModiferWhereInput | StatModiferWhereInput[]
    OR?: StatModiferWhereInput[]
    NOT?: StatModiferWhereInput | StatModiferWhereInput[]
    id?: IntFilter<"StatModifer"> | number
    type?: EnumStatModifierTypeFilter<"StatModifer"> | $Enums.StatModifierType
    sourceId?: IntFilter<"StatModifer"> | number
    hp?: IntNullableFilter<"StatModifer"> | number | null
    mv?: IntNullableFilter<"StatModifer"> | number | null
    ma?: IntNullableFilter<"StatModifer"> | number | null
    ac?: IntNullableFilter<"StatModifer"> | number | null
    str?: IntNullableFilter<"StatModifer"> | number | null
    min?: IntNullableFilter<"StatModifer"> | number | null
    dex?: IntNullableFilter<"StatModifer"> | number | null
    con?: IntNullableFilter<"StatModifer"> | number | null
    per?: IntNullableFilter<"StatModifer"> | number | null
    spi?: IntNullableFilter<"StatModifer"> | number | null
    hpRegen?: IntNullableFilter<"StatModifer"> | number | null
    mvRegen?: IntNullableFilter<"StatModifer"> | number | null
    maRegen?: IntNullableFilter<"StatModifer"> | number | null
    damroll?: IntNullableFilter<"StatModifer"> | number | null
    hitroll?: IntNullableFilter<"StatModifer"> | number | null
    mitigation?: IntNullableFilter<"StatModifer"> | number | null
    spellDam?: IntNullableFilter<"StatModifer"> | number | null
    spellCrit?: IntNullableFilter<"StatModifer"> | number | null
    spellRedux?: IntNullableFilter<"StatModifer"> | number | null
    concentration?: IntNullableFilter<"StatModifer"> | number | null
    shotAccuracy?: IntNullableFilter<"StatModifer"> | number | null
    bonusAccuracy?: IntNullableFilter<"StatModifer"> | number | null
    ammoCapacity?: IntNullableFilter<"StatModifer"> | number | null
    parry?: IntNullableFilter<"StatModifer"> | number | null
    strCap?: IntNullableFilter<"StatModifer"> | number | null
    minCap?: IntNullableFilter<"StatModifer"> | number | null
    dexCap?: IntNullableFilter<"StatModifer"> | number | null
    conCap?: IntNullableFilter<"StatModifer"> | number | null
    perCap?: IntNullableFilter<"StatModifer"> | number | null
    spiCap?: IntNullableFilter<"StatModifer"> | number | null
    ItemSource?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
    QuestSource?: XOR<QuestNullableRelationFilter, QuestWhereInput> | null
    AbilitySource?: XOR<AbilityNullableRelationFilter, AbilityWhereInput> | null
    SkillSource?: XOR<SkillNullableRelationFilter, SkillWhereInput> | null
    SpellSource?: XOR<SpellNullableRelationFilter, SpellWhereInput> | null
    PotionSource?: XOR<PotionNullableRelationFilter, PotionWhereInput> | null
  }

  export type StatModiferOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    sourceId?: SortOrder
    hp?: SortOrderInput | SortOrder
    mv?: SortOrderInput | SortOrder
    ma?: SortOrderInput | SortOrder
    ac?: SortOrderInput | SortOrder
    str?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    dex?: SortOrderInput | SortOrder
    con?: SortOrderInput | SortOrder
    per?: SortOrderInput | SortOrder
    spi?: SortOrderInput | SortOrder
    hpRegen?: SortOrderInput | SortOrder
    mvRegen?: SortOrderInput | SortOrder
    maRegen?: SortOrderInput | SortOrder
    damroll?: SortOrderInput | SortOrder
    hitroll?: SortOrderInput | SortOrder
    mitigation?: SortOrderInput | SortOrder
    spellDam?: SortOrderInput | SortOrder
    spellCrit?: SortOrderInput | SortOrder
    spellRedux?: SortOrderInput | SortOrder
    concentration?: SortOrderInput | SortOrder
    shotAccuracy?: SortOrderInput | SortOrder
    bonusAccuracy?: SortOrderInput | SortOrder
    ammoCapacity?: SortOrderInput | SortOrder
    parry?: SortOrderInput | SortOrder
    strCap?: SortOrderInput | SortOrder
    minCap?: SortOrderInput | SortOrder
    dexCap?: SortOrderInput | SortOrder
    conCap?: SortOrderInput | SortOrder
    perCap?: SortOrderInput | SortOrder
    spiCap?: SortOrderInput | SortOrder
    ItemSource?: ItemOrderByWithRelationInput
    QuestSource?: QuestOrderByWithRelationInput
    AbilitySource?: AbilityOrderByWithRelationInput
    SkillSource?: SkillOrderByWithRelationInput
    SpellSource?: SpellOrderByWithRelationInput
    PotionSource?: PotionOrderByWithRelationInput
  }

  export type StatModiferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type?: $Enums.StatModifierType
    sourceId?: number
    AND?: StatModiferWhereInput | StatModiferWhereInput[]
    OR?: StatModiferWhereInput[]
    NOT?: StatModiferWhereInput | StatModiferWhereInput[]
    hp?: IntNullableFilter<"StatModifer"> | number | null
    mv?: IntNullableFilter<"StatModifer"> | number | null
    ma?: IntNullableFilter<"StatModifer"> | number | null
    ac?: IntNullableFilter<"StatModifer"> | number | null
    str?: IntNullableFilter<"StatModifer"> | number | null
    min?: IntNullableFilter<"StatModifer"> | number | null
    dex?: IntNullableFilter<"StatModifer"> | number | null
    con?: IntNullableFilter<"StatModifer"> | number | null
    per?: IntNullableFilter<"StatModifer"> | number | null
    spi?: IntNullableFilter<"StatModifer"> | number | null
    hpRegen?: IntNullableFilter<"StatModifer"> | number | null
    mvRegen?: IntNullableFilter<"StatModifer"> | number | null
    maRegen?: IntNullableFilter<"StatModifer"> | number | null
    damroll?: IntNullableFilter<"StatModifer"> | number | null
    hitroll?: IntNullableFilter<"StatModifer"> | number | null
    mitigation?: IntNullableFilter<"StatModifer"> | number | null
    spellDam?: IntNullableFilter<"StatModifer"> | number | null
    spellCrit?: IntNullableFilter<"StatModifer"> | number | null
    spellRedux?: IntNullableFilter<"StatModifer"> | number | null
    concentration?: IntNullableFilter<"StatModifer"> | number | null
    shotAccuracy?: IntNullableFilter<"StatModifer"> | number | null
    bonusAccuracy?: IntNullableFilter<"StatModifer"> | number | null
    ammoCapacity?: IntNullableFilter<"StatModifer"> | number | null
    parry?: IntNullableFilter<"StatModifer"> | number | null
    strCap?: IntNullableFilter<"StatModifer"> | number | null
    minCap?: IntNullableFilter<"StatModifer"> | number | null
    dexCap?: IntNullableFilter<"StatModifer"> | number | null
    conCap?: IntNullableFilter<"StatModifer"> | number | null
    perCap?: IntNullableFilter<"StatModifer"> | number | null
    spiCap?: IntNullableFilter<"StatModifer"> | number | null
    ItemSource?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
    QuestSource?: XOR<QuestNullableRelationFilter, QuestWhereInput> | null
    AbilitySource?: XOR<AbilityNullableRelationFilter, AbilityWhereInput> | null
    SkillSource?: XOR<SkillNullableRelationFilter, SkillWhereInput> | null
    SpellSource?: XOR<SpellNullableRelationFilter, SpellWhereInput> | null
    PotionSource?: XOR<PotionNullableRelationFilter, PotionWhereInput> | null
  }, "id" | "type" | "sourceId">

  export type StatModiferOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    sourceId?: SortOrder
    hp?: SortOrderInput | SortOrder
    mv?: SortOrderInput | SortOrder
    ma?: SortOrderInput | SortOrder
    ac?: SortOrderInput | SortOrder
    str?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    dex?: SortOrderInput | SortOrder
    con?: SortOrderInput | SortOrder
    per?: SortOrderInput | SortOrder
    spi?: SortOrderInput | SortOrder
    hpRegen?: SortOrderInput | SortOrder
    mvRegen?: SortOrderInput | SortOrder
    maRegen?: SortOrderInput | SortOrder
    damroll?: SortOrderInput | SortOrder
    hitroll?: SortOrderInput | SortOrder
    mitigation?: SortOrderInput | SortOrder
    spellDam?: SortOrderInput | SortOrder
    spellCrit?: SortOrderInput | SortOrder
    spellRedux?: SortOrderInput | SortOrder
    concentration?: SortOrderInput | SortOrder
    shotAccuracy?: SortOrderInput | SortOrder
    bonusAccuracy?: SortOrderInput | SortOrder
    ammoCapacity?: SortOrderInput | SortOrder
    parry?: SortOrderInput | SortOrder
    strCap?: SortOrderInput | SortOrder
    minCap?: SortOrderInput | SortOrder
    dexCap?: SortOrderInput | SortOrder
    conCap?: SortOrderInput | SortOrder
    perCap?: SortOrderInput | SortOrder
    spiCap?: SortOrderInput | SortOrder
    _count?: StatModiferCountOrderByAggregateInput
    _avg?: StatModiferAvgOrderByAggregateInput
    _max?: StatModiferMaxOrderByAggregateInput
    _min?: StatModiferMinOrderByAggregateInput
    _sum?: StatModiferSumOrderByAggregateInput
  }

  export type StatModiferScalarWhereWithAggregatesInput = {
    AND?: StatModiferScalarWhereWithAggregatesInput | StatModiferScalarWhereWithAggregatesInput[]
    OR?: StatModiferScalarWhereWithAggregatesInput[]
    NOT?: StatModiferScalarWhereWithAggregatesInput | StatModiferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StatModifer"> | number
    type?: EnumStatModifierTypeWithAggregatesFilter<"StatModifer"> | $Enums.StatModifierType
    sourceId?: IntWithAggregatesFilter<"StatModifer"> | number
    hp?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    mv?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    ma?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    ac?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    str?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    min?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    dex?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    con?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    per?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    spi?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    hpRegen?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    mvRegen?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    maRegen?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    damroll?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    hitroll?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    mitigation?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    spellDam?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    spellCrit?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    spellRedux?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    concentration?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    shotAccuracy?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    bonusAccuracy?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    ammoCapacity?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    parry?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    strCap?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    minCap?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    dexCap?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    conCap?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    perCap?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
    spiCap?: IntNullableWithAggregatesFilter<"StatModifer"> | number | null
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: IntFilter<"Article"> | number
    createdDate?: DateTimeFilter<"Article"> | Date | string
    authorId?: IntFilter<"Article"> | number
    isProtected?: BoolFilter<"Article"> | boolean
    Author?: XOR<AccountRelationFilter, AccountWhereInput>
    ArticleContent?: ArticleVersionListRelationFilter
    ArticleTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    authorId?: SortOrder
    isProtected?: SortOrder
    Author?: AccountOrderByWithRelationInput
    ArticleContent?: ArticleVersionOrderByRelationAggregateInput
    ArticleTagSource?: AppliedTagOrderByWithRelationInput
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    createdDate?: DateTimeFilter<"Article"> | Date | string
    authorId?: IntFilter<"Article"> | number
    isProtected?: BoolFilter<"Article"> | boolean
    Author?: XOR<AccountRelationFilter, AccountWhereInput>
    ArticleContent?: ArticleVersionListRelationFilter
    ArticleTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
  }, "id">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    authorId?: SortOrder
    isProtected?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Article"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    authorId?: IntWithAggregatesFilter<"Article"> | number
    isProtected?: BoolWithAggregatesFilter<"Article"> | boolean
  }

  export type ArticleVersionWhereInput = {
    AND?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    OR?: ArticleVersionWhereInput[]
    NOT?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    id?: IntFilter<"ArticleVersion"> | number
    articleId?: IntFilter<"ArticleVersion"> | number
    modifiedDate?: DateTimeFilter<"ArticleVersion"> | Date | string
    editorId?: IntFilter<"ArticleVersion"> | number
    content?: StringFilter<"ArticleVersion"> | string
    isCurrent?: BoolFilter<"ArticleVersion"> | boolean
    version?: StringNullableFilter<"ArticleVersion"> | string | null
    Editor?: XOR<AccountRelationFilter, AccountWhereInput>
    Article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type ArticleVersionOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    modifiedDate?: SortOrder
    editorId?: SortOrder
    content?: SortOrder
    isCurrent?: SortOrder
    version?: SortOrderInput | SortOrder
    Editor?: AccountOrderByWithRelationInput
    Article?: ArticleOrderByWithRelationInput
  }

  export type ArticleVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    OR?: ArticleVersionWhereInput[]
    NOT?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    articleId?: IntFilter<"ArticleVersion"> | number
    modifiedDate?: DateTimeFilter<"ArticleVersion"> | Date | string
    editorId?: IntFilter<"ArticleVersion"> | number
    content?: StringFilter<"ArticleVersion"> | string
    isCurrent?: BoolFilter<"ArticleVersion"> | boolean
    version?: StringNullableFilter<"ArticleVersion"> | string | null
    Editor?: XOR<AccountRelationFilter, AccountWhereInput>
    Article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }, "id">

  export type ArticleVersionOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    modifiedDate?: SortOrder
    editorId?: SortOrder
    content?: SortOrder
    isCurrent?: SortOrder
    version?: SortOrderInput | SortOrder
    _count?: ArticleVersionCountOrderByAggregateInput
    _avg?: ArticleVersionAvgOrderByAggregateInput
    _max?: ArticleVersionMaxOrderByAggregateInput
    _min?: ArticleVersionMinOrderByAggregateInput
    _sum?: ArticleVersionSumOrderByAggregateInput
  }

  export type ArticleVersionScalarWhereWithAggregatesInput = {
    AND?: ArticleVersionScalarWhereWithAggregatesInput | ArticleVersionScalarWhereWithAggregatesInput[]
    OR?: ArticleVersionScalarWhereWithAggregatesInput[]
    NOT?: ArticleVersionScalarWhereWithAggregatesInput | ArticleVersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ArticleVersion"> | number
    articleId?: IntWithAggregatesFilter<"ArticleVersion"> | number
    modifiedDate?: DateTimeWithAggregatesFilter<"ArticleVersion"> | Date | string
    editorId?: IntWithAggregatesFilter<"ArticleVersion"> | number
    content?: StringWithAggregatesFilter<"ArticleVersion"> | string
    isCurrent?: BoolWithAggregatesFilter<"ArticleVersion"> | boolean
    version?: StringNullableWithAggregatesFilter<"ArticleVersion"> | string | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    createdDate?: DateTimeFilter<"Tag"> | Date | string
    createdBy?: IntFilter<"Tag"> | number
    tag?: StringFilter<"Tag"> | string
    Creator?: XOR<AccountRelationFilter, AccountWhereInput>
    AppliedTag?: AppliedTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    tag?: SortOrder
    Creator?: AccountOrderByWithRelationInput
    AppliedTag?: AppliedTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    createdDate?: DateTimeFilter<"Tag"> | Date | string
    createdBy?: IntFilter<"Tag"> | number
    tag?: StringFilter<"Tag"> | string
    Creator?: XOR<AccountRelationFilter, AccountWhereInput>
    AppliedTag?: AppliedTagListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    tag?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    createdDate?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    createdBy?: IntWithAggregatesFilter<"Tag"> | number
    tag?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type AppliedTagWhereInput = {
    AND?: AppliedTagWhereInput | AppliedTagWhereInput[]
    OR?: AppliedTagWhereInput[]
    NOT?: AppliedTagWhereInput | AppliedTagWhereInput[]
    id?: IntFilter<"AppliedTag"> | number
    typeId?: EnumTagTypeFilter<"AppliedTag"> | $Enums.TagType
    sourceId?: IntNullableFilter<"AppliedTag"> | number | null
    tagId?: IntFilter<"AppliedTag"> | number
    Tag?: XOR<TagRelationFilter, TagWhereInput>
    ArticleTagSource?: XOR<ArticleNullableRelationFilter, ArticleWhereInput> | null
    ItemTagSource?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
    MobTagSource?: XOR<MobNullableRelationFilter, MobWhereInput> | null
    QuestTagSource?: XOR<QuestNullableRelationFilter, QuestWhereInput> | null
  }

  export type AppliedTagOrderByWithRelationInput = {
    id?: SortOrder
    typeId?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    tagId?: SortOrder
    Tag?: TagOrderByWithRelationInput
    ArticleTagSource?: ArticleOrderByWithRelationInput
    ItemTagSource?: ItemOrderByWithRelationInput
    MobTagSource?: MobOrderByWithRelationInput
    QuestTagSource?: QuestOrderByWithRelationInput
  }

  export type AppliedTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sourceId?: number
    AND?: AppliedTagWhereInput | AppliedTagWhereInput[]
    OR?: AppliedTagWhereInput[]
    NOT?: AppliedTagWhereInput | AppliedTagWhereInput[]
    typeId?: EnumTagTypeFilter<"AppliedTag"> | $Enums.TagType
    tagId?: IntFilter<"AppliedTag"> | number
    Tag?: XOR<TagRelationFilter, TagWhereInput>
    ArticleTagSource?: XOR<ArticleNullableRelationFilter, ArticleWhereInput> | null
    ItemTagSource?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
    MobTagSource?: XOR<MobNullableRelationFilter, MobWhereInput> | null
    QuestTagSource?: XOR<QuestNullableRelationFilter, QuestWhereInput> | null
  }, "id" | "sourceId">

  export type AppliedTagOrderByWithAggregationInput = {
    id?: SortOrder
    typeId?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    tagId?: SortOrder
    _count?: AppliedTagCountOrderByAggregateInput
    _avg?: AppliedTagAvgOrderByAggregateInput
    _max?: AppliedTagMaxOrderByAggregateInput
    _min?: AppliedTagMinOrderByAggregateInput
    _sum?: AppliedTagSumOrderByAggregateInput
  }

  export type AppliedTagScalarWhereWithAggregatesInput = {
    AND?: AppliedTagScalarWhereWithAggregatesInput | AppliedTagScalarWhereWithAggregatesInput[]
    OR?: AppliedTagScalarWhereWithAggregatesInput[]
    NOT?: AppliedTagScalarWhereWithAggregatesInput | AppliedTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppliedTag"> | number
    typeId?: EnumTagTypeWithAggregatesFilter<"AppliedTag"> | $Enums.TagType
    sourceId?: IntNullableWithAggregatesFilter<"AppliedTag"> | number | null
    tagId?: IntWithAggregatesFilter<"AppliedTag"> | number
  }

  export type MobWhereInput = {
    AND?: MobWhereInput | MobWhereInput[]
    OR?: MobWhereInput[]
    NOT?: MobWhereInput | MobWhereInput[]
    id?: IntFilter<"Mob"> | number
    mudId?: IntNullableFilter<"Mob"> | number | null
    areaId?: IntNullableFilter<"Mob"> | number | null
    shortDescription?: StringFilter<"Mob"> | string
    longDescription?: StringNullableFilter<"Mob"> | string | null
    level?: IntNullableFilter<"Mob"> | number | null
    isAggressive?: BoolFilter<"Mob"> | boolean
    experience?: IntNullableFilter<"Mob"> | number | null
    gold?: IntNullableFilter<"Mob"> | number | null
    MobTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
    Area?: XOR<AreaNullableRelationFilter, AreaWhereInput> | null
  }

  export type MobOrderByWithRelationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    isAggressive?: SortOrder
    experience?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    MobTagSource?: AppliedTagOrderByWithRelationInput
    Area?: AreaOrderByWithRelationInput
  }

  export type MobWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MobWhereInput | MobWhereInput[]
    OR?: MobWhereInput[]
    NOT?: MobWhereInput | MobWhereInput[]
    mudId?: IntNullableFilter<"Mob"> | number | null
    areaId?: IntNullableFilter<"Mob"> | number | null
    shortDescription?: StringFilter<"Mob"> | string
    longDescription?: StringNullableFilter<"Mob"> | string | null
    level?: IntNullableFilter<"Mob"> | number | null
    isAggressive?: BoolFilter<"Mob"> | boolean
    experience?: IntNullableFilter<"Mob"> | number | null
    gold?: IntNullableFilter<"Mob"> | number | null
    MobTagSource?: XOR<AppliedTagNullableRelationFilter, AppliedTagWhereInput> | null
    Area?: XOR<AreaNullableRelationFilter, AreaWhereInput> | null
  }, "id">

  export type MobOrderByWithAggregationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    isAggressive?: SortOrder
    experience?: SortOrderInput | SortOrder
    gold?: SortOrderInput | SortOrder
    _count?: MobCountOrderByAggregateInput
    _avg?: MobAvgOrderByAggregateInput
    _max?: MobMaxOrderByAggregateInput
    _min?: MobMinOrderByAggregateInput
    _sum?: MobSumOrderByAggregateInput
  }

  export type MobScalarWhereWithAggregatesInput = {
    AND?: MobScalarWhereWithAggregatesInput | MobScalarWhereWithAggregatesInput[]
    OR?: MobScalarWhereWithAggregatesInput[]
    NOT?: MobScalarWhereWithAggregatesInput | MobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mob"> | number
    mudId?: IntNullableWithAggregatesFilter<"Mob"> | number | null
    areaId?: IntNullableWithAggregatesFilter<"Mob"> | number | null
    shortDescription?: StringWithAggregatesFilter<"Mob"> | string
    longDescription?: StringNullableWithAggregatesFilter<"Mob"> | string | null
    level?: IntNullableWithAggregatesFilter<"Mob"> | number | null
    isAggressive?: BoolWithAggregatesFilter<"Mob"> | boolean
    experience?: IntNullableWithAggregatesFilter<"Mob"> | number | null
    gold?: IntNullableWithAggregatesFilter<"Mob"> | number | null
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: IntFilter<"Area"> | number
    mudId?: IntNullableFilter<"Area"> | number | null
    name?: StringFilter<"Area"> | string
    authorId?: IntNullableFilter<"Area"> | number | null
    releaseDate?: DateTimeNullableFilter<"Area"> | Date | string | null
    Author?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    Mob?: MobListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    name?: SortOrder
    authorId?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    Author?: AccountOrderByWithRelationInput
    Mob?: MobOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    mudId?: IntNullableFilter<"Area"> | number | null
    name?: StringFilter<"Area"> | string
    authorId?: IntNullableFilter<"Area"> | number | null
    releaseDate?: DateTimeNullableFilter<"Area"> | Date | string | null
    Author?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    Mob?: MobListRelationFilter
  }, "id">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    mudId?: SortOrderInput | SortOrder
    name?: SortOrder
    authorId?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    _count?: AreaCountOrderByAggregateInput
    _avg?: AreaAvgOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
    _sum?: AreaSumOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Area"> | number
    mudId?: IntNullableWithAggregatesFilter<"Area"> | number | null
    name?: StringWithAggregatesFilter<"Area"> | string
    authorId?: IntNullableWithAggregatesFilter<"Area"> | number | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Area"> | Date | string | null
  }

  export type ChangeLogWhereInput = {
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    id?: IntFilter<"ChangeLog"> | number
    createdDate?: DateTimeFilter<"ChangeLog"> | Date | string
    createdBy?: IntFilter<"ChangeLog"> | number
    content?: StringNullableFilter<"ChangeLog"> | string | null
    version?: StringNullableFilter<"ChangeLog"> | string | null
    releaseDate?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    Creator?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
  }

  export type ChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    content?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    Creator?: AccountOrderByWithRelationInput
  }

  export type ChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    createdDate?: DateTimeFilter<"ChangeLog"> | Date | string
    createdBy?: IntFilter<"ChangeLog"> | number
    content?: StringNullableFilter<"ChangeLog"> | string | null
    version?: StringNullableFilter<"ChangeLog"> | string | null
    releaseDate?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    Creator?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
  }, "id">

  export type ChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    content?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    _count?: ChangeLogCountOrderByAggregateInput
    _avg?: ChangeLogAvgOrderByAggregateInput
    _max?: ChangeLogMaxOrderByAggregateInput
    _min?: ChangeLogMinOrderByAggregateInput
    _sum?: ChangeLogSumOrderByAggregateInput
  }

  export type ChangeLogScalarWhereWithAggregatesInput = {
    AND?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    OR?: ChangeLogScalarWhereWithAggregatesInput[]
    NOT?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChangeLog"> | number
    createdDate?: DateTimeWithAggregatesFilter<"ChangeLog"> | Date | string
    createdBy?: IntWithAggregatesFilter<"ChangeLog"> | number
    content?: StringNullableWithAggregatesFilter<"ChangeLog"> | string | null
    version?: StringNullableWithAggregatesFilter<"ChangeLog"> | string | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"ChangeLog"> | Date | string | null
  }

  export type AccountCreateInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountUpdateInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateManyInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AccountUpdateManyMutationInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AccountNotificationCreateInput = {
    notificationId: number
    read?: boolean | null
    readDate?: Date | string | null
    Account: AccountCreateNestedOneWithoutAccountNotificationInput
  }

  export type AccountNotificationUncheckedCreateInput = {
    id?: number
    accountId: number
    notificationId: number
    read?: boolean | null
    readDate?: Date | string | null
  }

  export type AccountNotificationUpdateInput = {
    notificationId?: IntFieldUpdateOperationsInput | number
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    readDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Account?: AccountUpdateOneRequiredWithoutAccountNotificationNestedInput
  }

  export type AccountNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    readDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountNotificationCreateManyInput = {
    id?: number
    accountId: number
    notificationId: number
    read?: boolean | null
    readDate?: Date | string | null
  }

  export type AccountNotificationUpdateManyMutationInput = {
    notificationId?: IntFieldUpdateOperationsInput | number
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    readDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    readDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountPasswordCreateInput = {
    passwordHash: string
    Account: AccountCreateNestedOneWithoutAccountPasswordInput
  }

  export type AccountPasswordUncheckedCreateInput = {
    id?: number
    accountId: number
    passwordHash: string
  }

  export type AccountPasswordUpdateInput = {
    passwordHash?: StringFieldUpdateOperationsInput | string
    Account?: AccountUpdateOneRequiredWithoutAccountPasswordNestedInput
  }

  export type AccountPasswordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type AccountPasswordCreateManyInput = {
    id?: number
    accountId: number
    passwordHash: string
  }

  export type AccountPasswordUpdateManyMutationInput = {
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type AccountPasswordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkHistoryCreateInput = {
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
    Account: AccountCreateNestedOneWithoutNetworkHistoryInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutNetworkHistoryInput
  }

  export type NetworkHistoryUncheckedCreateInput = {
    id?: number
    accountId: number
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutNetworkHistoryInput
  }

  export type NetworkHistoryUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    Account?: AccountUpdateOneRequiredWithoutNetworkHistoryNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutNetworkHistoryNestedInput
  }

  export type NetworkHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutNetworkHistoryNestedInput
  }

  export type NetworkHistoryCreateManyInput = {
    id?: number
    accountId: number
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
  }

  export type NetworkHistoryUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkBlacklistCreateInput = {
    issueDate: Date | string
    termDate: Date | string
    NetworkHistory: NetworkHistoryCreateNestedOneWithoutNetworkBlacklistInput
    Account: AccountCreateNestedOneWithoutNetworkBlacklistInput
  }

  export type NetworkBlacklistUncheckedCreateInput = {
    id?: number
    networkHistoryId: number
    issueDate: Date | string
    termDate: Date | string
    issuer: number
  }

  export type NetworkBlacklistUpdateInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
    NetworkHistory?: NetworkHistoryUpdateOneRequiredWithoutNetworkBlacklistNestedInput
    Account?: AccountUpdateOneRequiredWithoutNetworkBlacklistNestedInput
  }

  export type NetworkBlacklistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    networkHistoryId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IntFieldUpdateOperationsInput | number
  }

  export type NetworkBlacklistCreateManyInput = {
    id?: number
    networkHistoryId: number
    issueDate: Date | string
    termDate: Date | string
    issuer: number
  }

  export type NetworkBlacklistUpdateManyMutationInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkBlacklistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    networkHistoryId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    createdDate: Date | string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    content?: string | null
    Account: AccountCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    createdDate: Date | string
    createdBy: number
    type: $Enums.NotificationType
    title: string
    description?: string | null
    content?: string | null
  }

  export type NotificationUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    createdDate: Date | string
    createdBy: number
    type: $Enums.NotificationType
    title: string
    description?: string | null
    content?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterCreateInput = {
    mudId?: number | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
    Account: AccountCreateNestedOneWithoutCharacterInput
    CharacterVersion?: CharacterVersionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: number
    mudId?: number | null
    accountId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
    CharacterVersion?: CharacterVersionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    Account?: AccountUpdateOneRequiredWithoutCharacterNestedInput
    CharacterVersion?: CharacterVersionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterVersion?: CharacterVersionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: number
    mudId?: number | null
    accountId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
  }

  export type CharacterUpdateManyMutationInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterVersionCreateInput = {
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    Character: CharacterCreateNestedOneWithoutCharacterVersionInput
    CharacterStat?: CharacterStatCreateNestedOneWithoutCharacterVersionInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutCharacterVersionInput
    CharacterEquipment?: CharacterEquipmentCreateNestedOneWithoutCharacterVersionInput
  }

  export type CharacterVersionUncheckedCreateInput = {
    id?: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    characterEquipmentId?: number | null
    CharacterStat?: CharacterStatUncheckedCreateNestedOneWithoutCharacterVersionInput
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutCharacterVersionInput
  }

  export type CharacterVersionUpdateInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    Character?: CharacterUpdateOneRequiredWithoutCharacterVersionNestedInput
    CharacterStat?: CharacterStatUpdateOneWithoutCharacterVersionNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutCharacterVersionNestedInput
    CharacterEquipment?: CharacterEquipmentUpdateOneWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    characterEquipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterStat?: CharacterStatUncheckedUpdateOneWithoutCharacterVersionNestedInput
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionCreateManyInput = {
    id?: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    characterEquipmentId?: number | null
  }

  export type CharacterVersionUpdateManyMutationInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    characterEquipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterStatCreateInput = {
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    strSwap?: number | null
    minSwap?: number | null
    dexSwap?: number | null
    conSwap?: number | null
    perSwap?: number | null
    spiSwap?: number | null
    CharacterVersion: CharacterVersionCreateNestedOneWithoutCharacterStatInput
  }

  export type CharacterStatUncheckedCreateInput = {
    id?: number
    characterVersionId: number
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    strSwap?: number | null
    minSwap?: number | null
    dexSwap?: number | null
    conSwap?: number | null
    perSwap?: number | null
    spiSwap?: number | null
  }

  export type CharacterStatUpdateInput = {
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    strSwap?: NullableIntFieldUpdateOperationsInput | number | null
    minSwap?: NullableIntFieldUpdateOperationsInput | number | null
    dexSwap?: NullableIntFieldUpdateOperationsInput | number | null
    conSwap?: NullableIntFieldUpdateOperationsInput | number | null
    perSwap?: NullableIntFieldUpdateOperationsInput | number | null
    spiSwap?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterVersion?: CharacterVersionUpdateOneRequiredWithoutCharacterStatNestedInput
  }

  export type CharacterStatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterVersionId?: IntFieldUpdateOperationsInput | number
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    strSwap?: NullableIntFieldUpdateOperationsInput | number | null
    minSwap?: NullableIntFieldUpdateOperationsInput | number | null
    dexSwap?: NullableIntFieldUpdateOperationsInput | number | null
    conSwap?: NullableIntFieldUpdateOperationsInput | number | null
    perSwap?: NullableIntFieldUpdateOperationsInput | number | null
    spiSwap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterStatCreateManyInput = {
    id?: number
    characterVersionId: number
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    strSwap?: number | null
    minSwap?: number | null
    dexSwap?: number | null
    conSwap?: number | null
    perSwap?: number | null
    spiSwap?: number | null
  }

  export type CharacterStatUpdateManyMutationInput = {
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    strSwap?: NullableIntFieldUpdateOperationsInput | number | null
    minSwap?: NullableIntFieldUpdateOperationsInput | number | null
    dexSwap?: NullableIntFieldUpdateOperationsInput | number | null
    conSwap?: NullableIntFieldUpdateOperationsInput | number | null
    perSwap?: NullableIntFieldUpdateOperationsInput | number | null
    spiSwap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterStatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterVersionId?: IntFieldUpdateOperationsInput | number
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    strSwap?: NullableIntFieldUpdateOperationsInput | number | null
    minSwap?: NullableIntFieldUpdateOperationsInput | number | null
    dexSwap?: NullableIntFieldUpdateOperationsInput | number | null
    conSwap?: NullableIntFieldUpdateOperationsInput | number | null
    perSwap?: NullableIntFieldUpdateOperationsInput | number | null
    spiSwap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterQuestCreateInput = {
    CharacterVersion: CharacterVersionCreateNestedOneWithoutCharacterQuestInput
    Quest: QuestCreateNestedOneWithoutCharacterQuestInput
  }

  export type CharacterQuestUncheckedCreateInput = {
    id?: number
    characterVersionId: number
    questId: number
  }

  export type CharacterQuestUpdateInput = {
    CharacterVersion?: CharacterVersionUpdateOneRequiredWithoutCharacterQuestNestedInput
    Quest?: QuestUpdateOneRequiredWithoutCharacterQuestNestedInput
  }

  export type CharacterQuestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterVersionId?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterQuestCreateManyInput = {
    id?: number
    characterVersionId: number
    questId: number
  }

  export type CharacterQuestUpdateManyMutationInput = {

  }

  export type CharacterQuestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterVersionId?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterEquipmentCreateInput = {
    light?: number | null
    finger1?: number | null
    finger2?: number | null
    neck1?: number | null
    neck2?: number | null
    body?: number | null
    head?: number | null
    hands?: number | null
    feet?: number | null
    face?: number | null
    arms?: number | null
    legs?: number | null
    about?: number | null
    waist?: number | null
    wrist1?: number | null
    wrist2?: number | null
    wield?: number | null
    hold1?: number | null
    hold2?: number | null
    hold3?: number | null
    ear1?: number | null
    ear2?: number | null
    arm?: number | null
    amulet?: number | null
    aux?: number | null
    CharacterVersion?: CharacterVersionCreateNestedManyWithoutCharacterEquipmentInput
  }

  export type CharacterEquipmentUncheckedCreateInput = {
    id?: number
    light?: number | null
    finger1?: number | null
    finger2?: number | null
    neck1?: number | null
    neck2?: number | null
    body?: number | null
    head?: number | null
    hands?: number | null
    feet?: number | null
    face?: number | null
    arms?: number | null
    legs?: number | null
    about?: number | null
    waist?: number | null
    wrist1?: number | null
    wrist2?: number | null
    wield?: number | null
    hold1?: number | null
    hold2?: number | null
    hold3?: number | null
    ear1?: number | null
    ear2?: number | null
    arm?: number | null
    amulet?: number | null
    aux?: number | null
    CharacterVersion?: CharacterVersionUncheckedCreateNestedManyWithoutCharacterEquipmentInput
  }

  export type CharacterEquipmentUpdateInput = {
    light?: NullableIntFieldUpdateOperationsInput | number | null
    finger1?: NullableIntFieldUpdateOperationsInput | number | null
    finger2?: NullableIntFieldUpdateOperationsInput | number | null
    neck1?: NullableIntFieldUpdateOperationsInput | number | null
    neck2?: NullableIntFieldUpdateOperationsInput | number | null
    body?: NullableIntFieldUpdateOperationsInput | number | null
    head?: NullableIntFieldUpdateOperationsInput | number | null
    hands?: NullableIntFieldUpdateOperationsInput | number | null
    feet?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    arms?: NullableIntFieldUpdateOperationsInput | number | null
    legs?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableIntFieldUpdateOperationsInput | number | null
    waist?: NullableIntFieldUpdateOperationsInput | number | null
    wrist1?: NullableIntFieldUpdateOperationsInput | number | null
    wrist2?: NullableIntFieldUpdateOperationsInput | number | null
    wield?: NullableIntFieldUpdateOperationsInput | number | null
    hold1?: NullableIntFieldUpdateOperationsInput | number | null
    hold2?: NullableIntFieldUpdateOperationsInput | number | null
    hold3?: NullableIntFieldUpdateOperationsInput | number | null
    ear1?: NullableIntFieldUpdateOperationsInput | number | null
    ear2?: NullableIntFieldUpdateOperationsInput | number | null
    arm?: NullableIntFieldUpdateOperationsInput | number | null
    amulet?: NullableIntFieldUpdateOperationsInput | number | null
    aux?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterVersion?: CharacterVersionUpdateManyWithoutCharacterEquipmentNestedInput
  }

  export type CharacterEquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    light?: NullableIntFieldUpdateOperationsInput | number | null
    finger1?: NullableIntFieldUpdateOperationsInput | number | null
    finger2?: NullableIntFieldUpdateOperationsInput | number | null
    neck1?: NullableIntFieldUpdateOperationsInput | number | null
    neck2?: NullableIntFieldUpdateOperationsInput | number | null
    body?: NullableIntFieldUpdateOperationsInput | number | null
    head?: NullableIntFieldUpdateOperationsInput | number | null
    hands?: NullableIntFieldUpdateOperationsInput | number | null
    feet?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    arms?: NullableIntFieldUpdateOperationsInput | number | null
    legs?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableIntFieldUpdateOperationsInput | number | null
    waist?: NullableIntFieldUpdateOperationsInput | number | null
    wrist1?: NullableIntFieldUpdateOperationsInput | number | null
    wrist2?: NullableIntFieldUpdateOperationsInput | number | null
    wield?: NullableIntFieldUpdateOperationsInput | number | null
    hold1?: NullableIntFieldUpdateOperationsInput | number | null
    hold2?: NullableIntFieldUpdateOperationsInput | number | null
    hold3?: NullableIntFieldUpdateOperationsInput | number | null
    ear1?: NullableIntFieldUpdateOperationsInput | number | null
    ear2?: NullableIntFieldUpdateOperationsInput | number | null
    arm?: NullableIntFieldUpdateOperationsInput | number | null
    amulet?: NullableIntFieldUpdateOperationsInput | number | null
    aux?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterVersion?: CharacterVersionUncheckedUpdateManyWithoutCharacterEquipmentNestedInput
  }

  export type CharacterEquipmentCreateManyInput = {
    id?: number
    light?: number | null
    finger1?: number | null
    finger2?: number | null
    neck1?: number | null
    neck2?: number | null
    body?: number | null
    head?: number | null
    hands?: number | null
    feet?: number | null
    face?: number | null
    arms?: number | null
    legs?: number | null
    about?: number | null
    waist?: number | null
    wrist1?: number | null
    wrist2?: number | null
    wield?: number | null
    hold1?: number | null
    hold2?: number | null
    hold3?: number | null
    ear1?: number | null
    ear2?: number | null
    arm?: number | null
    amulet?: number | null
    aux?: number | null
  }

  export type CharacterEquipmentUpdateManyMutationInput = {
    light?: NullableIntFieldUpdateOperationsInput | number | null
    finger1?: NullableIntFieldUpdateOperationsInput | number | null
    finger2?: NullableIntFieldUpdateOperationsInput | number | null
    neck1?: NullableIntFieldUpdateOperationsInput | number | null
    neck2?: NullableIntFieldUpdateOperationsInput | number | null
    body?: NullableIntFieldUpdateOperationsInput | number | null
    head?: NullableIntFieldUpdateOperationsInput | number | null
    hands?: NullableIntFieldUpdateOperationsInput | number | null
    feet?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    arms?: NullableIntFieldUpdateOperationsInput | number | null
    legs?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableIntFieldUpdateOperationsInput | number | null
    waist?: NullableIntFieldUpdateOperationsInput | number | null
    wrist1?: NullableIntFieldUpdateOperationsInput | number | null
    wrist2?: NullableIntFieldUpdateOperationsInput | number | null
    wield?: NullableIntFieldUpdateOperationsInput | number | null
    hold1?: NullableIntFieldUpdateOperationsInput | number | null
    hold2?: NullableIntFieldUpdateOperationsInput | number | null
    hold3?: NullableIntFieldUpdateOperationsInput | number | null
    ear1?: NullableIntFieldUpdateOperationsInput | number | null
    ear2?: NullableIntFieldUpdateOperationsInput | number | null
    arm?: NullableIntFieldUpdateOperationsInput | number | null
    amulet?: NullableIntFieldUpdateOperationsInput | number | null
    aux?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterEquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    light?: NullableIntFieldUpdateOperationsInput | number | null
    finger1?: NullableIntFieldUpdateOperationsInput | number | null
    finger2?: NullableIntFieldUpdateOperationsInput | number | null
    neck1?: NullableIntFieldUpdateOperationsInput | number | null
    neck2?: NullableIntFieldUpdateOperationsInput | number | null
    body?: NullableIntFieldUpdateOperationsInput | number | null
    head?: NullableIntFieldUpdateOperationsInput | number | null
    hands?: NullableIntFieldUpdateOperationsInput | number | null
    feet?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    arms?: NullableIntFieldUpdateOperationsInput | number | null
    legs?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableIntFieldUpdateOperationsInput | number | null
    waist?: NullableIntFieldUpdateOperationsInput | number | null
    wrist1?: NullableIntFieldUpdateOperationsInput | number | null
    wrist2?: NullableIntFieldUpdateOperationsInput | number | null
    wield?: NullableIntFieldUpdateOperationsInput | number | null
    hold1?: NullableIntFieldUpdateOperationsInput | number | null
    hold2?: NullableIntFieldUpdateOperationsInput | number | null
    hold3?: NullableIntFieldUpdateOperationsInput | number | null
    ear1?: NullableIntFieldUpdateOperationsInput | number | null
    ear2?: NullableIntFieldUpdateOperationsInput | number | null
    arm?: NullableIntFieldUpdateOperationsInput | number | null
    amulet?: NullableIntFieldUpdateOperationsInput | number | null
    aux?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ItemCreateInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    CreatedItems: AccountCreateNestedOneWithoutCreatedItemsInput
    ModifiedItems?: AccountCreateNestedOneWithoutModifiedItemsInput
    ItemSpell?: ItemSpellCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponUncheckedCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedItems?: AccountUpdateOneRequiredWithoutCreatedItemsNestedInput
    ModifiedItems?: AccountUpdateOneWithoutModifiedItemsNestedInput
    ItemSpell?: ItemSpellUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUncheckedUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemCreateManyInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
  }

  export type ItemUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ItemWeaponCreateInput = {
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
    Item: ItemCreateNestedOneWithoutItemWeaponInput
    AmmoItem: ItemCreateNestedOneWithoutAmmoItemInput
  }

  export type ItemWeaponUncheckedCreateInput = {
    id?: number
    itemId: number
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    ammoTypeId: number
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
  }

  export type ItemWeaponUpdateInput = {
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    Item?: ItemUpdateOneRequiredWithoutItemWeaponNestedInput
    AmmoItem?: ItemUpdateOneRequiredWithoutAmmoItemNestedInput
  }

  export type ItemWeaponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    ammoTypeId?: IntFieldUpdateOperationsInput | number
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
  }

  export type ItemWeaponCreateManyInput = {
    id?: number
    itemId: number
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    ammoTypeId: number
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
  }

  export type ItemWeaponUpdateManyMutationInput = {
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
  }

  export type ItemWeaponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    ammoTypeId?: IntFieldUpdateOperationsInput | number
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
  }

  export type ItemSpellCreateInput = {
    Item: ItemCreateNestedOneWithoutItemSpellInput
    Spell: SpellCreateNestedOneWithoutItemSpellInput
  }

  export type ItemSpellUncheckedCreateInput = {
    id?: number
    itemId: number
    spellId: number
  }

  export type ItemSpellUpdateInput = {
    Item?: ItemUpdateOneRequiredWithoutItemSpellNestedInput
    Spell?: SpellUpdateOneRequiredWithoutItemSpellNestedInput
  }

  export type ItemSpellUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemSpellCreateManyInput = {
    id?: number
    itemId: number
    spellId: number
  }

  export type ItemSpellUpdateManyMutationInput = {

  }

  export type ItemSpellUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellCreateInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellCreateNestedManyWithoutSpellInput
    CreatedSpells: AccountCreateNestedOneWithoutCreatedSpellsInput
    ModifiedSpells: AccountCreateNestedOneWithoutModifiedSpellsInput
    StatModifer?: StatModiferCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutSpellInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUpdateManyWithoutSpellNestedInput
    CreatedSpells?: AccountUpdateOneRequiredWithoutCreatedSpellsNestedInput
    ModifiedSpells?: AccountUpdateOneRequiredWithoutModifiedSpellsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutSpellSourceNestedInput
  }

  export type SpellUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutSpellNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutSpellSourceNestedInput
  }

  export type SpellCreateManyInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
  }

  export type SpellUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PotionCreateInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
    CreatedPotions: AccountCreateNestedOneWithoutCreatedPotionsInput
    ModifiedPotions: AccountCreateNestedOneWithoutModifiedPotionsInput
    StatModifer?: StatModiferCreateNestedOneWithoutPotionSourceInput
  }

  export type PotionUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutPotionSourceInput
  }

  export type PotionUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedPotions?: AccountUpdateOneRequiredWithoutCreatedPotionsNestedInput
    ModifiedPotions?: AccountUpdateOneRequiredWithoutModifiedPotionsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutPotionSourceNestedInput
  }

  export type PotionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutPotionSourceNestedInput
  }

  export type PotionCreateManyInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
  }

  export type PotionUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PotionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SkillCreateInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
    CreatedSkills: AccountCreateNestedOneWithoutCreatedSkillsInput
    ModifiedSkills: AccountCreateNestedOneWithoutModifiedSkillsInput
    StatModifer?: StatModiferCreateNestedOneWithoutSkillSourceInput
  }

  export type SkillUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutSkillSourceInput
  }

  export type SkillUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
    CreatedSkills?: AccountUpdateOneRequiredWithoutCreatedSkillsNestedInput
    ModifiedSkills?: AccountUpdateOneRequiredWithoutModifiedSkillsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutSkillSourceNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
    StatModifer?: StatModiferUncheckedUpdateOneWithoutSkillSourceNestedInput
  }

  export type SkillCreateManyInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
  }

  export type SkillUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
  }

  export type AbilityCreateInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
    CreatedAbilities: AccountCreateNestedOneWithoutCreatedAbilitiesInput
    ModifiedAbilities: AccountCreateNestedOneWithoutModifiedAbilitiesInput
    StatModifer?: StatModiferCreateNestedOneWithoutAbilitySourceInput
  }

  export type AbilityUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutAbilitySourceInput
  }

  export type AbilityUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedAbilities?: AccountUpdateOneRequiredWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AccountUpdateOneRequiredWithoutModifiedAbilitiesNestedInput
    StatModifer?: StatModiferUpdateOneWithoutAbilitySourceNestedInput
  }

  export type AbilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutAbilitySourceNestedInput
  }

  export type AbilityCreateManyInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
  }

  export type AbilityUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AbilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestCreateInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CreatedQuests: AccountCreateNestedOneWithoutCreatedQuestsInput
    ModifiedQuests: AccountCreateNestedOneWithoutModifiedQuestsInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagUncheckedCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedQuests?: AccountUpdateOneRequiredWithoutCreatedQuestsNestedInput
    ModifiedQuests?: AccountUpdateOneRequiredWithoutModifiedQuestsNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUncheckedUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestCreateManyInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
  }

  export type QuestUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatModiferCreateInput = {
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
    ItemSource?: ItemCreateNestedOneWithoutStatModiferInput
    QuestSource?: QuestCreateNestedOneWithoutStatModiferInput
    AbilitySource?: AbilityCreateNestedOneWithoutStatModiferInput
    SkillSource?: SkillCreateNestedOneWithoutStatModiferInput
    SpellSource?: SpellCreateNestedOneWithoutStatModiferInput
    PotionSource?: PotionCreateNestedOneWithoutStatModiferInput
  }

  export type StatModiferUncheckedCreateInput = {
    id?: number
    type: $Enums.StatModifierType
    sourceId: number
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferUpdateInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSource?: ItemUpdateOneWithoutStatModiferNestedInput
    QuestSource?: QuestUpdateOneWithoutStatModiferNestedInput
    AbilitySource?: AbilityUpdateOneWithoutStatModiferNestedInput
    SkillSource?: SkillUpdateOneWithoutStatModiferNestedInput
    SpellSource?: SpellUpdateOneWithoutStatModiferNestedInput
    PotionSource?: PotionUpdateOneWithoutStatModiferNestedInput
  }

  export type StatModiferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    sourceId?: IntFieldUpdateOperationsInput | number
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatModiferCreateManyInput = {
    id?: number
    type: $Enums.StatModifierType
    sourceId: number
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferUpdateManyMutationInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatModiferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    sourceId?: IntFieldUpdateOperationsInput | number
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArticleCreateInput = {
    createdDate?: Date | string
    isProtected?: boolean
    Author: AccountCreateNestedOneWithoutArticleInput
    ArticleContent?: ArticleVersionCreateNestedManyWithoutArticleInput
    ArticleTagSource?: AppliedTagCreateNestedOneWithoutArticleTagSourceInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    authorId: number
    isProtected?: boolean
    ArticleContent?: ArticleVersionUncheckedCreateNestedManyWithoutArticleInput
    ArticleTagSource?: AppliedTagUncheckedCreateNestedOneWithoutArticleTagSourceInput
  }

  export type ArticleUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    Author?: AccountUpdateOneRequiredWithoutArticleNestedInput
    ArticleContent?: ArticleVersionUpdateManyWithoutArticleNestedInput
    ArticleTagSource?: AppliedTagUpdateOneWithoutArticleTagSourceNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    ArticleContent?: ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
    ArticleTagSource?: AppliedTagUncheckedUpdateOneWithoutArticleTagSourceNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: number
    createdDate?: Date | string
    authorId: number
    isProtected?: boolean
  }

  export type ArticleUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isProtected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
    isProtected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArticleVersionCreateInput = {
    modifiedDate?: Date | string
    content: string
    isCurrent: boolean
    version?: string | null
    Editor: AccountCreateNestedOneWithoutArticleVersionInput
    Article: ArticleCreateNestedOneWithoutArticleContentInput
  }

  export type ArticleVersionUncheckedCreateInput = {
    id?: number
    articleId: number
    modifiedDate?: Date | string
    editorId: number
    content: string
    isCurrent: boolean
    version?: string | null
  }

  export type ArticleVersionUpdateInput = {
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
    Editor?: AccountUpdateOneRequiredWithoutArticleVersionNestedInput
    Article?: ArticleUpdateOneRequiredWithoutArticleContentNestedInput
  }

  export type ArticleVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    editorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleVersionCreateManyInput = {
    id?: number
    articleId: number
    modifiedDate?: Date | string
    editorId: number
    content: string
    isCurrent: boolean
    version?: string | null
  }

  export type ArticleVersionUpdateManyMutationInput = {
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    editorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagCreateInput = {
    createdDate?: Date | string
    tag: string
    Creator: AccountCreateNestedOneWithoutTagInput
    AppliedTag?: AppliedTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    tag: string
    AppliedTag?: AppliedTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    Creator?: AccountUpdateOneRequiredWithoutTagNestedInput
    AppliedTag?: AppliedTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    AppliedTag?: AppliedTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    tag: string
  }

  export type TagUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type AppliedTagCreateInput = {
    typeId: $Enums.TagType
    Tag: TagCreateNestedOneWithoutAppliedTagInput
    ArticleTagSource?: ArticleCreateNestedOneWithoutArticleTagSourceInput
    ItemTagSource?: ItemCreateNestedOneWithoutItemTagSourceInput
    MobTagSource?: MobCreateNestedOneWithoutMobTagSourceInput
    QuestTagSource?: QuestCreateNestedOneWithoutQuestTagSourceInput
  }

  export type AppliedTagUncheckedCreateInput = {
    id?: number
    typeId: $Enums.TagType
    sourceId?: number | null
    tagId: number
  }

  export type AppliedTagUpdateInput = {
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    Tag?: TagUpdateOneRequiredWithoutAppliedTagNestedInput
    ArticleTagSource?: ArticleUpdateOneWithoutArticleTagSourceNestedInput
    ItemTagSource?: ItemUpdateOneWithoutItemTagSourceNestedInput
    MobTagSource?: MobUpdateOneWithoutMobTagSourceNestedInput
    QuestTagSource?: QuestUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type AppliedTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type AppliedTagCreateManyInput = {
    id?: number
    typeId: $Enums.TagType
    sourceId?: number | null
    tagId: number
  }

  export type AppliedTagUpdateManyMutationInput = {
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
  }

  export type AppliedTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type MobCreateInput = {
    mudId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
    MobTagSource?: AppliedTagCreateNestedOneWithoutMobTagSourceInput
    Area?: AreaCreateNestedOneWithoutMobInput
  }

  export type MobUncheckedCreateInput = {
    id?: number
    mudId?: number | null
    areaId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
    MobTagSource?: AppliedTagUncheckedCreateNestedOneWithoutMobTagSourceInput
  }

  export type MobUpdateInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
    MobTagSource?: AppliedTagUpdateOneWithoutMobTagSourceNestedInput
    Area?: AreaUpdateOneWithoutMobNestedInput
  }

  export type MobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
    MobTagSource?: AppliedTagUncheckedUpdateOneWithoutMobTagSourceNestedInput
  }

  export type MobCreateManyInput = {
    id?: number
    mudId?: number | null
    areaId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
  }

  export type MobUpdateManyMutationInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaCreateInput = {
    mudId?: number | null
    name: string
    releaseDate?: Date | string | null
    Author?: AccountCreateNestedOneWithoutAreaInput
    Mob?: MobCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: number
    mudId?: number | null
    name: string
    authorId?: number | null
    releaseDate?: Date | string | null
    Mob?: MobUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaUpdateInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Author?: AccountUpdateOneWithoutAreaNestedInput
    Mob?: MobUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Mob?: MobUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: number
    mudId?: number | null
    name: string
    authorId?: number | null
    releaseDate?: Date | string | null
  }

  export type AreaUpdateManyMutationInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeLogCreateInput = {
    createdDate: Date | string
    content?: string | null
    version?: string | null
    releaseDate?: Date | string | null
    Creator?: AccountCreateNestedOneWithoutChangeLogInput
  }

  export type ChangeLogUncheckedCreateInput = {
    id?: number
    createdDate: Date | string
    createdBy: number
    content?: string | null
    version?: string | null
    releaseDate?: Date | string | null
  }

  export type ChangeLogUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Creator?: AccountUpdateOneWithoutChangeLogNestedInput
  }

  export type ChangeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeLogCreateManyInput = {
    id?: number
    createdDate: Date | string
    createdBy: number
    content?: string | null
    version?: string | null
    releaseDate?: Date | string | null
  }

  export type ChangeLogUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AccountNotificationListRelationFilter = {
    every?: AccountNotificationWhereInput
    some?: AccountNotificationWhereInput
    none?: AccountNotificationWhereInput
  }

  export type AccountPasswordListRelationFilter = {
    every?: AccountPasswordWhereInput
    some?: AccountPasswordWhereInput
    none?: AccountPasswordWhereInput
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type NetworkHistoryListRelationFilter = {
    every?: NetworkHistoryWhereInput
    some?: NetworkHistoryWhereInput
    none?: NetworkHistoryWhereInput
  }

  export type NetworkBlacklistListRelationFilter = {
    every?: NetworkBlacklistWhereInput
    some?: NetworkBlacklistWhereInput
    none?: NetworkBlacklistWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type SpellListRelationFilter = {
    every?: SpellWhereInput
    some?: SpellWhereInput
    none?: SpellWhereInput
  }

  export type PotionListRelationFilter = {
    every?: PotionWhereInput
    some?: PotionWhereInput
    none?: PotionWhereInput
  }

  export type SkillListRelationFilter = {
    every?: SkillWhereInput
    some?: SkillWhereInput
    none?: SkillWhereInput
  }

  export type AbilityListRelationFilter = {
    every?: AbilityWhereInput
    some?: AbilityWhereInput
    none?: AbilityWhereInput
  }

  export type QuestListRelationFilter = {
    every?: QuestWhereInput
    some?: QuestWhereInput
    none?: QuestWhereInput
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type ArticleVersionListRelationFilter = {
    every?: ArticleVersionWhereInput
    some?: ArticleVersionWhereInput
    none?: ArticleVersionWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type AreaListRelationFilter = {
    every?: AreaWhereInput
    some?: AreaWhereInput
    none?: AreaWhereInput
  }

  export type ChangeLogListRelationFilter = {
    every?: ChangeLogWhereInput
    some?: ChangeLogWhereInput
    none?: ChangeLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountPasswordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkBlacklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    preferences?: SortOrder
    roles?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    notificationId?: SortOrder
    read?: SortOrder
    readDate?: SortOrder
  }

  export type AccountNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    notificationId?: SortOrder
  }

  export type AccountNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    notificationId?: SortOrder
    read?: SortOrder
    readDate?: SortOrder
  }

  export type AccountNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    notificationId?: SortOrder
    read?: SortOrder
    readDate?: SortOrder
  }

  export type AccountNotificationSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    notificationId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AccountPasswordCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    passwordHash?: SortOrder
  }

  export type AccountPasswordAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type AccountPasswordMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    passwordHash?: SortOrder
  }

  export type AccountPasswordMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    passwordHash?: SortOrder
  }

  export type AccountPasswordSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type NetworkHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    loginDate?: SortOrder
    ipAddress?: SortOrder
  }

  export type NetworkHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type NetworkHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    loginDate?: SortOrder
    ipAddress?: SortOrder
  }

  export type NetworkHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    loginDate?: SortOrder
    ipAddress?: SortOrder
  }

  export type NetworkHistorySumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type NetworkHistoryRelationFilter = {
    is?: NetworkHistoryWhereInput
    isNot?: NetworkHistoryWhereInput
  }

  export type NetworkBlacklistCountOrderByAggregateInput = {
    id?: SortOrder
    networkHistoryId?: SortOrder
    issueDate?: SortOrder
    termDate?: SortOrder
    issuer?: SortOrder
  }

  export type NetworkBlacklistAvgOrderByAggregateInput = {
    id?: SortOrder
    networkHistoryId?: SortOrder
    issuer?: SortOrder
  }

  export type NetworkBlacklistMaxOrderByAggregateInput = {
    id?: SortOrder
    networkHistoryId?: SortOrder
    issueDate?: SortOrder
    termDate?: SortOrder
    issuer?: SortOrder
  }

  export type NetworkBlacklistMinOrderByAggregateInput = {
    id?: SortOrder
    networkHistoryId?: SortOrder
    issueDate?: SortOrder
    termDate?: SortOrder
    issuer?: SortOrder
  }

  export type NetworkBlacklistSumOrderByAggregateInput = {
    id?: SortOrder
    networkHistoryId?: SortOrder
    issuer?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CharacterVersionListRelationFilter = {
    every?: CharacterVersionWhereInput
    some?: CharacterVersionWhereInput
    none?: CharacterVersionWhereInput
  }

  export type CharacterVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    accountId?: SortOrder
    level?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    accountId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    accountId?: SortOrder
    level?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CharacterRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type CharacterStatNullableRelationFilter = {
    is?: CharacterStatWhereInput | null
    isNot?: CharacterStatWhereInput | null
  }

  export type CharacterQuestListRelationFilter = {
    every?: CharacterQuestWhereInput
    some?: CharacterQuestWhereInput
    none?: CharacterQuestWhereInput
  }

  export type CharacterEquipmentNullableRelationFilter = {
    is?: CharacterEquipmentWhereInput | null
    isNot?: CharacterEquipmentWhereInput | null
  }

  export type CharacterQuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterVersionCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    equipmentId?: SortOrder
    statsId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    version?: SortOrder
    hometown?: SortOrder
    characterEquipmentId?: SortOrder
  }

  export type CharacterVersionAvgOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    equipmentId?: SortOrder
    statsId?: SortOrder
    characterEquipmentId?: SortOrder
  }

  export type CharacterVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    equipmentId?: SortOrder
    statsId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    version?: SortOrder
    hometown?: SortOrder
    characterEquipmentId?: SortOrder
  }

  export type CharacterVersionMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    equipmentId?: SortOrder
    statsId?: SortOrder
    createdDate?: SortOrder
    modifiedDate?: SortOrder
    version?: SortOrder
    hometown?: SortOrder
    characterEquipmentId?: SortOrder
  }

  export type CharacterVersionSumOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    equipmentId?: SortOrder
    statsId?: SortOrder
    characterEquipmentId?: SortOrder
  }

  export type CharacterVersionRelationFilter = {
    is?: CharacterVersionWhereInput
    isNot?: CharacterVersionWhereInput
  }

  export type CharacterStatCountOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    strSwap?: SortOrder
    minSwap?: SortOrder
    dexSwap?: SortOrder
    conSwap?: SortOrder
    perSwap?: SortOrder
    spiSwap?: SortOrder
  }

  export type CharacterStatAvgOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    strSwap?: SortOrder
    minSwap?: SortOrder
    dexSwap?: SortOrder
    conSwap?: SortOrder
    perSwap?: SortOrder
    spiSwap?: SortOrder
  }

  export type CharacterStatMaxOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    strSwap?: SortOrder
    minSwap?: SortOrder
    dexSwap?: SortOrder
    conSwap?: SortOrder
    perSwap?: SortOrder
    spiSwap?: SortOrder
  }

  export type CharacterStatMinOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    strSwap?: SortOrder
    minSwap?: SortOrder
    dexSwap?: SortOrder
    conSwap?: SortOrder
    perSwap?: SortOrder
    spiSwap?: SortOrder
  }

  export type CharacterStatSumOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    strSwap?: SortOrder
    minSwap?: SortOrder
    dexSwap?: SortOrder
    conSwap?: SortOrder
    perSwap?: SortOrder
    spiSwap?: SortOrder
  }

  export type QuestRelationFilter = {
    is?: QuestWhereInput
    isNot?: QuestWhereInput
  }

  export type CharacterQuestCountOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    questId?: SortOrder
  }

  export type CharacterQuestAvgOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    questId?: SortOrder
  }

  export type CharacterQuestMaxOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    questId?: SortOrder
  }

  export type CharacterQuestMinOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    questId?: SortOrder
  }

  export type CharacterQuestSumOrderByAggregateInput = {
    id?: SortOrder
    characterVersionId?: SortOrder
    questId?: SortOrder
  }

  export type CharacterEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    light?: SortOrder
    finger1?: SortOrder
    finger2?: SortOrder
    neck1?: SortOrder
    neck2?: SortOrder
    body?: SortOrder
    head?: SortOrder
    hands?: SortOrder
    feet?: SortOrder
    face?: SortOrder
    arms?: SortOrder
    legs?: SortOrder
    about?: SortOrder
    waist?: SortOrder
    wrist1?: SortOrder
    wrist2?: SortOrder
    wield?: SortOrder
    hold1?: SortOrder
    hold2?: SortOrder
    hold3?: SortOrder
    ear1?: SortOrder
    ear2?: SortOrder
    arm?: SortOrder
    amulet?: SortOrder
    aux?: SortOrder
  }

  export type CharacterEquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    light?: SortOrder
    finger1?: SortOrder
    finger2?: SortOrder
    neck1?: SortOrder
    neck2?: SortOrder
    body?: SortOrder
    head?: SortOrder
    hands?: SortOrder
    feet?: SortOrder
    face?: SortOrder
    arms?: SortOrder
    legs?: SortOrder
    about?: SortOrder
    waist?: SortOrder
    wrist1?: SortOrder
    wrist2?: SortOrder
    wield?: SortOrder
    hold1?: SortOrder
    hold2?: SortOrder
    hold3?: SortOrder
    ear1?: SortOrder
    ear2?: SortOrder
    arm?: SortOrder
    amulet?: SortOrder
    aux?: SortOrder
  }

  export type CharacterEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    light?: SortOrder
    finger1?: SortOrder
    finger2?: SortOrder
    neck1?: SortOrder
    neck2?: SortOrder
    body?: SortOrder
    head?: SortOrder
    hands?: SortOrder
    feet?: SortOrder
    face?: SortOrder
    arms?: SortOrder
    legs?: SortOrder
    about?: SortOrder
    waist?: SortOrder
    wrist1?: SortOrder
    wrist2?: SortOrder
    wield?: SortOrder
    hold1?: SortOrder
    hold2?: SortOrder
    hold3?: SortOrder
    ear1?: SortOrder
    ear2?: SortOrder
    arm?: SortOrder
    amulet?: SortOrder
    aux?: SortOrder
  }

  export type CharacterEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    light?: SortOrder
    finger1?: SortOrder
    finger2?: SortOrder
    neck1?: SortOrder
    neck2?: SortOrder
    body?: SortOrder
    head?: SortOrder
    hands?: SortOrder
    feet?: SortOrder
    face?: SortOrder
    arms?: SortOrder
    legs?: SortOrder
    about?: SortOrder
    waist?: SortOrder
    wrist1?: SortOrder
    wrist2?: SortOrder
    wield?: SortOrder
    hold1?: SortOrder
    hold2?: SortOrder
    hold3?: SortOrder
    ear1?: SortOrder
    ear2?: SortOrder
    arm?: SortOrder
    amulet?: SortOrder
    aux?: SortOrder
  }

  export type CharacterEquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    light?: SortOrder
    finger1?: SortOrder
    finger2?: SortOrder
    neck1?: SortOrder
    neck2?: SortOrder
    body?: SortOrder
    head?: SortOrder
    hands?: SortOrder
    feet?: SortOrder
    face?: SortOrder
    arms?: SortOrder
    legs?: SortOrder
    about?: SortOrder
    waist?: SortOrder
    wrist1?: SortOrder
    wrist2?: SortOrder
    wield?: SortOrder
    hold1?: SortOrder
    hold2?: SortOrder
    hold3?: SortOrder
    ear1?: SortOrder
    ear2?: SortOrder
    arm?: SortOrder
    amulet?: SortOrder
    aux?: SortOrder
  }

  export type EnumAlignNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Align | EnumAlignFieldRefInput<$PrismaModel> | null
    in?: $Enums.Align[] | null
    notIn?: $Enums.Align[] | null
    not?: NestedEnumAlignNullableFilter<$PrismaModel> | $Enums.Align | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AccountNullableRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type ItemSpellListRelationFilter = {
    every?: ItemSpellWhereInput
    some?: ItemSpellWhereInput
    none?: ItemSpellWhereInput
  }

  export type ItemWeaponNullableRelationFilter = {
    is?: ItemWeaponWhereInput | null
    isNot?: ItemWeaponWhereInput | null
  }

  export type ItemWeaponListRelationFilter = {
    every?: ItemWeaponWhereInput
    some?: ItemWeaponWhereInput
    none?: ItemWeaponWhereInput
  }

  export type StatModiferNullableRelationFilter = {
    is?: StatModiferWhereInput | null
    isNot?: StatModiferWhereInput | null
  }

  export type AppliedTagNullableRelationFilter = {
    is?: AppliedTagWhereInput | null
    isNot?: AppliedTagWhereInput | null
  }

  export type ItemSpellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemWeaponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    timer?: SortOrder
    align?: SortOrder
    rent?: SortOrder
    preservable?: SortOrder
    netStat?: SortOrder
    notes?: SortOrder
    weight?: SortOrder
    slots?: SortOrder
    isBonded?: SortOrder
    isCastable?: SortOrder
    isHeroic?: SortOrder
    isLevelRequired?: SortOrder
    isLight?: SortOrder
    isLimited?: SortOrder
    isSoulbound?: SortOrder
    isUnique?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    timer?: SortOrder
    rent?: SortOrder
    netStat?: SortOrder
    weight?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    timer?: SortOrder
    align?: SortOrder
    rent?: SortOrder
    preservable?: SortOrder
    netStat?: SortOrder
    notes?: SortOrder
    weight?: SortOrder
    slots?: SortOrder
    isBonded?: SortOrder
    isCastable?: SortOrder
    isHeroic?: SortOrder
    isLevelRequired?: SortOrder
    isLight?: SortOrder
    isLimited?: SortOrder
    isSoulbound?: SortOrder
    isUnique?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    timer?: SortOrder
    align?: SortOrder
    rent?: SortOrder
    preservable?: SortOrder
    netStat?: SortOrder
    notes?: SortOrder
    weight?: SortOrder
    slots?: SortOrder
    isBonded?: SortOrder
    isCastable?: SortOrder
    isHeroic?: SortOrder
    isLevelRequired?: SortOrder
    isLight?: SortOrder
    isLimited?: SortOrder
    isSoulbound?: SortOrder
    isUnique?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    timer?: SortOrder
    rent?: SortOrder
    netStat?: SortOrder
    weight?: SortOrder
  }

  export type EnumAlignNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Align | EnumAlignFieldRefInput<$PrismaModel> | null
    in?: $Enums.Align[] | null
    notIn?: $Enums.Align[] | null
    not?: NestedEnumAlignNullableWithAggregatesFilter<$PrismaModel> | $Enums.Align | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAlignNullableFilter<$PrismaModel>
    _max?: NestedEnumAlignNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumWeaponStatNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponStat | EnumWeaponStatFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponStat[] | null
    notIn?: $Enums.WeaponStat[] | null
    not?: NestedEnumWeaponStatNullableFilter<$PrismaModel> | $Enums.WeaponStat | null
  }

  export type EnumWeaponTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | null
    notIn?: $Enums.WeaponType[] | null
    not?: NestedEnumWeaponTypeNullableFilter<$PrismaModel> | $Enums.WeaponType | null
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type ItemWeaponCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quality?: SortOrder
    speed?: SortOrder
    isHoldable?: SortOrder
    isTwoHanded?: SortOrder
    ammoCapacity?: SortOrder
    ammoTypeId?: SortOrder
    shotAccuracy?: SortOrder
    maxDamage?: SortOrder
    minDamage?: SortOrder
    avgDamage?: SortOrder
    stat?: SortOrder
    type?: SortOrder
  }

  export type ItemWeaponAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quality?: SortOrder
    speed?: SortOrder
    ammoCapacity?: SortOrder
    ammoTypeId?: SortOrder
    shotAccuracy?: SortOrder
    maxDamage?: SortOrder
    minDamage?: SortOrder
    avgDamage?: SortOrder
  }

  export type ItemWeaponMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quality?: SortOrder
    speed?: SortOrder
    isHoldable?: SortOrder
    isTwoHanded?: SortOrder
    ammoCapacity?: SortOrder
    ammoTypeId?: SortOrder
    shotAccuracy?: SortOrder
    maxDamage?: SortOrder
    minDamage?: SortOrder
    avgDamage?: SortOrder
    stat?: SortOrder
    type?: SortOrder
  }

  export type ItemWeaponMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quality?: SortOrder
    speed?: SortOrder
    isHoldable?: SortOrder
    isTwoHanded?: SortOrder
    ammoCapacity?: SortOrder
    ammoTypeId?: SortOrder
    shotAccuracy?: SortOrder
    maxDamage?: SortOrder
    minDamage?: SortOrder
    avgDamage?: SortOrder
    stat?: SortOrder
    type?: SortOrder
  }

  export type ItemWeaponSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quality?: SortOrder
    speed?: SortOrder
    ammoCapacity?: SortOrder
    ammoTypeId?: SortOrder
    shotAccuracy?: SortOrder
    maxDamage?: SortOrder
    minDamage?: SortOrder
    avgDamage?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumWeaponStatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponStat | EnumWeaponStatFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponStat[] | null
    notIn?: $Enums.WeaponStat[] | null
    not?: NestedEnumWeaponStatNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeaponStat | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeaponStatNullableFilter<$PrismaModel>
    _max?: NestedEnumWeaponStatNullableFilter<$PrismaModel>
  }

  export type EnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | null
    notIn?: $Enums.WeaponType[] | null
    not?: NestedEnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeaponType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
  }

  export type SpellRelationFilter = {
    is?: SpellWhereInput
    isNot?: SpellWhereInput
  }

  export type ItemSpellCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    spellId?: SortOrder
  }

  export type ItemSpellAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    spellId?: SortOrder
  }

  export type ItemSpellMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    spellId?: SortOrder
  }

  export type ItemSpellMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    spellId?: SortOrder
  }

  export type ItemSpellSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    spellId?: SortOrder
  }

  export type SpellCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    words?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SpellAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SpellMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    words?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SpellMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    words?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SpellSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    levelRequirement?: SortOrder
  }

  export type PotionCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    duration?: SortOrder
  }

  export type PotionAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    duration?: SortOrder
  }

  export type PotionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    duration?: SortOrder
  }

  export type PotionMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    duration?: SortOrder
  }

  export type PotionSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    duration?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    trainable?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    trainable?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    trainable?: SortOrder
    levelRequirement?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    levelRequirement?: SortOrder
  }

  export type AbilityCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    firstRankPoints?: SortOrder
    secondRankPoints?: SortOrder
    thirdRankPoints?: SortOrder
    fourthRankPoints?: SortOrder
    fifthRankPoints?: SortOrder
    sixthRankPoints?: SortOrder
  }

  export type AbilityAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    firstRankPoints?: SortOrder
    secondRankPoints?: SortOrder
    thirdRankPoints?: SortOrder
    fourthRankPoints?: SortOrder
    fifthRankPoints?: SortOrder
    sixthRankPoints?: SortOrder
  }

  export type AbilityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    firstRankPoints?: SortOrder
    secondRankPoints?: SortOrder
    thirdRankPoints?: SortOrder
    fourthRankPoints?: SortOrder
    fifthRankPoints?: SortOrder
    sixthRankPoints?: SortOrder
  }

  export type AbilityMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    firstRankPoints?: SortOrder
    secondRankPoints?: SortOrder
    thirdRankPoints?: SortOrder
    fourthRankPoints?: SortOrder
    fifthRankPoints?: SortOrder
    sixthRankPoints?: SortOrder
  }

  export type AbilitySumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    firstRankPoints?: SortOrder
    secondRankPoints?: SortOrder
    thirdRankPoints?: SortOrder
    fourthRankPoints?: SortOrder
    fifthRankPoints?: SortOrder
    sixthRankPoints?: SortOrder
  }

  export type QuestCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    whoises?: SortOrder
    pretitles?: SortOrder
    post_titles?: SortOrder
    experience?: SortOrder
  }

  export type QuestAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    experience?: SortOrder
  }

  export type QuestMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    whoises?: SortOrder
    pretitles?: SortOrder
    post_titles?: SortOrder
    experience?: SortOrder
  }

  export type QuestMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    modifiedDate?: SortOrder
    modifiedBy?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    whoises?: SortOrder
    pretitles?: SortOrder
    post_titles?: SortOrder
    experience?: SortOrder
  }

  export type QuestSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    experience?: SortOrder
  }

  export type EnumStatModifierTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatModifierType | EnumStatModifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatModifierType[]
    notIn?: $Enums.StatModifierType[]
    not?: NestedEnumStatModifierTypeFilter<$PrismaModel> | $Enums.StatModifierType
  }

  export type ItemNullableRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type QuestNullableRelationFilter = {
    is?: QuestWhereInput | null
    isNot?: QuestWhereInput | null
  }

  export type AbilityNullableRelationFilter = {
    is?: AbilityWhereInput | null
    isNot?: AbilityWhereInput | null
  }

  export type SkillNullableRelationFilter = {
    is?: SkillWhereInput | null
    isNot?: SkillWhereInput | null
  }

  export type SpellNullableRelationFilter = {
    is?: SpellWhereInput | null
    isNot?: SpellWhereInput | null
  }

  export type PotionNullableRelationFilter = {
    is?: PotionWhereInput | null
    isNot?: PotionWhereInput | null
  }

  export type StatModiferCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sourceId?: SortOrder
    hp?: SortOrder
    mv?: SortOrder
    ma?: SortOrder
    ac?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    hpRegen?: SortOrder
    mvRegen?: SortOrder
    maRegen?: SortOrder
    damroll?: SortOrder
    hitroll?: SortOrder
    mitigation?: SortOrder
    spellDam?: SortOrder
    spellCrit?: SortOrder
    spellRedux?: SortOrder
    concentration?: SortOrder
    shotAccuracy?: SortOrder
    bonusAccuracy?: SortOrder
    ammoCapacity?: SortOrder
    parry?: SortOrder
    strCap?: SortOrder
    minCap?: SortOrder
    dexCap?: SortOrder
    conCap?: SortOrder
    perCap?: SortOrder
    spiCap?: SortOrder
  }

  export type StatModiferAvgOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    hp?: SortOrder
    mv?: SortOrder
    ma?: SortOrder
    ac?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    hpRegen?: SortOrder
    mvRegen?: SortOrder
    maRegen?: SortOrder
    damroll?: SortOrder
    hitroll?: SortOrder
    mitigation?: SortOrder
    spellDam?: SortOrder
    spellCrit?: SortOrder
    spellRedux?: SortOrder
    concentration?: SortOrder
    shotAccuracy?: SortOrder
    bonusAccuracy?: SortOrder
    ammoCapacity?: SortOrder
    parry?: SortOrder
    strCap?: SortOrder
    minCap?: SortOrder
    dexCap?: SortOrder
    conCap?: SortOrder
    perCap?: SortOrder
    spiCap?: SortOrder
  }

  export type StatModiferMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sourceId?: SortOrder
    hp?: SortOrder
    mv?: SortOrder
    ma?: SortOrder
    ac?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    hpRegen?: SortOrder
    mvRegen?: SortOrder
    maRegen?: SortOrder
    damroll?: SortOrder
    hitroll?: SortOrder
    mitigation?: SortOrder
    spellDam?: SortOrder
    spellCrit?: SortOrder
    spellRedux?: SortOrder
    concentration?: SortOrder
    shotAccuracy?: SortOrder
    bonusAccuracy?: SortOrder
    ammoCapacity?: SortOrder
    parry?: SortOrder
    strCap?: SortOrder
    minCap?: SortOrder
    dexCap?: SortOrder
    conCap?: SortOrder
    perCap?: SortOrder
    spiCap?: SortOrder
  }

  export type StatModiferMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sourceId?: SortOrder
    hp?: SortOrder
    mv?: SortOrder
    ma?: SortOrder
    ac?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    hpRegen?: SortOrder
    mvRegen?: SortOrder
    maRegen?: SortOrder
    damroll?: SortOrder
    hitroll?: SortOrder
    mitigation?: SortOrder
    spellDam?: SortOrder
    spellCrit?: SortOrder
    spellRedux?: SortOrder
    concentration?: SortOrder
    shotAccuracy?: SortOrder
    bonusAccuracy?: SortOrder
    ammoCapacity?: SortOrder
    parry?: SortOrder
    strCap?: SortOrder
    minCap?: SortOrder
    dexCap?: SortOrder
    conCap?: SortOrder
    perCap?: SortOrder
    spiCap?: SortOrder
  }

  export type StatModiferSumOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    hp?: SortOrder
    mv?: SortOrder
    ma?: SortOrder
    ac?: SortOrder
    str?: SortOrder
    min?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    per?: SortOrder
    spi?: SortOrder
    hpRegen?: SortOrder
    mvRegen?: SortOrder
    maRegen?: SortOrder
    damroll?: SortOrder
    hitroll?: SortOrder
    mitigation?: SortOrder
    spellDam?: SortOrder
    spellCrit?: SortOrder
    spellRedux?: SortOrder
    concentration?: SortOrder
    shotAccuracy?: SortOrder
    bonusAccuracy?: SortOrder
    ammoCapacity?: SortOrder
    parry?: SortOrder
    strCap?: SortOrder
    minCap?: SortOrder
    dexCap?: SortOrder
    conCap?: SortOrder
    perCap?: SortOrder
    spiCap?: SortOrder
  }

  export type EnumStatModifierTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatModifierType | EnumStatModifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatModifierType[]
    notIn?: $Enums.StatModifierType[]
    not?: NestedEnumStatModifierTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatModifierType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatModifierTypeFilter<$PrismaModel>
    _max?: NestedEnumStatModifierTypeFilter<$PrismaModel>
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    authorId?: SortOrder
    isProtected?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    authorId?: SortOrder
    isProtected?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    authorId?: SortOrder
    isProtected?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type ArticleRelationFilter = {
    is?: ArticleWhereInput
    isNot?: ArticleWhereInput
  }

  export type ArticleVersionCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    modifiedDate?: SortOrder
    editorId?: SortOrder
    content?: SortOrder
    isCurrent?: SortOrder
    version?: SortOrder
  }

  export type ArticleVersionAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    editorId?: SortOrder
  }

  export type ArticleVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    modifiedDate?: SortOrder
    editorId?: SortOrder
    content?: SortOrder
    isCurrent?: SortOrder
    version?: SortOrder
  }

  export type ArticleVersionMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    modifiedDate?: SortOrder
    editorId?: SortOrder
    content?: SortOrder
    isCurrent?: SortOrder
    version?: SortOrder
  }

  export type ArticleVersionSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    editorId?: SortOrder
  }

  export type AppliedTagListRelationFilter = {
    every?: AppliedTagWhereInput
    some?: AppliedTagWhereInput
    none?: AppliedTagWhereInput
  }

  export type AppliedTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    tag?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    tag?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    tag?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[]
    notIn?: $Enums.TagType[]
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ArticleNullableRelationFilter = {
    is?: ArticleWhereInput | null
    isNot?: ArticleWhereInput | null
  }

  export type MobNullableRelationFilter = {
    is?: MobWhereInput | null
    isNot?: MobWhereInput | null
  }

  export type AppliedTagCountOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    sourceId?: SortOrder
    tagId?: SortOrder
  }

  export type AppliedTagAvgOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    tagId?: SortOrder
  }

  export type AppliedTagMaxOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    sourceId?: SortOrder
    tagId?: SortOrder
  }

  export type AppliedTagMinOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    sourceId?: SortOrder
    tagId?: SortOrder
  }

  export type AppliedTagSumOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    tagId?: SortOrder
  }

  export type EnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[]
    notIn?: $Enums.TagType[]
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type AreaNullableRelationFilter = {
    is?: AreaWhereInput | null
    isNot?: AreaWhereInput | null
  }

  export type MobCountOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    areaId?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    level?: SortOrder
    isAggressive?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
  }

  export type MobAvgOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    areaId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
  }

  export type MobMaxOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    areaId?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    level?: SortOrder
    isAggressive?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
  }

  export type MobMinOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    areaId?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    level?: SortOrder
    isAggressive?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
  }

  export type MobSumOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    areaId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
  }

  export type MobListRelationFilter = {
    every?: MobWhereInput
    some?: MobWhereInput
    none?: MobWhereInput
  }

  export type MobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrder
  }

  export type AreaAvgOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    authorId?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    releaseDate?: SortOrder
  }

  export type AreaSumOrderByAggregateInput = {
    id?: SortOrder
    mudId?: SortOrder
    authorId?: SortOrder
  }

  export type ChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    content?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrder
  }

  export type ChangeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type ChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    content?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrder
  }

  export type ChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdDate?: SortOrder
    createdBy?: SortOrder
    content?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrder
  }

  export type ChangeLogSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type AccountNotificationCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountNotificationCreateWithoutAccountInput, AccountNotificationUncheckedCreateWithoutAccountInput> | AccountNotificationCreateWithoutAccountInput[] | AccountNotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountNotificationCreateOrConnectWithoutAccountInput | AccountNotificationCreateOrConnectWithoutAccountInput[]
    createMany?: AccountNotificationCreateManyAccountInputEnvelope
    connect?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
  }

  export type AccountPasswordCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountPasswordCreateWithoutAccountInput, AccountPasswordUncheckedCreateWithoutAccountInput> | AccountPasswordCreateWithoutAccountInput[] | AccountPasswordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountPasswordCreateOrConnectWithoutAccountInput | AccountPasswordCreateOrConnectWithoutAccountInput[]
    createMany?: AccountPasswordCreateManyAccountInputEnvelope
    connect?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
  }

  export type CharacterCreateNestedManyWithoutAccountInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type NetworkHistoryCreateNestedManyWithoutAccountInput = {
    create?: XOR<NetworkHistoryCreateWithoutAccountInput, NetworkHistoryUncheckedCreateWithoutAccountInput> | NetworkHistoryCreateWithoutAccountInput[] | NetworkHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkHistoryCreateOrConnectWithoutAccountInput | NetworkHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: NetworkHistoryCreateManyAccountInputEnvelope
    connect?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
  }

  export type NetworkBlacklistCreateNestedManyWithoutAccountInput = {
    create?: XOR<NetworkBlacklistCreateWithoutAccountInput, NetworkBlacklistUncheckedCreateWithoutAccountInput> | NetworkBlacklistCreateWithoutAccountInput[] | NetworkBlacklistUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutAccountInput | NetworkBlacklistCreateOrConnectWithoutAccountInput[]
    createMany?: NetworkBlacklistCreateManyAccountInputEnvelope
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutAccountInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutCreatedItemsInput = {
    create?: XOR<ItemCreateWithoutCreatedItemsInput, ItemUncheckedCreateWithoutCreatedItemsInput> | ItemCreateWithoutCreatedItemsInput[] | ItemUncheckedCreateWithoutCreatedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCreatedItemsInput | ItemCreateOrConnectWithoutCreatedItemsInput[]
    createMany?: ItemCreateManyCreatedItemsInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutModifiedItemsInput = {
    create?: XOR<ItemCreateWithoutModifiedItemsInput, ItemUncheckedCreateWithoutModifiedItemsInput> | ItemCreateWithoutModifiedItemsInput[] | ItemUncheckedCreateWithoutModifiedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutModifiedItemsInput | ItemCreateOrConnectWithoutModifiedItemsInput[]
    createMany?: ItemCreateManyModifiedItemsInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type SpellCreateNestedManyWithoutCreatedSpellsInput = {
    create?: XOR<SpellCreateWithoutCreatedSpellsInput, SpellUncheckedCreateWithoutCreatedSpellsInput> | SpellCreateWithoutCreatedSpellsInput[] | SpellUncheckedCreateWithoutCreatedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutCreatedSpellsInput | SpellCreateOrConnectWithoutCreatedSpellsInput[]
    createMany?: SpellCreateManyCreatedSpellsInputEnvelope
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type SpellCreateNestedManyWithoutModifiedSpellsInput = {
    create?: XOR<SpellCreateWithoutModifiedSpellsInput, SpellUncheckedCreateWithoutModifiedSpellsInput> | SpellCreateWithoutModifiedSpellsInput[] | SpellUncheckedCreateWithoutModifiedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutModifiedSpellsInput | SpellCreateOrConnectWithoutModifiedSpellsInput[]
    createMany?: SpellCreateManyModifiedSpellsInputEnvelope
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type PotionCreateNestedManyWithoutCreatedPotionsInput = {
    create?: XOR<PotionCreateWithoutCreatedPotionsInput, PotionUncheckedCreateWithoutCreatedPotionsInput> | PotionCreateWithoutCreatedPotionsInput[] | PotionUncheckedCreateWithoutCreatedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutCreatedPotionsInput | PotionCreateOrConnectWithoutCreatedPotionsInput[]
    createMany?: PotionCreateManyCreatedPotionsInputEnvelope
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
  }

  export type PotionCreateNestedManyWithoutModifiedPotionsInput = {
    create?: XOR<PotionCreateWithoutModifiedPotionsInput, PotionUncheckedCreateWithoutModifiedPotionsInput> | PotionCreateWithoutModifiedPotionsInput[] | PotionUncheckedCreateWithoutModifiedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutModifiedPotionsInput | PotionCreateOrConnectWithoutModifiedPotionsInput[]
    createMany?: PotionCreateManyModifiedPotionsInputEnvelope
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
  }

  export type SkillCreateNestedManyWithoutCreatedSkillsInput = {
    create?: XOR<SkillCreateWithoutCreatedSkillsInput, SkillUncheckedCreateWithoutCreatedSkillsInput> | SkillCreateWithoutCreatedSkillsInput[] | SkillUncheckedCreateWithoutCreatedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCreatedSkillsInput | SkillCreateOrConnectWithoutCreatedSkillsInput[]
    createMany?: SkillCreateManyCreatedSkillsInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type SkillCreateNestedManyWithoutModifiedSkillsInput = {
    create?: XOR<SkillCreateWithoutModifiedSkillsInput, SkillUncheckedCreateWithoutModifiedSkillsInput> | SkillCreateWithoutModifiedSkillsInput[] | SkillUncheckedCreateWithoutModifiedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutModifiedSkillsInput | SkillCreateOrConnectWithoutModifiedSkillsInput[]
    createMany?: SkillCreateManyModifiedSkillsInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type AbilityCreateNestedManyWithoutCreatedAbilitiesInput = {
    create?: XOR<AbilityCreateWithoutCreatedAbilitiesInput, AbilityUncheckedCreateWithoutCreatedAbilitiesInput> | AbilityCreateWithoutCreatedAbilitiesInput[] | AbilityUncheckedCreateWithoutCreatedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutCreatedAbilitiesInput | AbilityCreateOrConnectWithoutCreatedAbilitiesInput[]
    createMany?: AbilityCreateManyCreatedAbilitiesInputEnvelope
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
  }

  export type AbilityCreateNestedManyWithoutModifiedAbilitiesInput = {
    create?: XOR<AbilityCreateWithoutModifiedAbilitiesInput, AbilityUncheckedCreateWithoutModifiedAbilitiesInput> | AbilityCreateWithoutModifiedAbilitiesInput[] | AbilityUncheckedCreateWithoutModifiedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutModifiedAbilitiesInput | AbilityCreateOrConnectWithoutModifiedAbilitiesInput[]
    createMany?: AbilityCreateManyModifiedAbilitiesInputEnvelope
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
  }

  export type QuestCreateNestedManyWithoutCreatedQuestsInput = {
    create?: XOR<QuestCreateWithoutCreatedQuestsInput, QuestUncheckedCreateWithoutCreatedQuestsInput> | QuestCreateWithoutCreatedQuestsInput[] | QuestUncheckedCreateWithoutCreatedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCreatedQuestsInput | QuestCreateOrConnectWithoutCreatedQuestsInput[]
    createMany?: QuestCreateManyCreatedQuestsInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type QuestCreateNestedManyWithoutModifiedQuestsInput = {
    create?: XOR<QuestCreateWithoutModifiedQuestsInput, QuestUncheckedCreateWithoutModifiedQuestsInput> | QuestCreateWithoutModifiedQuestsInput[] | QuestUncheckedCreateWithoutModifiedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutModifiedQuestsInput | QuestCreateOrConnectWithoutModifiedQuestsInput[]
    createMany?: QuestCreateManyModifiedQuestsInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ArticleVersionCreateNestedManyWithoutEditorInput = {
    create?: XOR<ArticleVersionCreateWithoutEditorInput, ArticleVersionUncheckedCreateWithoutEditorInput> | ArticleVersionCreateWithoutEditorInput[] | ArticleVersionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutEditorInput | ArticleVersionCreateOrConnectWithoutEditorInput[]
    createMany?: ArticleVersionCreateManyEditorInputEnvelope
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TagCreateWithoutCreatorInput, TagUncheckedCreateWithoutCreatorInput> | TagCreateWithoutCreatorInput[] | TagUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCreatorInput | TagCreateOrConnectWithoutCreatorInput[]
    createMany?: TagCreateManyCreatorInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type AreaCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AreaCreateWithoutAuthorInput, AreaUncheckedCreateWithoutAuthorInput> | AreaCreateWithoutAuthorInput[] | AreaUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutAuthorInput | AreaCreateOrConnectWithoutAuthorInput[]
    createMany?: AreaCreateManyAuthorInputEnvelope
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type ChangeLogCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ChangeLogCreateWithoutCreatorInput, ChangeLogUncheckedCreateWithoutCreatorInput> | ChangeLogCreateWithoutCreatorInput[] | ChangeLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutCreatorInput | ChangeLogCreateOrConnectWithoutCreatorInput[]
    createMany?: ChangeLogCreateManyCreatorInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type AccountNotificationUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountNotificationCreateWithoutAccountInput, AccountNotificationUncheckedCreateWithoutAccountInput> | AccountNotificationCreateWithoutAccountInput[] | AccountNotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountNotificationCreateOrConnectWithoutAccountInput | AccountNotificationCreateOrConnectWithoutAccountInput[]
    createMany?: AccountNotificationCreateManyAccountInputEnvelope
    connect?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
  }

  export type AccountPasswordUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountPasswordCreateWithoutAccountInput, AccountPasswordUncheckedCreateWithoutAccountInput> | AccountPasswordCreateWithoutAccountInput[] | AccountPasswordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountPasswordCreateOrConnectWithoutAccountInput | AccountPasswordCreateOrConnectWithoutAccountInput[]
    createMany?: AccountPasswordCreateManyAccountInputEnvelope
    connect?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<NetworkHistoryCreateWithoutAccountInput, NetworkHistoryUncheckedCreateWithoutAccountInput> | NetworkHistoryCreateWithoutAccountInput[] | NetworkHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkHistoryCreateOrConnectWithoutAccountInput | NetworkHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: NetworkHistoryCreateManyAccountInputEnvelope
    connect?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
  }

  export type NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<NetworkBlacklistCreateWithoutAccountInput, NetworkBlacklistUncheckedCreateWithoutAccountInput> | NetworkBlacklistCreateWithoutAccountInput[] | NetworkBlacklistUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutAccountInput | NetworkBlacklistCreateOrConnectWithoutAccountInput[]
    createMany?: NetworkBlacklistCreateManyAccountInputEnvelope
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutCreatedItemsInput = {
    create?: XOR<ItemCreateWithoutCreatedItemsInput, ItemUncheckedCreateWithoutCreatedItemsInput> | ItemCreateWithoutCreatedItemsInput[] | ItemUncheckedCreateWithoutCreatedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCreatedItemsInput | ItemCreateOrConnectWithoutCreatedItemsInput[]
    createMany?: ItemCreateManyCreatedItemsInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutModifiedItemsInput = {
    create?: XOR<ItemCreateWithoutModifiedItemsInput, ItemUncheckedCreateWithoutModifiedItemsInput> | ItemCreateWithoutModifiedItemsInput[] | ItemUncheckedCreateWithoutModifiedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutModifiedItemsInput | ItemCreateOrConnectWithoutModifiedItemsInput[]
    createMany?: ItemCreateManyModifiedItemsInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput = {
    create?: XOR<SpellCreateWithoutCreatedSpellsInput, SpellUncheckedCreateWithoutCreatedSpellsInput> | SpellCreateWithoutCreatedSpellsInput[] | SpellUncheckedCreateWithoutCreatedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutCreatedSpellsInput | SpellCreateOrConnectWithoutCreatedSpellsInput[]
    createMany?: SpellCreateManyCreatedSpellsInputEnvelope
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput = {
    create?: XOR<SpellCreateWithoutModifiedSpellsInput, SpellUncheckedCreateWithoutModifiedSpellsInput> | SpellCreateWithoutModifiedSpellsInput[] | SpellUncheckedCreateWithoutModifiedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutModifiedSpellsInput | SpellCreateOrConnectWithoutModifiedSpellsInput[]
    createMany?: SpellCreateManyModifiedSpellsInputEnvelope
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput = {
    create?: XOR<PotionCreateWithoutCreatedPotionsInput, PotionUncheckedCreateWithoutCreatedPotionsInput> | PotionCreateWithoutCreatedPotionsInput[] | PotionUncheckedCreateWithoutCreatedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutCreatedPotionsInput | PotionCreateOrConnectWithoutCreatedPotionsInput[]
    createMany?: PotionCreateManyCreatedPotionsInputEnvelope
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
  }

  export type PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput = {
    create?: XOR<PotionCreateWithoutModifiedPotionsInput, PotionUncheckedCreateWithoutModifiedPotionsInput> | PotionCreateWithoutModifiedPotionsInput[] | PotionUncheckedCreateWithoutModifiedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutModifiedPotionsInput | PotionCreateOrConnectWithoutModifiedPotionsInput[]
    createMany?: PotionCreateManyModifiedPotionsInputEnvelope
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput = {
    create?: XOR<SkillCreateWithoutCreatedSkillsInput, SkillUncheckedCreateWithoutCreatedSkillsInput> | SkillCreateWithoutCreatedSkillsInput[] | SkillUncheckedCreateWithoutCreatedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCreatedSkillsInput | SkillCreateOrConnectWithoutCreatedSkillsInput[]
    createMany?: SkillCreateManyCreatedSkillsInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput = {
    create?: XOR<SkillCreateWithoutModifiedSkillsInput, SkillUncheckedCreateWithoutModifiedSkillsInput> | SkillCreateWithoutModifiedSkillsInput[] | SkillUncheckedCreateWithoutModifiedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutModifiedSkillsInput | SkillCreateOrConnectWithoutModifiedSkillsInput[]
    createMany?: SkillCreateManyModifiedSkillsInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput = {
    create?: XOR<AbilityCreateWithoutCreatedAbilitiesInput, AbilityUncheckedCreateWithoutCreatedAbilitiesInput> | AbilityCreateWithoutCreatedAbilitiesInput[] | AbilityUncheckedCreateWithoutCreatedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutCreatedAbilitiesInput | AbilityCreateOrConnectWithoutCreatedAbilitiesInput[]
    createMany?: AbilityCreateManyCreatedAbilitiesInputEnvelope
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
  }

  export type AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput = {
    create?: XOR<AbilityCreateWithoutModifiedAbilitiesInput, AbilityUncheckedCreateWithoutModifiedAbilitiesInput> | AbilityCreateWithoutModifiedAbilitiesInput[] | AbilityUncheckedCreateWithoutModifiedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutModifiedAbilitiesInput | AbilityCreateOrConnectWithoutModifiedAbilitiesInput[]
    createMany?: AbilityCreateManyModifiedAbilitiesInputEnvelope
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput = {
    create?: XOR<QuestCreateWithoutCreatedQuestsInput, QuestUncheckedCreateWithoutCreatedQuestsInput> | QuestCreateWithoutCreatedQuestsInput[] | QuestUncheckedCreateWithoutCreatedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCreatedQuestsInput | QuestCreateOrConnectWithoutCreatedQuestsInput[]
    createMany?: QuestCreateManyCreatedQuestsInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput = {
    create?: XOR<QuestCreateWithoutModifiedQuestsInput, QuestUncheckedCreateWithoutModifiedQuestsInput> | QuestCreateWithoutModifiedQuestsInput[] | QuestUncheckedCreateWithoutModifiedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutModifiedQuestsInput | QuestCreateOrConnectWithoutModifiedQuestsInput[]
    createMany?: QuestCreateManyModifiedQuestsInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ArticleVersionUncheckedCreateNestedManyWithoutEditorInput = {
    create?: XOR<ArticleVersionCreateWithoutEditorInput, ArticleVersionUncheckedCreateWithoutEditorInput> | ArticleVersionCreateWithoutEditorInput[] | ArticleVersionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutEditorInput | ArticleVersionCreateOrConnectWithoutEditorInput[]
    createMany?: ArticleVersionCreateManyEditorInputEnvelope
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TagCreateWithoutCreatorInput, TagUncheckedCreateWithoutCreatorInput> | TagCreateWithoutCreatorInput[] | TagUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCreatorInput | TagCreateOrConnectWithoutCreatorInput[]
    createMany?: TagCreateManyCreatorInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type AreaUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AreaCreateWithoutAuthorInput, AreaUncheckedCreateWithoutAuthorInput> | AreaCreateWithoutAuthorInput[] | AreaUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutAuthorInput | AreaCreateOrConnectWithoutAuthorInput[]
    createMany?: AreaCreateManyAuthorInputEnvelope
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type ChangeLogUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ChangeLogCreateWithoutCreatorInput, ChangeLogUncheckedCreateWithoutCreatorInput> | ChangeLogCreateWithoutCreatorInput[] | ChangeLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutCreatorInput | ChangeLogCreateOrConnectWithoutCreatorInput[]
    createMany?: ChangeLogCreateManyCreatorInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AccountNotificationUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountNotificationCreateWithoutAccountInput, AccountNotificationUncheckedCreateWithoutAccountInput> | AccountNotificationCreateWithoutAccountInput[] | AccountNotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountNotificationCreateOrConnectWithoutAccountInput | AccountNotificationCreateOrConnectWithoutAccountInput[]
    upsert?: AccountNotificationUpsertWithWhereUniqueWithoutAccountInput | AccountNotificationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountNotificationCreateManyAccountInputEnvelope
    set?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    disconnect?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    delete?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    connect?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    update?: AccountNotificationUpdateWithWhereUniqueWithoutAccountInput | AccountNotificationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountNotificationUpdateManyWithWhereWithoutAccountInput | AccountNotificationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountNotificationScalarWhereInput | AccountNotificationScalarWhereInput[]
  }

  export type AccountPasswordUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountPasswordCreateWithoutAccountInput, AccountPasswordUncheckedCreateWithoutAccountInput> | AccountPasswordCreateWithoutAccountInput[] | AccountPasswordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountPasswordCreateOrConnectWithoutAccountInput | AccountPasswordCreateOrConnectWithoutAccountInput[]
    upsert?: AccountPasswordUpsertWithWhereUniqueWithoutAccountInput | AccountPasswordUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountPasswordCreateManyAccountInputEnvelope
    set?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    disconnect?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    delete?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    connect?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    update?: AccountPasswordUpdateWithWhereUniqueWithoutAccountInput | AccountPasswordUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountPasswordUpdateManyWithWhereWithoutAccountInput | AccountPasswordUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountPasswordScalarWhereInput | AccountPasswordScalarWhereInput[]
  }

  export type CharacterUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAccountInput | CharacterUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAccountInput | CharacterUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAccountInput | CharacterUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type NetworkHistoryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NetworkHistoryCreateWithoutAccountInput, NetworkHistoryUncheckedCreateWithoutAccountInput> | NetworkHistoryCreateWithoutAccountInput[] | NetworkHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkHistoryCreateOrConnectWithoutAccountInput | NetworkHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: NetworkHistoryUpsertWithWhereUniqueWithoutAccountInput | NetworkHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NetworkHistoryCreateManyAccountInputEnvelope
    set?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    disconnect?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    delete?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    connect?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    update?: NetworkHistoryUpdateWithWhereUniqueWithoutAccountInput | NetworkHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NetworkHistoryUpdateManyWithWhereWithoutAccountInput | NetworkHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NetworkHistoryScalarWhereInput | NetworkHistoryScalarWhereInput[]
  }

  export type NetworkBlacklistUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NetworkBlacklistCreateWithoutAccountInput, NetworkBlacklistUncheckedCreateWithoutAccountInput> | NetworkBlacklistCreateWithoutAccountInput[] | NetworkBlacklistUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutAccountInput | NetworkBlacklistCreateOrConnectWithoutAccountInput[]
    upsert?: NetworkBlacklistUpsertWithWhereUniqueWithoutAccountInput | NetworkBlacklistUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NetworkBlacklistCreateManyAccountInputEnvelope
    set?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    disconnect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    delete?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    update?: NetworkBlacklistUpdateWithWhereUniqueWithoutAccountInput | NetworkBlacklistUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NetworkBlacklistUpdateManyWithWhereWithoutAccountInput | NetworkBlacklistUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NetworkBlacklistScalarWhereInput | NetworkBlacklistScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAccountInput | NotificationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAccountInput | NotificationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAccountInput | NotificationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutCreatedItemsNestedInput = {
    create?: XOR<ItemCreateWithoutCreatedItemsInput, ItemUncheckedCreateWithoutCreatedItemsInput> | ItemCreateWithoutCreatedItemsInput[] | ItemUncheckedCreateWithoutCreatedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCreatedItemsInput | ItemCreateOrConnectWithoutCreatedItemsInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCreatedItemsInput | ItemUpsertWithWhereUniqueWithoutCreatedItemsInput[]
    createMany?: ItemCreateManyCreatedItemsInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCreatedItemsInput | ItemUpdateWithWhereUniqueWithoutCreatedItemsInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCreatedItemsInput | ItemUpdateManyWithWhereWithoutCreatedItemsInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutModifiedItemsNestedInput = {
    create?: XOR<ItemCreateWithoutModifiedItemsInput, ItemUncheckedCreateWithoutModifiedItemsInput> | ItemCreateWithoutModifiedItemsInput[] | ItemUncheckedCreateWithoutModifiedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutModifiedItemsInput | ItemCreateOrConnectWithoutModifiedItemsInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutModifiedItemsInput | ItemUpsertWithWhereUniqueWithoutModifiedItemsInput[]
    createMany?: ItemCreateManyModifiedItemsInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutModifiedItemsInput | ItemUpdateWithWhereUniqueWithoutModifiedItemsInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutModifiedItemsInput | ItemUpdateManyWithWhereWithoutModifiedItemsInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type SpellUpdateManyWithoutCreatedSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutCreatedSpellsInput, SpellUncheckedCreateWithoutCreatedSpellsInput> | SpellCreateWithoutCreatedSpellsInput[] | SpellUncheckedCreateWithoutCreatedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutCreatedSpellsInput | SpellCreateOrConnectWithoutCreatedSpellsInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutCreatedSpellsInput | SpellUpsertWithWhereUniqueWithoutCreatedSpellsInput[]
    createMany?: SpellCreateManyCreatedSpellsInputEnvelope
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutCreatedSpellsInput | SpellUpdateWithWhereUniqueWithoutCreatedSpellsInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutCreatedSpellsInput | SpellUpdateManyWithWhereWithoutCreatedSpellsInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type SpellUpdateManyWithoutModifiedSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutModifiedSpellsInput, SpellUncheckedCreateWithoutModifiedSpellsInput> | SpellCreateWithoutModifiedSpellsInput[] | SpellUncheckedCreateWithoutModifiedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutModifiedSpellsInput | SpellCreateOrConnectWithoutModifiedSpellsInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutModifiedSpellsInput | SpellUpsertWithWhereUniqueWithoutModifiedSpellsInput[]
    createMany?: SpellCreateManyModifiedSpellsInputEnvelope
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutModifiedSpellsInput | SpellUpdateWithWhereUniqueWithoutModifiedSpellsInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutModifiedSpellsInput | SpellUpdateManyWithWhereWithoutModifiedSpellsInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type PotionUpdateManyWithoutCreatedPotionsNestedInput = {
    create?: XOR<PotionCreateWithoutCreatedPotionsInput, PotionUncheckedCreateWithoutCreatedPotionsInput> | PotionCreateWithoutCreatedPotionsInput[] | PotionUncheckedCreateWithoutCreatedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutCreatedPotionsInput | PotionCreateOrConnectWithoutCreatedPotionsInput[]
    upsert?: PotionUpsertWithWhereUniqueWithoutCreatedPotionsInput | PotionUpsertWithWhereUniqueWithoutCreatedPotionsInput[]
    createMany?: PotionCreateManyCreatedPotionsInputEnvelope
    set?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    disconnect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    delete?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    update?: PotionUpdateWithWhereUniqueWithoutCreatedPotionsInput | PotionUpdateWithWhereUniqueWithoutCreatedPotionsInput[]
    updateMany?: PotionUpdateManyWithWhereWithoutCreatedPotionsInput | PotionUpdateManyWithWhereWithoutCreatedPotionsInput[]
    deleteMany?: PotionScalarWhereInput | PotionScalarWhereInput[]
  }

  export type PotionUpdateManyWithoutModifiedPotionsNestedInput = {
    create?: XOR<PotionCreateWithoutModifiedPotionsInput, PotionUncheckedCreateWithoutModifiedPotionsInput> | PotionCreateWithoutModifiedPotionsInput[] | PotionUncheckedCreateWithoutModifiedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutModifiedPotionsInput | PotionCreateOrConnectWithoutModifiedPotionsInput[]
    upsert?: PotionUpsertWithWhereUniqueWithoutModifiedPotionsInput | PotionUpsertWithWhereUniqueWithoutModifiedPotionsInput[]
    createMany?: PotionCreateManyModifiedPotionsInputEnvelope
    set?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    disconnect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    delete?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    update?: PotionUpdateWithWhereUniqueWithoutModifiedPotionsInput | PotionUpdateWithWhereUniqueWithoutModifiedPotionsInput[]
    updateMany?: PotionUpdateManyWithWhereWithoutModifiedPotionsInput | PotionUpdateManyWithWhereWithoutModifiedPotionsInput[]
    deleteMany?: PotionScalarWhereInput | PotionScalarWhereInput[]
  }

  export type SkillUpdateManyWithoutCreatedSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutCreatedSkillsInput, SkillUncheckedCreateWithoutCreatedSkillsInput> | SkillCreateWithoutCreatedSkillsInput[] | SkillUncheckedCreateWithoutCreatedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCreatedSkillsInput | SkillCreateOrConnectWithoutCreatedSkillsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutCreatedSkillsInput | SkillUpsertWithWhereUniqueWithoutCreatedSkillsInput[]
    createMany?: SkillCreateManyCreatedSkillsInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutCreatedSkillsInput | SkillUpdateWithWhereUniqueWithoutCreatedSkillsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutCreatedSkillsInput | SkillUpdateManyWithWhereWithoutCreatedSkillsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type SkillUpdateManyWithoutModifiedSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutModifiedSkillsInput, SkillUncheckedCreateWithoutModifiedSkillsInput> | SkillCreateWithoutModifiedSkillsInput[] | SkillUncheckedCreateWithoutModifiedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutModifiedSkillsInput | SkillCreateOrConnectWithoutModifiedSkillsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutModifiedSkillsInput | SkillUpsertWithWhereUniqueWithoutModifiedSkillsInput[]
    createMany?: SkillCreateManyModifiedSkillsInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutModifiedSkillsInput | SkillUpdateWithWhereUniqueWithoutModifiedSkillsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutModifiedSkillsInput | SkillUpdateManyWithWhereWithoutModifiedSkillsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type AbilityUpdateManyWithoutCreatedAbilitiesNestedInput = {
    create?: XOR<AbilityCreateWithoutCreatedAbilitiesInput, AbilityUncheckedCreateWithoutCreatedAbilitiesInput> | AbilityCreateWithoutCreatedAbilitiesInput[] | AbilityUncheckedCreateWithoutCreatedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutCreatedAbilitiesInput | AbilityCreateOrConnectWithoutCreatedAbilitiesInput[]
    upsert?: AbilityUpsertWithWhereUniqueWithoutCreatedAbilitiesInput | AbilityUpsertWithWhereUniqueWithoutCreatedAbilitiesInput[]
    createMany?: AbilityCreateManyCreatedAbilitiesInputEnvelope
    set?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    disconnect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    delete?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    update?: AbilityUpdateWithWhereUniqueWithoutCreatedAbilitiesInput | AbilityUpdateWithWhereUniqueWithoutCreatedAbilitiesInput[]
    updateMany?: AbilityUpdateManyWithWhereWithoutCreatedAbilitiesInput | AbilityUpdateManyWithWhereWithoutCreatedAbilitiesInput[]
    deleteMany?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
  }

  export type AbilityUpdateManyWithoutModifiedAbilitiesNestedInput = {
    create?: XOR<AbilityCreateWithoutModifiedAbilitiesInput, AbilityUncheckedCreateWithoutModifiedAbilitiesInput> | AbilityCreateWithoutModifiedAbilitiesInput[] | AbilityUncheckedCreateWithoutModifiedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutModifiedAbilitiesInput | AbilityCreateOrConnectWithoutModifiedAbilitiesInput[]
    upsert?: AbilityUpsertWithWhereUniqueWithoutModifiedAbilitiesInput | AbilityUpsertWithWhereUniqueWithoutModifiedAbilitiesInput[]
    createMany?: AbilityCreateManyModifiedAbilitiesInputEnvelope
    set?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    disconnect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    delete?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    update?: AbilityUpdateWithWhereUniqueWithoutModifiedAbilitiesInput | AbilityUpdateWithWhereUniqueWithoutModifiedAbilitiesInput[]
    updateMany?: AbilityUpdateManyWithWhereWithoutModifiedAbilitiesInput | AbilityUpdateManyWithWhereWithoutModifiedAbilitiesInput[]
    deleteMany?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
  }

  export type QuestUpdateManyWithoutCreatedQuestsNestedInput = {
    create?: XOR<QuestCreateWithoutCreatedQuestsInput, QuestUncheckedCreateWithoutCreatedQuestsInput> | QuestCreateWithoutCreatedQuestsInput[] | QuestUncheckedCreateWithoutCreatedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCreatedQuestsInput | QuestCreateOrConnectWithoutCreatedQuestsInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutCreatedQuestsInput | QuestUpsertWithWhereUniqueWithoutCreatedQuestsInput[]
    createMany?: QuestCreateManyCreatedQuestsInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutCreatedQuestsInput | QuestUpdateWithWhereUniqueWithoutCreatedQuestsInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutCreatedQuestsInput | QuestUpdateManyWithWhereWithoutCreatedQuestsInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type QuestUpdateManyWithoutModifiedQuestsNestedInput = {
    create?: XOR<QuestCreateWithoutModifiedQuestsInput, QuestUncheckedCreateWithoutModifiedQuestsInput> | QuestCreateWithoutModifiedQuestsInput[] | QuestUncheckedCreateWithoutModifiedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutModifiedQuestsInput | QuestCreateOrConnectWithoutModifiedQuestsInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutModifiedQuestsInput | QuestUpsertWithWhereUniqueWithoutModifiedQuestsInput[]
    createMany?: QuestCreateManyModifiedQuestsInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutModifiedQuestsInput | QuestUpdateWithWhereUniqueWithoutModifiedQuestsInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutModifiedQuestsInput | QuestUpdateManyWithWhereWithoutModifiedQuestsInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutAuthorInput | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutAuthorInput | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutAuthorInput | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ArticleVersionUpdateManyWithoutEditorNestedInput = {
    create?: XOR<ArticleVersionCreateWithoutEditorInput, ArticleVersionUncheckedCreateWithoutEditorInput> | ArticleVersionCreateWithoutEditorInput[] | ArticleVersionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutEditorInput | ArticleVersionCreateOrConnectWithoutEditorInput[]
    upsert?: ArticleVersionUpsertWithWhereUniqueWithoutEditorInput | ArticleVersionUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: ArticleVersionCreateManyEditorInputEnvelope
    set?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    disconnect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    delete?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    update?: ArticleVersionUpdateWithWhereUniqueWithoutEditorInput | ArticleVersionUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: ArticleVersionUpdateManyWithWhereWithoutEditorInput | ArticleVersionUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TagCreateWithoutCreatorInput, TagUncheckedCreateWithoutCreatorInput> | TagCreateWithoutCreatorInput[] | TagUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCreatorInput | TagCreateOrConnectWithoutCreatorInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCreatorInput | TagUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TagCreateManyCreatorInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCreatorInput | TagUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCreatorInput | TagUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type AreaUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AreaCreateWithoutAuthorInput, AreaUncheckedCreateWithoutAuthorInput> | AreaCreateWithoutAuthorInput[] | AreaUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutAuthorInput | AreaCreateOrConnectWithoutAuthorInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutAuthorInput | AreaUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AreaCreateManyAuthorInputEnvelope
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutAuthorInput | AreaUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutAuthorInput | AreaUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type ChangeLogUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ChangeLogCreateWithoutCreatorInput, ChangeLogUncheckedCreateWithoutCreatorInput> | ChangeLogCreateWithoutCreatorInput[] | ChangeLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutCreatorInput | ChangeLogCreateOrConnectWithoutCreatorInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutCreatorInput | ChangeLogUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ChangeLogCreateManyCreatorInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutCreatorInput | ChangeLogUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutCreatorInput | ChangeLogUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountNotificationCreateWithoutAccountInput, AccountNotificationUncheckedCreateWithoutAccountInput> | AccountNotificationCreateWithoutAccountInput[] | AccountNotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountNotificationCreateOrConnectWithoutAccountInput | AccountNotificationCreateOrConnectWithoutAccountInput[]
    upsert?: AccountNotificationUpsertWithWhereUniqueWithoutAccountInput | AccountNotificationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountNotificationCreateManyAccountInputEnvelope
    set?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    disconnect?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    delete?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    connect?: AccountNotificationWhereUniqueInput | AccountNotificationWhereUniqueInput[]
    update?: AccountNotificationUpdateWithWhereUniqueWithoutAccountInput | AccountNotificationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountNotificationUpdateManyWithWhereWithoutAccountInput | AccountNotificationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountNotificationScalarWhereInput | AccountNotificationScalarWhereInput[]
  }

  export type AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountPasswordCreateWithoutAccountInput, AccountPasswordUncheckedCreateWithoutAccountInput> | AccountPasswordCreateWithoutAccountInput[] | AccountPasswordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountPasswordCreateOrConnectWithoutAccountInput | AccountPasswordCreateOrConnectWithoutAccountInput[]
    upsert?: AccountPasswordUpsertWithWhereUniqueWithoutAccountInput | AccountPasswordUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountPasswordCreateManyAccountInputEnvelope
    set?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    disconnect?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    delete?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    connect?: AccountPasswordWhereUniqueInput | AccountPasswordWhereUniqueInput[]
    update?: AccountPasswordUpdateWithWhereUniqueWithoutAccountInput | AccountPasswordUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountPasswordUpdateManyWithWhereWithoutAccountInput | AccountPasswordUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountPasswordScalarWhereInput | AccountPasswordScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAccountInput | CharacterUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAccountInput | CharacterUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAccountInput | CharacterUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NetworkHistoryCreateWithoutAccountInput, NetworkHistoryUncheckedCreateWithoutAccountInput> | NetworkHistoryCreateWithoutAccountInput[] | NetworkHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkHistoryCreateOrConnectWithoutAccountInput | NetworkHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: NetworkHistoryUpsertWithWhereUniqueWithoutAccountInput | NetworkHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NetworkHistoryCreateManyAccountInputEnvelope
    set?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    disconnect?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    delete?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    connect?: NetworkHistoryWhereUniqueInput | NetworkHistoryWhereUniqueInput[]
    update?: NetworkHistoryUpdateWithWhereUniqueWithoutAccountInput | NetworkHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NetworkHistoryUpdateManyWithWhereWithoutAccountInput | NetworkHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NetworkHistoryScalarWhereInput | NetworkHistoryScalarWhereInput[]
  }

  export type NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NetworkBlacklistCreateWithoutAccountInput, NetworkBlacklistUncheckedCreateWithoutAccountInput> | NetworkBlacklistCreateWithoutAccountInput[] | NetworkBlacklistUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutAccountInput | NetworkBlacklistCreateOrConnectWithoutAccountInput[]
    upsert?: NetworkBlacklistUpsertWithWhereUniqueWithoutAccountInput | NetworkBlacklistUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NetworkBlacklistCreateManyAccountInputEnvelope
    set?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    disconnect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    delete?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    update?: NetworkBlacklistUpdateWithWhereUniqueWithoutAccountInput | NetworkBlacklistUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NetworkBlacklistUpdateManyWithWhereWithoutAccountInput | NetworkBlacklistUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NetworkBlacklistScalarWhereInput | NetworkBlacklistScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput> | NotificationCreateWithoutAccountInput[] | NotificationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAccountInput | NotificationCreateOrConnectWithoutAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAccountInput | NotificationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NotificationCreateManyAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAccountInput | NotificationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAccountInput | NotificationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput = {
    create?: XOR<ItemCreateWithoutCreatedItemsInput, ItemUncheckedCreateWithoutCreatedItemsInput> | ItemCreateWithoutCreatedItemsInput[] | ItemUncheckedCreateWithoutCreatedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCreatedItemsInput | ItemCreateOrConnectWithoutCreatedItemsInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCreatedItemsInput | ItemUpsertWithWhereUniqueWithoutCreatedItemsInput[]
    createMany?: ItemCreateManyCreatedItemsInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCreatedItemsInput | ItemUpdateWithWhereUniqueWithoutCreatedItemsInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCreatedItemsInput | ItemUpdateManyWithWhereWithoutCreatedItemsInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput = {
    create?: XOR<ItemCreateWithoutModifiedItemsInput, ItemUncheckedCreateWithoutModifiedItemsInput> | ItemCreateWithoutModifiedItemsInput[] | ItemUncheckedCreateWithoutModifiedItemsInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutModifiedItemsInput | ItemCreateOrConnectWithoutModifiedItemsInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutModifiedItemsInput | ItemUpsertWithWhereUniqueWithoutModifiedItemsInput[]
    createMany?: ItemCreateManyModifiedItemsInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutModifiedItemsInput | ItemUpdateWithWhereUniqueWithoutModifiedItemsInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutModifiedItemsInput | ItemUpdateManyWithWhereWithoutModifiedItemsInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutCreatedSpellsInput, SpellUncheckedCreateWithoutCreatedSpellsInput> | SpellCreateWithoutCreatedSpellsInput[] | SpellUncheckedCreateWithoutCreatedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutCreatedSpellsInput | SpellCreateOrConnectWithoutCreatedSpellsInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutCreatedSpellsInput | SpellUpsertWithWhereUniqueWithoutCreatedSpellsInput[]
    createMany?: SpellCreateManyCreatedSpellsInputEnvelope
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutCreatedSpellsInput | SpellUpdateWithWhereUniqueWithoutCreatedSpellsInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutCreatedSpellsInput | SpellUpdateManyWithWhereWithoutCreatedSpellsInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutModifiedSpellsInput, SpellUncheckedCreateWithoutModifiedSpellsInput> | SpellCreateWithoutModifiedSpellsInput[] | SpellUncheckedCreateWithoutModifiedSpellsInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutModifiedSpellsInput | SpellCreateOrConnectWithoutModifiedSpellsInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutModifiedSpellsInput | SpellUpsertWithWhereUniqueWithoutModifiedSpellsInput[]
    createMany?: SpellCreateManyModifiedSpellsInputEnvelope
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutModifiedSpellsInput | SpellUpdateWithWhereUniqueWithoutModifiedSpellsInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutModifiedSpellsInput | SpellUpdateManyWithWhereWithoutModifiedSpellsInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput = {
    create?: XOR<PotionCreateWithoutCreatedPotionsInput, PotionUncheckedCreateWithoutCreatedPotionsInput> | PotionCreateWithoutCreatedPotionsInput[] | PotionUncheckedCreateWithoutCreatedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutCreatedPotionsInput | PotionCreateOrConnectWithoutCreatedPotionsInput[]
    upsert?: PotionUpsertWithWhereUniqueWithoutCreatedPotionsInput | PotionUpsertWithWhereUniqueWithoutCreatedPotionsInput[]
    createMany?: PotionCreateManyCreatedPotionsInputEnvelope
    set?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    disconnect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    delete?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    update?: PotionUpdateWithWhereUniqueWithoutCreatedPotionsInput | PotionUpdateWithWhereUniqueWithoutCreatedPotionsInput[]
    updateMany?: PotionUpdateManyWithWhereWithoutCreatedPotionsInput | PotionUpdateManyWithWhereWithoutCreatedPotionsInput[]
    deleteMany?: PotionScalarWhereInput | PotionScalarWhereInput[]
  }

  export type PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput = {
    create?: XOR<PotionCreateWithoutModifiedPotionsInput, PotionUncheckedCreateWithoutModifiedPotionsInput> | PotionCreateWithoutModifiedPotionsInput[] | PotionUncheckedCreateWithoutModifiedPotionsInput[]
    connectOrCreate?: PotionCreateOrConnectWithoutModifiedPotionsInput | PotionCreateOrConnectWithoutModifiedPotionsInput[]
    upsert?: PotionUpsertWithWhereUniqueWithoutModifiedPotionsInput | PotionUpsertWithWhereUniqueWithoutModifiedPotionsInput[]
    createMany?: PotionCreateManyModifiedPotionsInputEnvelope
    set?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    disconnect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    delete?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    connect?: PotionWhereUniqueInput | PotionWhereUniqueInput[]
    update?: PotionUpdateWithWhereUniqueWithoutModifiedPotionsInput | PotionUpdateWithWhereUniqueWithoutModifiedPotionsInput[]
    updateMany?: PotionUpdateManyWithWhereWithoutModifiedPotionsInput | PotionUpdateManyWithWhereWithoutModifiedPotionsInput[]
    deleteMany?: PotionScalarWhereInput | PotionScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutCreatedSkillsInput, SkillUncheckedCreateWithoutCreatedSkillsInput> | SkillCreateWithoutCreatedSkillsInput[] | SkillUncheckedCreateWithoutCreatedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCreatedSkillsInput | SkillCreateOrConnectWithoutCreatedSkillsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutCreatedSkillsInput | SkillUpsertWithWhereUniqueWithoutCreatedSkillsInput[]
    createMany?: SkillCreateManyCreatedSkillsInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutCreatedSkillsInput | SkillUpdateWithWhereUniqueWithoutCreatedSkillsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutCreatedSkillsInput | SkillUpdateManyWithWhereWithoutCreatedSkillsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutModifiedSkillsInput, SkillUncheckedCreateWithoutModifiedSkillsInput> | SkillCreateWithoutModifiedSkillsInput[] | SkillUncheckedCreateWithoutModifiedSkillsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutModifiedSkillsInput | SkillCreateOrConnectWithoutModifiedSkillsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutModifiedSkillsInput | SkillUpsertWithWhereUniqueWithoutModifiedSkillsInput[]
    createMany?: SkillCreateManyModifiedSkillsInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutModifiedSkillsInput | SkillUpdateWithWhereUniqueWithoutModifiedSkillsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutModifiedSkillsInput | SkillUpdateManyWithWhereWithoutModifiedSkillsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput = {
    create?: XOR<AbilityCreateWithoutCreatedAbilitiesInput, AbilityUncheckedCreateWithoutCreatedAbilitiesInput> | AbilityCreateWithoutCreatedAbilitiesInput[] | AbilityUncheckedCreateWithoutCreatedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutCreatedAbilitiesInput | AbilityCreateOrConnectWithoutCreatedAbilitiesInput[]
    upsert?: AbilityUpsertWithWhereUniqueWithoutCreatedAbilitiesInput | AbilityUpsertWithWhereUniqueWithoutCreatedAbilitiesInput[]
    createMany?: AbilityCreateManyCreatedAbilitiesInputEnvelope
    set?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    disconnect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    delete?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    update?: AbilityUpdateWithWhereUniqueWithoutCreatedAbilitiesInput | AbilityUpdateWithWhereUniqueWithoutCreatedAbilitiesInput[]
    updateMany?: AbilityUpdateManyWithWhereWithoutCreatedAbilitiesInput | AbilityUpdateManyWithWhereWithoutCreatedAbilitiesInput[]
    deleteMany?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
  }

  export type AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput = {
    create?: XOR<AbilityCreateWithoutModifiedAbilitiesInput, AbilityUncheckedCreateWithoutModifiedAbilitiesInput> | AbilityCreateWithoutModifiedAbilitiesInput[] | AbilityUncheckedCreateWithoutModifiedAbilitiesInput[]
    connectOrCreate?: AbilityCreateOrConnectWithoutModifiedAbilitiesInput | AbilityCreateOrConnectWithoutModifiedAbilitiesInput[]
    upsert?: AbilityUpsertWithWhereUniqueWithoutModifiedAbilitiesInput | AbilityUpsertWithWhereUniqueWithoutModifiedAbilitiesInput[]
    createMany?: AbilityCreateManyModifiedAbilitiesInputEnvelope
    set?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    disconnect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    delete?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    connect?: AbilityWhereUniqueInput | AbilityWhereUniqueInput[]
    update?: AbilityUpdateWithWhereUniqueWithoutModifiedAbilitiesInput | AbilityUpdateWithWhereUniqueWithoutModifiedAbilitiesInput[]
    updateMany?: AbilityUpdateManyWithWhereWithoutModifiedAbilitiesInput | AbilityUpdateManyWithWhereWithoutModifiedAbilitiesInput[]
    deleteMany?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput = {
    create?: XOR<QuestCreateWithoutCreatedQuestsInput, QuestUncheckedCreateWithoutCreatedQuestsInput> | QuestCreateWithoutCreatedQuestsInput[] | QuestUncheckedCreateWithoutCreatedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCreatedQuestsInput | QuestCreateOrConnectWithoutCreatedQuestsInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutCreatedQuestsInput | QuestUpsertWithWhereUniqueWithoutCreatedQuestsInput[]
    createMany?: QuestCreateManyCreatedQuestsInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutCreatedQuestsInput | QuestUpdateWithWhereUniqueWithoutCreatedQuestsInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutCreatedQuestsInput | QuestUpdateManyWithWhereWithoutCreatedQuestsInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput = {
    create?: XOR<QuestCreateWithoutModifiedQuestsInput, QuestUncheckedCreateWithoutModifiedQuestsInput> | QuestCreateWithoutModifiedQuestsInput[] | QuestUncheckedCreateWithoutModifiedQuestsInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutModifiedQuestsInput | QuestCreateOrConnectWithoutModifiedQuestsInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutModifiedQuestsInput | QuestUpsertWithWhereUniqueWithoutModifiedQuestsInput[]
    createMany?: QuestCreateManyModifiedQuestsInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutModifiedQuestsInput | QuestUpdateWithWhereUniqueWithoutModifiedQuestsInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutModifiedQuestsInput | QuestUpdateManyWithWhereWithoutModifiedQuestsInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutAuthorInput | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutAuthorInput | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutAuthorInput | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput = {
    create?: XOR<ArticleVersionCreateWithoutEditorInput, ArticleVersionUncheckedCreateWithoutEditorInput> | ArticleVersionCreateWithoutEditorInput[] | ArticleVersionUncheckedCreateWithoutEditorInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutEditorInput | ArticleVersionCreateOrConnectWithoutEditorInput[]
    upsert?: ArticleVersionUpsertWithWhereUniqueWithoutEditorInput | ArticleVersionUpsertWithWhereUniqueWithoutEditorInput[]
    createMany?: ArticleVersionCreateManyEditorInputEnvelope
    set?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    disconnect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    delete?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    update?: ArticleVersionUpdateWithWhereUniqueWithoutEditorInput | ArticleVersionUpdateWithWhereUniqueWithoutEditorInput[]
    updateMany?: ArticleVersionUpdateManyWithWhereWithoutEditorInput | ArticleVersionUpdateManyWithWhereWithoutEditorInput[]
    deleteMany?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TagCreateWithoutCreatorInput, TagUncheckedCreateWithoutCreatorInput> | TagCreateWithoutCreatorInput[] | TagUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCreatorInput | TagCreateOrConnectWithoutCreatorInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCreatorInput | TagUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TagCreateManyCreatorInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCreatorInput | TagUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCreatorInput | TagUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type AreaUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AreaCreateWithoutAuthorInput, AreaUncheckedCreateWithoutAuthorInput> | AreaCreateWithoutAuthorInput[] | AreaUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutAuthorInput | AreaCreateOrConnectWithoutAuthorInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutAuthorInput | AreaUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AreaCreateManyAuthorInputEnvelope
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutAuthorInput | AreaUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutAuthorInput | AreaUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ChangeLogCreateWithoutCreatorInput, ChangeLogUncheckedCreateWithoutCreatorInput> | ChangeLogCreateWithoutCreatorInput[] | ChangeLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutCreatorInput | ChangeLogCreateOrConnectWithoutCreatorInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutCreatorInput | ChangeLogUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ChangeLogCreateManyCreatorInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutCreatorInput | ChangeLogUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutCreatorInput | ChangeLogUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutAccountNotificationInput = {
    create?: XOR<AccountCreateWithoutAccountNotificationInput, AccountUncheckedCreateWithoutAccountNotificationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountNotificationInput
    connect?: AccountWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateOneRequiredWithoutAccountNotificationNestedInput = {
    create?: XOR<AccountCreateWithoutAccountNotificationInput, AccountUncheckedCreateWithoutAccountNotificationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountNotificationInput
    upsert?: AccountUpsertWithoutAccountNotificationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAccountNotificationInput, AccountUpdateWithoutAccountNotificationInput>, AccountUncheckedUpdateWithoutAccountNotificationInput>
  }

  export type AccountCreateNestedOneWithoutAccountPasswordInput = {
    create?: XOR<AccountCreateWithoutAccountPasswordInput, AccountUncheckedCreateWithoutAccountPasswordInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountPasswordInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccountPasswordNestedInput = {
    create?: XOR<AccountCreateWithoutAccountPasswordInput, AccountUncheckedCreateWithoutAccountPasswordInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountPasswordInput
    upsert?: AccountUpsertWithoutAccountPasswordInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAccountPasswordInput, AccountUpdateWithoutAccountPasswordInput>, AccountUncheckedUpdateWithoutAccountPasswordInput>
  }

  export type AccountCreateNestedOneWithoutNetworkHistoryInput = {
    create?: XOR<AccountCreateWithoutNetworkHistoryInput, AccountUncheckedCreateWithoutNetworkHistoryInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNetworkHistoryInput
    connect?: AccountWhereUniqueInput
  }

  export type NetworkBlacklistCreateNestedManyWithoutNetworkHistoryInput = {
    create?: XOR<NetworkBlacklistCreateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput> | NetworkBlacklistCreateWithoutNetworkHistoryInput[] | NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput | NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput[]
    createMany?: NetworkBlacklistCreateManyNetworkHistoryInputEnvelope
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
  }

  export type NetworkBlacklistUncheckedCreateNestedManyWithoutNetworkHistoryInput = {
    create?: XOR<NetworkBlacklistCreateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput> | NetworkBlacklistCreateWithoutNetworkHistoryInput[] | NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput | NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput[]
    createMany?: NetworkBlacklistCreateManyNetworkHistoryInputEnvelope
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutNetworkHistoryNestedInput = {
    create?: XOR<AccountCreateWithoutNetworkHistoryInput, AccountUncheckedCreateWithoutNetworkHistoryInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNetworkHistoryInput
    upsert?: AccountUpsertWithoutNetworkHistoryInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutNetworkHistoryInput, AccountUpdateWithoutNetworkHistoryInput>, AccountUncheckedUpdateWithoutNetworkHistoryInput>
  }

  export type NetworkBlacklistUpdateManyWithoutNetworkHistoryNestedInput = {
    create?: XOR<NetworkBlacklistCreateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput> | NetworkBlacklistCreateWithoutNetworkHistoryInput[] | NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput | NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput[]
    upsert?: NetworkBlacklistUpsertWithWhereUniqueWithoutNetworkHistoryInput | NetworkBlacklistUpsertWithWhereUniqueWithoutNetworkHistoryInput[]
    createMany?: NetworkBlacklistCreateManyNetworkHistoryInputEnvelope
    set?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    disconnect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    delete?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    update?: NetworkBlacklistUpdateWithWhereUniqueWithoutNetworkHistoryInput | NetworkBlacklistUpdateWithWhereUniqueWithoutNetworkHistoryInput[]
    updateMany?: NetworkBlacklistUpdateManyWithWhereWithoutNetworkHistoryInput | NetworkBlacklistUpdateManyWithWhereWithoutNetworkHistoryInput[]
    deleteMany?: NetworkBlacklistScalarWhereInput | NetworkBlacklistScalarWhereInput[]
  }

  export type NetworkBlacklistUncheckedUpdateManyWithoutNetworkHistoryNestedInput = {
    create?: XOR<NetworkBlacklistCreateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput> | NetworkBlacklistCreateWithoutNetworkHistoryInput[] | NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput[]
    connectOrCreate?: NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput | NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput[]
    upsert?: NetworkBlacklistUpsertWithWhereUniqueWithoutNetworkHistoryInput | NetworkBlacklistUpsertWithWhereUniqueWithoutNetworkHistoryInput[]
    createMany?: NetworkBlacklistCreateManyNetworkHistoryInputEnvelope
    set?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    disconnect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    delete?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    connect?: NetworkBlacklistWhereUniqueInput | NetworkBlacklistWhereUniqueInput[]
    update?: NetworkBlacklistUpdateWithWhereUniqueWithoutNetworkHistoryInput | NetworkBlacklistUpdateWithWhereUniqueWithoutNetworkHistoryInput[]
    updateMany?: NetworkBlacklistUpdateManyWithWhereWithoutNetworkHistoryInput | NetworkBlacklistUpdateManyWithWhereWithoutNetworkHistoryInput[]
    deleteMany?: NetworkBlacklistScalarWhereInput | NetworkBlacklistScalarWhereInput[]
  }

  export type NetworkHistoryCreateNestedOneWithoutNetworkBlacklistInput = {
    create?: XOR<NetworkHistoryCreateWithoutNetworkBlacklistInput, NetworkHistoryUncheckedCreateWithoutNetworkBlacklistInput>
    connectOrCreate?: NetworkHistoryCreateOrConnectWithoutNetworkBlacklistInput
    connect?: NetworkHistoryWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutNetworkBlacklistInput = {
    create?: XOR<AccountCreateWithoutNetworkBlacklistInput, AccountUncheckedCreateWithoutNetworkBlacklistInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNetworkBlacklistInput
    connect?: AccountWhereUniqueInput
  }

  export type NetworkHistoryUpdateOneRequiredWithoutNetworkBlacklistNestedInput = {
    create?: XOR<NetworkHistoryCreateWithoutNetworkBlacklistInput, NetworkHistoryUncheckedCreateWithoutNetworkBlacklistInput>
    connectOrCreate?: NetworkHistoryCreateOrConnectWithoutNetworkBlacklistInput
    upsert?: NetworkHistoryUpsertWithoutNetworkBlacklistInput
    connect?: NetworkHistoryWhereUniqueInput
    update?: XOR<XOR<NetworkHistoryUpdateToOneWithWhereWithoutNetworkBlacklistInput, NetworkHistoryUpdateWithoutNetworkBlacklistInput>, NetworkHistoryUncheckedUpdateWithoutNetworkBlacklistInput>
  }

  export type AccountUpdateOneRequiredWithoutNetworkBlacklistNestedInput = {
    create?: XOR<AccountCreateWithoutNetworkBlacklistInput, AccountUncheckedCreateWithoutNetworkBlacklistInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNetworkBlacklistInput
    upsert?: AccountUpsertWithoutNetworkBlacklistInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutNetworkBlacklistInput, AccountUpdateWithoutNetworkBlacklistInput>, AccountUncheckedUpdateWithoutNetworkBlacklistInput>
  }

  export type AccountCreateNestedOneWithoutNotificationInput = {
    create?: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type AccountUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationInput
    upsert?: AccountUpsertWithoutNotificationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutNotificationInput, AccountUpdateWithoutNotificationInput>, AccountUncheckedUpdateWithoutNotificationInput>
  }

  export type AccountCreateNestedOneWithoutCharacterInput = {
    create?: XOR<AccountCreateWithoutCharacterInput, AccountUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCharacterInput
    connect?: AccountWhereUniqueInput
  }

  export type CharacterVersionCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterInput, CharacterVersionUncheckedCreateWithoutCharacterInput> | CharacterVersionCreateWithoutCharacterInput[] | CharacterVersionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterInput | CharacterVersionCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterVersionCreateManyCharacterInputEnvelope
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
  }

  export type CharacterVersionUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterInput, CharacterVersionUncheckedCreateWithoutCharacterInput> | CharacterVersionCreateWithoutCharacterInput[] | CharacterVersionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterInput | CharacterVersionCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterVersionCreateManyCharacterInputEnvelope
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneRequiredWithoutCharacterNestedInput = {
    create?: XOR<AccountCreateWithoutCharacterInput, AccountUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCharacterInput
    upsert?: AccountUpsertWithoutCharacterInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCharacterInput, AccountUpdateWithoutCharacterInput>, AccountUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterVersionUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterInput, CharacterVersionUncheckedCreateWithoutCharacterInput> | CharacterVersionCreateWithoutCharacterInput[] | CharacterVersionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterInput | CharacterVersionCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterVersionUpsertWithWhereUniqueWithoutCharacterInput | CharacterVersionUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterVersionCreateManyCharacterInputEnvelope
    set?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    disconnect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    delete?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    update?: CharacterVersionUpdateWithWhereUniqueWithoutCharacterInput | CharacterVersionUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterVersionUpdateManyWithWhereWithoutCharacterInput | CharacterVersionUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterVersionScalarWhereInput | CharacterVersionScalarWhereInput[]
  }

  export type CharacterVersionUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterInput, CharacterVersionUncheckedCreateWithoutCharacterInput> | CharacterVersionCreateWithoutCharacterInput[] | CharacterVersionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterInput | CharacterVersionCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterVersionUpsertWithWhereUniqueWithoutCharacterInput | CharacterVersionUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterVersionCreateManyCharacterInputEnvelope
    set?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    disconnect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    delete?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    update?: CharacterVersionUpdateWithWhereUniqueWithoutCharacterInput | CharacterVersionUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterVersionUpdateManyWithWhereWithoutCharacterInput | CharacterVersionUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterVersionScalarWhereInput | CharacterVersionScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutCharacterVersionInput = {
    create?: XOR<CharacterCreateWithoutCharacterVersionInput, CharacterUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCharacterVersionInput
    connect?: CharacterWhereUniqueInput
  }

  export type CharacterStatCreateNestedOneWithoutCharacterVersionInput = {
    create?: XOR<CharacterStatCreateWithoutCharacterVersionInput, CharacterStatUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterStatCreateOrConnectWithoutCharacterVersionInput
    connect?: CharacterStatWhereUniqueInput
  }

  export type CharacterQuestCreateNestedManyWithoutCharacterVersionInput = {
    create?: XOR<CharacterQuestCreateWithoutCharacterVersionInput, CharacterQuestUncheckedCreateWithoutCharacterVersionInput> | CharacterQuestCreateWithoutCharacterVersionInput[] | CharacterQuestUncheckedCreateWithoutCharacterVersionInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutCharacterVersionInput | CharacterQuestCreateOrConnectWithoutCharacterVersionInput[]
    createMany?: CharacterQuestCreateManyCharacterVersionInputEnvelope
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
  }

  export type CharacterEquipmentCreateNestedOneWithoutCharacterVersionInput = {
    create?: XOR<CharacterEquipmentCreateWithoutCharacterVersionInput, CharacterEquipmentUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterEquipmentCreateOrConnectWithoutCharacterVersionInput
    connect?: CharacterEquipmentWhereUniqueInput
  }

  export type CharacterStatUncheckedCreateNestedOneWithoutCharacterVersionInput = {
    create?: XOR<CharacterStatCreateWithoutCharacterVersionInput, CharacterStatUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterStatCreateOrConnectWithoutCharacterVersionInput
    connect?: CharacterStatWhereUniqueInput
  }

  export type CharacterQuestUncheckedCreateNestedManyWithoutCharacterVersionInput = {
    create?: XOR<CharacterQuestCreateWithoutCharacterVersionInput, CharacterQuestUncheckedCreateWithoutCharacterVersionInput> | CharacterQuestCreateWithoutCharacterVersionInput[] | CharacterQuestUncheckedCreateWithoutCharacterVersionInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutCharacterVersionInput | CharacterQuestCreateOrConnectWithoutCharacterVersionInput[]
    createMany?: CharacterQuestCreateManyCharacterVersionInputEnvelope
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
  }

  export type CharacterUpdateOneRequiredWithoutCharacterVersionNestedInput = {
    create?: XOR<CharacterCreateWithoutCharacterVersionInput, CharacterUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCharacterVersionInput
    upsert?: CharacterUpsertWithoutCharacterVersionInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutCharacterVersionInput, CharacterUpdateWithoutCharacterVersionInput>, CharacterUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterStatUpdateOneWithoutCharacterVersionNestedInput = {
    create?: XOR<CharacterStatCreateWithoutCharacterVersionInput, CharacterStatUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterStatCreateOrConnectWithoutCharacterVersionInput
    upsert?: CharacterStatUpsertWithoutCharacterVersionInput
    disconnect?: CharacterStatWhereInput | boolean
    delete?: CharacterStatWhereInput | boolean
    connect?: CharacterStatWhereUniqueInput
    update?: XOR<XOR<CharacterStatUpdateToOneWithWhereWithoutCharacterVersionInput, CharacterStatUpdateWithoutCharacterVersionInput>, CharacterStatUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterQuestUpdateManyWithoutCharacterVersionNestedInput = {
    create?: XOR<CharacterQuestCreateWithoutCharacterVersionInput, CharacterQuestUncheckedCreateWithoutCharacterVersionInput> | CharacterQuestCreateWithoutCharacterVersionInput[] | CharacterQuestUncheckedCreateWithoutCharacterVersionInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutCharacterVersionInput | CharacterQuestCreateOrConnectWithoutCharacterVersionInput[]
    upsert?: CharacterQuestUpsertWithWhereUniqueWithoutCharacterVersionInput | CharacterQuestUpsertWithWhereUniqueWithoutCharacterVersionInput[]
    createMany?: CharacterQuestCreateManyCharacterVersionInputEnvelope
    set?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    disconnect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    delete?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    update?: CharacterQuestUpdateWithWhereUniqueWithoutCharacterVersionInput | CharacterQuestUpdateWithWhereUniqueWithoutCharacterVersionInput[]
    updateMany?: CharacterQuestUpdateManyWithWhereWithoutCharacterVersionInput | CharacterQuestUpdateManyWithWhereWithoutCharacterVersionInput[]
    deleteMany?: CharacterQuestScalarWhereInput | CharacterQuestScalarWhereInput[]
  }

  export type CharacterEquipmentUpdateOneWithoutCharacterVersionNestedInput = {
    create?: XOR<CharacterEquipmentCreateWithoutCharacterVersionInput, CharacterEquipmentUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterEquipmentCreateOrConnectWithoutCharacterVersionInput
    upsert?: CharacterEquipmentUpsertWithoutCharacterVersionInput
    disconnect?: CharacterEquipmentWhereInput | boolean
    delete?: CharacterEquipmentWhereInput | boolean
    connect?: CharacterEquipmentWhereUniqueInput
    update?: XOR<XOR<CharacterEquipmentUpdateToOneWithWhereWithoutCharacterVersionInput, CharacterEquipmentUpdateWithoutCharacterVersionInput>, CharacterEquipmentUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterStatUncheckedUpdateOneWithoutCharacterVersionNestedInput = {
    create?: XOR<CharacterStatCreateWithoutCharacterVersionInput, CharacterStatUncheckedCreateWithoutCharacterVersionInput>
    connectOrCreate?: CharacterStatCreateOrConnectWithoutCharacterVersionInput
    upsert?: CharacterStatUpsertWithoutCharacterVersionInput
    disconnect?: CharacterStatWhereInput | boolean
    delete?: CharacterStatWhereInput | boolean
    connect?: CharacterStatWhereUniqueInput
    update?: XOR<XOR<CharacterStatUpdateToOneWithWhereWithoutCharacterVersionInput, CharacterStatUpdateWithoutCharacterVersionInput>, CharacterStatUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterQuestUncheckedUpdateManyWithoutCharacterVersionNestedInput = {
    create?: XOR<CharacterQuestCreateWithoutCharacterVersionInput, CharacterQuestUncheckedCreateWithoutCharacterVersionInput> | CharacterQuestCreateWithoutCharacterVersionInput[] | CharacterQuestUncheckedCreateWithoutCharacterVersionInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutCharacterVersionInput | CharacterQuestCreateOrConnectWithoutCharacterVersionInput[]
    upsert?: CharacterQuestUpsertWithWhereUniqueWithoutCharacterVersionInput | CharacterQuestUpsertWithWhereUniqueWithoutCharacterVersionInput[]
    createMany?: CharacterQuestCreateManyCharacterVersionInputEnvelope
    set?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    disconnect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    delete?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    update?: CharacterQuestUpdateWithWhereUniqueWithoutCharacterVersionInput | CharacterQuestUpdateWithWhereUniqueWithoutCharacterVersionInput[]
    updateMany?: CharacterQuestUpdateManyWithWhereWithoutCharacterVersionInput | CharacterQuestUpdateManyWithWhereWithoutCharacterVersionInput[]
    deleteMany?: CharacterQuestScalarWhereInput | CharacterQuestScalarWhereInput[]
  }

  export type CharacterVersionCreateNestedOneWithoutCharacterStatInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterStatInput, CharacterVersionUncheckedCreateWithoutCharacterStatInput>
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterStatInput
    connect?: CharacterVersionWhereUniqueInput
  }

  export type CharacterVersionUpdateOneRequiredWithoutCharacterStatNestedInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterStatInput, CharacterVersionUncheckedCreateWithoutCharacterStatInput>
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterStatInput
    upsert?: CharacterVersionUpsertWithoutCharacterStatInput
    connect?: CharacterVersionWhereUniqueInput
    update?: XOR<XOR<CharacterVersionUpdateToOneWithWhereWithoutCharacterStatInput, CharacterVersionUpdateWithoutCharacterStatInput>, CharacterVersionUncheckedUpdateWithoutCharacterStatInput>
  }

  export type CharacterVersionCreateNestedOneWithoutCharacterQuestInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterQuestInput, CharacterVersionUncheckedCreateWithoutCharacterQuestInput>
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterQuestInput
    connect?: CharacterVersionWhereUniqueInput
  }

  export type QuestCreateNestedOneWithoutCharacterQuestInput = {
    create?: XOR<QuestCreateWithoutCharacterQuestInput, QuestUncheckedCreateWithoutCharacterQuestInput>
    connectOrCreate?: QuestCreateOrConnectWithoutCharacterQuestInput
    connect?: QuestWhereUniqueInput
  }

  export type CharacterVersionUpdateOneRequiredWithoutCharacterQuestNestedInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterQuestInput, CharacterVersionUncheckedCreateWithoutCharacterQuestInput>
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterQuestInput
    upsert?: CharacterVersionUpsertWithoutCharacterQuestInput
    connect?: CharacterVersionWhereUniqueInput
    update?: XOR<XOR<CharacterVersionUpdateToOneWithWhereWithoutCharacterQuestInput, CharacterVersionUpdateWithoutCharacterQuestInput>, CharacterVersionUncheckedUpdateWithoutCharacterQuestInput>
  }

  export type QuestUpdateOneRequiredWithoutCharacterQuestNestedInput = {
    create?: XOR<QuestCreateWithoutCharacterQuestInput, QuestUncheckedCreateWithoutCharacterQuestInput>
    connectOrCreate?: QuestCreateOrConnectWithoutCharacterQuestInput
    upsert?: QuestUpsertWithoutCharacterQuestInput
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutCharacterQuestInput, QuestUpdateWithoutCharacterQuestInput>, QuestUncheckedUpdateWithoutCharacterQuestInput>
  }

  export type CharacterVersionCreateNestedManyWithoutCharacterEquipmentInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterEquipmentInput, CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput> | CharacterVersionCreateWithoutCharacterEquipmentInput[] | CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput | CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput[]
    createMany?: CharacterVersionCreateManyCharacterEquipmentInputEnvelope
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
  }

  export type CharacterVersionUncheckedCreateNestedManyWithoutCharacterEquipmentInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterEquipmentInput, CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput> | CharacterVersionCreateWithoutCharacterEquipmentInput[] | CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput | CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput[]
    createMany?: CharacterVersionCreateManyCharacterEquipmentInputEnvelope
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
  }

  export type CharacterVersionUpdateManyWithoutCharacterEquipmentNestedInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterEquipmentInput, CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput> | CharacterVersionCreateWithoutCharacterEquipmentInput[] | CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput | CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput[]
    upsert?: CharacterVersionUpsertWithWhereUniqueWithoutCharacterEquipmentInput | CharacterVersionUpsertWithWhereUniqueWithoutCharacterEquipmentInput[]
    createMany?: CharacterVersionCreateManyCharacterEquipmentInputEnvelope
    set?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    disconnect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    delete?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    update?: CharacterVersionUpdateWithWhereUniqueWithoutCharacterEquipmentInput | CharacterVersionUpdateWithWhereUniqueWithoutCharacterEquipmentInput[]
    updateMany?: CharacterVersionUpdateManyWithWhereWithoutCharacterEquipmentInput | CharacterVersionUpdateManyWithWhereWithoutCharacterEquipmentInput[]
    deleteMany?: CharacterVersionScalarWhereInput | CharacterVersionScalarWhereInput[]
  }

  export type CharacterVersionUncheckedUpdateManyWithoutCharacterEquipmentNestedInput = {
    create?: XOR<CharacterVersionCreateWithoutCharacterEquipmentInput, CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput> | CharacterVersionCreateWithoutCharacterEquipmentInput[] | CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput[]
    connectOrCreate?: CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput | CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput[]
    upsert?: CharacterVersionUpsertWithWhereUniqueWithoutCharacterEquipmentInput | CharacterVersionUpsertWithWhereUniqueWithoutCharacterEquipmentInput[]
    createMany?: CharacterVersionCreateManyCharacterEquipmentInputEnvelope
    set?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    disconnect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    delete?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    connect?: CharacterVersionWhereUniqueInput | CharacterVersionWhereUniqueInput[]
    update?: CharacterVersionUpdateWithWhereUniqueWithoutCharacterEquipmentInput | CharacterVersionUpdateWithWhereUniqueWithoutCharacterEquipmentInput[]
    updateMany?: CharacterVersionUpdateManyWithWhereWithoutCharacterEquipmentInput | CharacterVersionUpdateManyWithWhereWithoutCharacterEquipmentInput[]
    deleteMany?: CharacterVersionScalarWhereInput | CharacterVersionScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutCreatedItemsInput = {
    create?: XOR<AccountCreateWithoutCreatedItemsInput, AccountUncheckedCreateWithoutCreatedItemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedItemsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModifiedItemsInput = {
    create?: XOR<AccountCreateWithoutModifiedItemsInput, AccountUncheckedCreateWithoutModifiedItemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedItemsInput
    connect?: AccountWhereUniqueInput
  }

  export type ItemSpellCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSpellCreateWithoutItemInput, ItemSpellUncheckedCreateWithoutItemInput> | ItemSpellCreateWithoutItemInput[] | ItemSpellUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutItemInput | ItemSpellCreateOrConnectWithoutItemInput[]
    createMany?: ItemSpellCreateManyItemInputEnvelope
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
  }

  export type ItemWeaponCreateNestedOneWithoutItemInput = {
    create?: XOR<ItemWeaponCreateWithoutItemInput, ItemWeaponUncheckedCreateWithoutItemInput>
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutItemInput
    connect?: ItemWeaponWhereUniqueInput
  }

  export type ItemWeaponCreateNestedManyWithoutAmmoItemInput = {
    create?: XOR<ItemWeaponCreateWithoutAmmoItemInput, ItemWeaponUncheckedCreateWithoutAmmoItemInput> | ItemWeaponCreateWithoutAmmoItemInput[] | ItemWeaponUncheckedCreateWithoutAmmoItemInput[]
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutAmmoItemInput | ItemWeaponCreateOrConnectWithoutAmmoItemInput[]
    createMany?: ItemWeaponCreateManyAmmoItemInputEnvelope
    connect?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
  }

  export type StatModiferCreateNestedOneWithoutItemSourceInput = {
    create?: XOR<StatModiferCreateWithoutItemSourceInput, StatModiferUncheckedCreateWithoutItemSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutItemSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type AppliedTagCreateNestedOneWithoutItemTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutItemTagSourceInput, AppliedTagUncheckedCreateWithoutItemTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutItemTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type ItemSpellUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSpellCreateWithoutItemInput, ItemSpellUncheckedCreateWithoutItemInput> | ItemSpellCreateWithoutItemInput[] | ItemSpellUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutItemInput | ItemSpellCreateOrConnectWithoutItemInput[]
    createMany?: ItemSpellCreateManyItemInputEnvelope
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
  }

  export type ItemWeaponUncheckedCreateNestedOneWithoutItemInput = {
    create?: XOR<ItemWeaponCreateWithoutItemInput, ItemWeaponUncheckedCreateWithoutItemInput>
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutItemInput
    connect?: ItemWeaponWhereUniqueInput
  }

  export type ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput = {
    create?: XOR<ItemWeaponCreateWithoutAmmoItemInput, ItemWeaponUncheckedCreateWithoutAmmoItemInput> | ItemWeaponCreateWithoutAmmoItemInput[] | ItemWeaponUncheckedCreateWithoutAmmoItemInput[]
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutAmmoItemInput | ItemWeaponCreateOrConnectWithoutAmmoItemInput[]
    createMany?: ItemWeaponCreateManyAmmoItemInputEnvelope
    connect?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
  }

  export type StatModiferUncheckedCreateNestedOneWithoutItemSourceInput = {
    create?: XOR<StatModiferCreateWithoutItemSourceInput, StatModiferUncheckedCreateWithoutItemSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutItemSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutItemTagSourceInput, AppliedTagUncheckedCreateWithoutItemTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutItemTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type NullableEnumAlignFieldUpdateOperationsInput = {
    set?: $Enums.Align | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneRequiredWithoutCreatedItemsNestedInput = {
    create?: XOR<AccountCreateWithoutCreatedItemsInput, AccountUncheckedCreateWithoutCreatedItemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedItemsInput
    upsert?: AccountUpsertWithoutCreatedItemsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCreatedItemsInput, AccountUpdateWithoutCreatedItemsInput>, AccountUncheckedUpdateWithoutCreatedItemsInput>
  }

  export type AccountUpdateOneWithoutModifiedItemsNestedInput = {
    create?: XOR<AccountCreateWithoutModifiedItemsInput, AccountUncheckedCreateWithoutModifiedItemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedItemsInput
    upsert?: AccountUpsertWithoutModifiedItemsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModifiedItemsInput, AccountUpdateWithoutModifiedItemsInput>, AccountUncheckedUpdateWithoutModifiedItemsInput>
  }

  export type ItemSpellUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSpellCreateWithoutItemInput, ItemSpellUncheckedCreateWithoutItemInput> | ItemSpellCreateWithoutItemInput[] | ItemSpellUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutItemInput | ItemSpellCreateOrConnectWithoutItemInput[]
    upsert?: ItemSpellUpsertWithWhereUniqueWithoutItemInput | ItemSpellUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSpellCreateManyItemInputEnvelope
    set?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    disconnect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    delete?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    update?: ItemSpellUpdateWithWhereUniqueWithoutItemInput | ItemSpellUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSpellUpdateManyWithWhereWithoutItemInput | ItemSpellUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSpellScalarWhereInput | ItemSpellScalarWhereInput[]
  }

  export type ItemWeaponUpdateOneWithoutItemNestedInput = {
    create?: XOR<ItemWeaponCreateWithoutItemInput, ItemWeaponUncheckedCreateWithoutItemInput>
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutItemInput
    upsert?: ItemWeaponUpsertWithoutItemInput
    disconnect?: ItemWeaponWhereInput | boolean
    delete?: ItemWeaponWhereInput | boolean
    connect?: ItemWeaponWhereUniqueInput
    update?: XOR<XOR<ItemWeaponUpdateToOneWithWhereWithoutItemInput, ItemWeaponUpdateWithoutItemInput>, ItemWeaponUncheckedUpdateWithoutItemInput>
  }

  export type ItemWeaponUpdateManyWithoutAmmoItemNestedInput = {
    create?: XOR<ItemWeaponCreateWithoutAmmoItemInput, ItemWeaponUncheckedCreateWithoutAmmoItemInput> | ItemWeaponCreateWithoutAmmoItemInput[] | ItemWeaponUncheckedCreateWithoutAmmoItemInput[]
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutAmmoItemInput | ItemWeaponCreateOrConnectWithoutAmmoItemInput[]
    upsert?: ItemWeaponUpsertWithWhereUniqueWithoutAmmoItemInput | ItemWeaponUpsertWithWhereUniqueWithoutAmmoItemInput[]
    createMany?: ItemWeaponCreateManyAmmoItemInputEnvelope
    set?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    disconnect?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    delete?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    connect?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    update?: ItemWeaponUpdateWithWhereUniqueWithoutAmmoItemInput | ItemWeaponUpdateWithWhereUniqueWithoutAmmoItemInput[]
    updateMany?: ItemWeaponUpdateManyWithWhereWithoutAmmoItemInput | ItemWeaponUpdateManyWithWhereWithoutAmmoItemInput[]
    deleteMany?: ItemWeaponScalarWhereInput | ItemWeaponScalarWhereInput[]
  }

  export type StatModiferUpdateOneWithoutItemSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutItemSourceInput, StatModiferUncheckedCreateWithoutItemSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutItemSourceInput
    upsert?: StatModiferUpsertWithoutItemSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutItemSourceInput, StatModiferUpdateWithoutItemSourceInput>, StatModiferUncheckedUpdateWithoutItemSourceInput>
  }

  export type AppliedTagUpdateOneWithoutItemTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutItemTagSourceInput, AppliedTagUncheckedCreateWithoutItemTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutItemTagSourceInput
    upsert?: AppliedTagUpsertWithoutItemTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutItemTagSourceInput, AppliedTagUpdateWithoutItemTagSourceInput>, AppliedTagUncheckedUpdateWithoutItemTagSourceInput>
  }

  export type ItemSpellUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSpellCreateWithoutItemInput, ItemSpellUncheckedCreateWithoutItemInput> | ItemSpellCreateWithoutItemInput[] | ItemSpellUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutItemInput | ItemSpellCreateOrConnectWithoutItemInput[]
    upsert?: ItemSpellUpsertWithWhereUniqueWithoutItemInput | ItemSpellUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSpellCreateManyItemInputEnvelope
    set?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    disconnect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    delete?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    update?: ItemSpellUpdateWithWhereUniqueWithoutItemInput | ItemSpellUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSpellUpdateManyWithWhereWithoutItemInput | ItemSpellUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSpellScalarWhereInput | ItemSpellScalarWhereInput[]
  }

  export type ItemWeaponUncheckedUpdateOneWithoutItemNestedInput = {
    create?: XOR<ItemWeaponCreateWithoutItemInput, ItemWeaponUncheckedCreateWithoutItemInput>
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutItemInput
    upsert?: ItemWeaponUpsertWithoutItemInput
    disconnect?: ItemWeaponWhereInput | boolean
    delete?: ItemWeaponWhereInput | boolean
    connect?: ItemWeaponWhereUniqueInput
    update?: XOR<XOR<ItemWeaponUpdateToOneWithWhereWithoutItemInput, ItemWeaponUpdateWithoutItemInput>, ItemWeaponUncheckedUpdateWithoutItemInput>
  }

  export type ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput = {
    create?: XOR<ItemWeaponCreateWithoutAmmoItemInput, ItemWeaponUncheckedCreateWithoutAmmoItemInput> | ItemWeaponCreateWithoutAmmoItemInput[] | ItemWeaponUncheckedCreateWithoutAmmoItemInput[]
    connectOrCreate?: ItemWeaponCreateOrConnectWithoutAmmoItemInput | ItemWeaponCreateOrConnectWithoutAmmoItemInput[]
    upsert?: ItemWeaponUpsertWithWhereUniqueWithoutAmmoItemInput | ItemWeaponUpsertWithWhereUniqueWithoutAmmoItemInput[]
    createMany?: ItemWeaponCreateManyAmmoItemInputEnvelope
    set?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    disconnect?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    delete?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    connect?: ItemWeaponWhereUniqueInput | ItemWeaponWhereUniqueInput[]
    update?: ItemWeaponUpdateWithWhereUniqueWithoutAmmoItemInput | ItemWeaponUpdateWithWhereUniqueWithoutAmmoItemInput[]
    updateMany?: ItemWeaponUpdateManyWithWhereWithoutAmmoItemInput | ItemWeaponUpdateManyWithWhereWithoutAmmoItemInput[]
    deleteMany?: ItemWeaponScalarWhereInput | ItemWeaponScalarWhereInput[]
  }

  export type StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutItemSourceInput, StatModiferUncheckedCreateWithoutItemSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutItemSourceInput
    upsert?: StatModiferUpsertWithoutItemSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutItemSourceInput, StatModiferUpdateWithoutItemSourceInput>, StatModiferUncheckedUpdateWithoutItemSourceInput>
  }

  export type AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutItemTagSourceInput, AppliedTagUncheckedCreateWithoutItemTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutItemTagSourceInput
    upsert?: AppliedTagUpsertWithoutItemTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutItemTagSourceInput, AppliedTagUpdateWithoutItemTagSourceInput>, AppliedTagUncheckedUpdateWithoutItemTagSourceInput>
  }

  export type ItemCreateNestedOneWithoutItemWeaponInput = {
    create?: XOR<ItemCreateWithoutItemWeaponInput, ItemUncheckedCreateWithoutItemWeaponInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemWeaponInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutAmmoItemInput = {
    create?: XOR<ItemCreateWithoutAmmoItemInput, ItemUncheckedCreateWithoutAmmoItemInput>
    connectOrCreate?: ItemCreateOrConnectWithoutAmmoItemInput
    connect?: ItemWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumWeaponStatFieldUpdateOperationsInput = {
    set?: $Enums.WeaponStat | null
  }

  export type NullableEnumWeaponTypeFieldUpdateOperationsInput = {
    set?: $Enums.WeaponType | null
  }

  export type ItemUpdateOneRequiredWithoutItemWeaponNestedInput = {
    create?: XOR<ItemCreateWithoutItemWeaponInput, ItemUncheckedCreateWithoutItemWeaponInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemWeaponInput
    upsert?: ItemUpsertWithoutItemWeaponInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutItemWeaponInput, ItemUpdateWithoutItemWeaponInput>, ItemUncheckedUpdateWithoutItemWeaponInput>
  }

  export type ItemUpdateOneRequiredWithoutAmmoItemNestedInput = {
    create?: XOR<ItemCreateWithoutAmmoItemInput, ItemUncheckedCreateWithoutAmmoItemInput>
    connectOrCreate?: ItemCreateOrConnectWithoutAmmoItemInput
    upsert?: ItemUpsertWithoutAmmoItemInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutAmmoItemInput, ItemUpdateWithoutAmmoItemInput>, ItemUncheckedUpdateWithoutAmmoItemInput>
  }

  export type ItemCreateNestedOneWithoutItemSpellInput = {
    create?: XOR<ItemCreateWithoutItemSpellInput, ItemUncheckedCreateWithoutItemSpellInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemSpellInput
    connect?: ItemWhereUniqueInput
  }

  export type SpellCreateNestedOneWithoutItemSpellInput = {
    create?: XOR<SpellCreateWithoutItemSpellInput, SpellUncheckedCreateWithoutItemSpellInput>
    connectOrCreate?: SpellCreateOrConnectWithoutItemSpellInput
    connect?: SpellWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutItemSpellNestedInput = {
    create?: XOR<ItemCreateWithoutItemSpellInput, ItemUncheckedCreateWithoutItemSpellInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemSpellInput
    upsert?: ItemUpsertWithoutItemSpellInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutItemSpellInput, ItemUpdateWithoutItemSpellInput>, ItemUncheckedUpdateWithoutItemSpellInput>
  }

  export type SpellUpdateOneRequiredWithoutItemSpellNestedInput = {
    create?: XOR<SpellCreateWithoutItemSpellInput, SpellUncheckedCreateWithoutItemSpellInput>
    connectOrCreate?: SpellCreateOrConnectWithoutItemSpellInput
    upsert?: SpellUpsertWithoutItemSpellInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutItemSpellInput, SpellUpdateWithoutItemSpellInput>, SpellUncheckedUpdateWithoutItemSpellInput>
  }

  export type ItemSpellCreateNestedManyWithoutSpellInput = {
    create?: XOR<ItemSpellCreateWithoutSpellInput, ItemSpellUncheckedCreateWithoutSpellInput> | ItemSpellCreateWithoutSpellInput[] | ItemSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutSpellInput | ItemSpellCreateOrConnectWithoutSpellInput[]
    createMany?: ItemSpellCreateManySpellInputEnvelope
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutCreatedSpellsInput = {
    create?: XOR<AccountCreateWithoutCreatedSpellsInput, AccountUncheckedCreateWithoutCreatedSpellsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedSpellsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModifiedSpellsInput = {
    create?: XOR<AccountCreateWithoutModifiedSpellsInput, AccountUncheckedCreateWithoutModifiedSpellsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedSpellsInput
    connect?: AccountWhereUniqueInput
  }

  export type StatModiferCreateNestedOneWithoutSpellSourceInput = {
    create?: XOR<StatModiferCreateWithoutSpellSourceInput, StatModiferUncheckedCreateWithoutSpellSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSpellSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type ItemSpellUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<ItemSpellCreateWithoutSpellInput, ItemSpellUncheckedCreateWithoutSpellInput> | ItemSpellCreateWithoutSpellInput[] | ItemSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutSpellInput | ItemSpellCreateOrConnectWithoutSpellInput[]
    createMany?: ItemSpellCreateManySpellInputEnvelope
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
  }

  export type StatModiferUncheckedCreateNestedOneWithoutSpellSourceInput = {
    create?: XOR<StatModiferCreateWithoutSpellSourceInput, StatModiferUncheckedCreateWithoutSpellSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSpellSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type ItemSpellUpdateManyWithoutSpellNestedInput = {
    create?: XOR<ItemSpellCreateWithoutSpellInput, ItemSpellUncheckedCreateWithoutSpellInput> | ItemSpellCreateWithoutSpellInput[] | ItemSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutSpellInput | ItemSpellCreateOrConnectWithoutSpellInput[]
    upsert?: ItemSpellUpsertWithWhereUniqueWithoutSpellInput | ItemSpellUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: ItemSpellCreateManySpellInputEnvelope
    set?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    disconnect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    delete?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    update?: ItemSpellUpdateWithWhereUniqueWithoutSpellInput | ItemSpellUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: ItemSpellUpdateManyWithWhereWithoutSpellInput | ItemSpellUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: ItemSpellScalarWhereInput | ItemSpellScalarWhereInput[]
  }

  export type AccountUpdateOneRequiredWithoutCreatedSpellsNestedInput = {
    create?: XOR<AccountCreateWithoutCreatedSpellsInput, AccountUncheckedCreateWithoutCreatedSpellsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedSpellsInput
    upsert?: AccountUpsertWithoutCreatedSpellsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCreatedSpellsInput, AccountUpdateWithoutCreatedSpellsInput>, AccountUncheckedUpdateWithoutCreatedSpellsInput>
  }

  export type AccountUpdateOneRequiredWithoutModifiedSpellsNestedInput = {
    create?: XOR<AccountCreateWithoutModifiedSpellsInput, AccountUncheckedCreateWithoutModifiedSpellsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedSpellsInput
    upsert?: AccountUpsertWithoutModifiedSpellsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModifiedSpellsInput, AccountUpdateWithoutModifiedSpellsInput>, AccountUncheckedUpdateWithoutModifiedSpellsInput>
  }

  export type StatModiferUpdateOneWithoutSpellSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutSpellSourceInput, StatModiferUncheckedCreateWithoutSpellSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSpellSourceInput
    upsert?: StatModiferUpsertWithoutSpellSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutSpellSourceInput, StatModiferUpdateWithoutSpellSourceInput>, StatModiferUncheckedUpdateWithoutSpellSourceInput>
  }

  export type ItemSpellUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<ItemSpellCreateWithoutSpellInput, ItemSpellUncheckedCreateWithoutSpellInput> | ItemSpellCreateWithoutSpellInput[] | ItemSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: ItemSpellCreateOrConnectWithoutSpellInput | ItemSpellCreateOrConnectWithoutSpellInput[]
    upsert?: ItemSpellUpsertWithWhereUniqueWithoutSpellInput | ItemSpellUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: ItemSpellCreateManySpellInputEnvelope
    set?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    disconnect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    delete?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    connect?: ItemSpellWhereUniqueInput | ItemSpellWhereUniqueInput[]
    update?: ItemSpellUpdateWithWhereUniqueWithoutSpellInput | ItemSpellUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: ItemSpellUpdateManyWithWhereWithoutSpellInput | ItemSpellUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: ItemSpellScalarWhereInput | ItemSpellScalarWhereInput[]
  }

  export type StatModiferUncheckedUpdateOneWithoutSpellSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutSpellSourceInput, StatModiferUncheckedCreateWithoutSpellSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSpellSourceInput
    upsert?: StatModiferUpsertWithoutSpellSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutSpellSourceInput, StatModiferUpdateWithoutSpellSourceInput>, StatModiferUncheckedUpdateWithoutSpellSourceInput>
  }

  export type AccountCreateNestedOneWithoutCreatedPotionsInput = {
    create?: XOR<AccountCreateWithoutCreatedPotionsInput, AccountUncheckedCreateWithoutCreatedPotionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedPotionsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModifiedPotionsInput = {
    create?: XOR<AccountCreateWithoutModifiedPotionsInput, AccountUncheckedCreateWithoutModifiedPotionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedPotionsInput
    connect?: AccountWhereUniqueInput
  }

  export type StatModiferCreateNestedOneWithoutPotionSourceInput = {
    create?: XOR<StatModiferCreateWithoutPotionSourceInput, StatModiferUncheckedCreateWithoutPotionSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutPotionSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type StatModiferUncheckedCreateNestedOneWithoutPotionSourceInput = {
    create?: XOR<StatModiferCreateWithoutPotionSourceInput, StatModiferUncheckedCreateWithoutPotionSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutPotionSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutCreatedPotionsNestedInput = {
    create?: XOR<AccountCreateWithoutCreatedPotionsInput, AccountUncheckedCreateWithoutCreatedPotionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedPotionsInput
    upsert?: AccountUpsertWithoutCreatedPotionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCreatedPotionsInput, AccountUpdateWithoutCreatedPotionsInput>, AccountUncheckedUpdateWithoutCreatedPotionsInput>
  }

  export type AccountUpdateOneRequiredWithoutModifiedPotionsNestedInput = {
    create?: XOR<AccountCreateWithoutModifiedPotionsInput, AccountUncheckedCreateWithoutModifiedPotionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedPotionsInput
    upsert?: AccountUpsertWithoutModifiedPotionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModifiedPotionsInput, AccountUpdateWithoutModifiedPotionsInput>, AccountUncheckedUpdateWithoutModifiedPotionsInput>
  }

  export type StatModiferUpdateOneWithoutPotionSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutPotionSourceInput, StatModiferUncheckedCreateWithoutPotionSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutPotionSourceInput
    upsert?: StatModiferUpsertWithoutPotionSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutPotionSourceInput, StatModiferUpdateWithoutPotionSourceInput>, StatModiferUncheckedUpdateWithoutPotionSourceInput>
  }

  export type StatModiferUncheckedUpdateOneWithoutPotionSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutPotionSourceInput, StatModiferUncheckedCreateWithoutPotionSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutPotionSourceInput
    upsert?: StatModiferUpsertWithoutPotionSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutPotionSourceInput, StatModiferUpdateWithoutPotionSourceInput>, StatModiferUncheckedUpdateWithoutPotionSourceInput>
  }

  export type AccountCreateNestedOneWithoutCreatedSkillsInput = {
    create?: XOR<AccountCreateWithoutCreatedSkillsInput, AccountUncheckedCreateWithoutCreatedSkillsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedSkillsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModifiedSkillsInput = {
    create?: XOR<AccountCreateWithoutModifiedSkillsInput, AccountUncheckedCreateWithoutModifiedSkillsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedSkillsInput
    connect?: AccountWhereUniqueInput
  }

  export type StatModiferCreateNestedOneWithoutSkillSourceInput = {
    create?: XOR<StatModiferCreateWithoutSkillSourceInput, StatModiferUncheckedCreateWithoutSkillSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSkillSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type StatModiferUncheckedCreateNestedOneWithoutSkillSourceInput = {
    create?: XOR<StatModiferCreateWithoutSkillSourceInput, StatModiferUncheckedCreateWithoutSkillSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSkillSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutCreatedSkillsNestedInput = {
    create?: XOR<AccountCreateWithoutCreatedSkillsInput, AccountUncheckedCreateWithoutCreatedSkillsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedSkillsInput
    upsert?: AccountUpsertWithoutCreatedSkillsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCreatedSkillsInput, AccountUpdateWithoutCreatedSkillsInput>, AccountUncheckedUpdateWithoutCreatedSkillsInput>
  }

  export type AccountUpdateOneRequiredWithoutModifiedSkillsNestedInput = {
    create?: XOR<AccountCreateWithoutModifiedSkillsInput, AccountUncheckedCreateWithoutModifiedSkillsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedSkillsInput
    upsert?: AccountUpsertWithoutModifiedSkillsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModifiedSkillsInput, AccountUpdateWithoutModifiedSkillsInput>, AccountUncheckedUpdateWithoutModifiedSkillsInput>
  }

  export type StatModiferUpdateOneWithoutSkillSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutSkillSourceInput, StatModiferUncheckedCreateWithoutSkillSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSkillSourceInput
    upsert?: StatModiferUpsertWithoutSkillSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutSkillSourceInput, StatModiferUpdateWithoutSkillSourceInput>, StatModiferUncheckedUpdateWithoutSkillSourceInput>
  }

  export type StatModiferUncheckedUpdateOneWithoutSkillSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutSkillSourceInput, StatModiferUncheckedCreateWithoutSkillSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutSkillSourceInput
    upsert?: StatModiferUpsertWithoutSkillSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutSkillSourceInput, StatModiferUpdateWithoutSkillSourceInput>, StatModiferUncheckedUpdateWithoutSkillSourceInput>
  }

  export type AccountCreateNestedOneWithoutCreatedAbilitiesInput = {
    create?: XOR<AccountCreateWithoutCreatedAbilitiesInput, AccountUncheckedCreateWithoutCreatedAbilitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedAbilitiesInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModifiedAbilitiesInput = {
    create?: XOR<AccountCreateWithoutModifiedAbilitiesInput, AccountUncheckedCreateWithoutModifiedAbilitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedAbilitiesInput
    connect?: AccountWhereUniqueInput
  }

  export type StatModiferCreateNestedOneWithoutAbilitySourceInput = {
    create?: XOR<StatModiferCreateWithoutAbilitySourceInput, StatModiferUncheckedCreateWithoutAbilitySourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutAbilitySourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type StatModiferUncheckedCreateNestedOneWithoutAbilitySourceInput = {
    create?: XOR<StatModiferCreateWithoutAbilitySourceInput, StatModiferUncheckedCreateWithoutAbilitySourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutAbilitySourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutCreatedAbilitiesNestedInput = {
    create?: XOR<AccountCreateWithoutCreatedAbilitiesInput, AccountUncheckedCreateWithoutCreatedAbilitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedAbilitiesInput
    upsert?: AccountUpsertWithoutCreatedAbilitiesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCreatedAbilitiesInput, AccountUpdateWithoutCreatedAbilitiesInput>, AccountUncheckedUpdateWithoutCreatedAbilitiesInput>
  }

  export type AccountUpdateOneRequiredWithoutModifiedAbilitiesNestedInput = {
    create?: XOR<AccountCreateWithoutModifiedAbilitiesInput, AccountUncheckedCreateWithoutModifiedAbilitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedAbilitiesInput
    upsert?: AccountUpsertWithoutModifiedAbilitiesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModifiedAbilitiesInput, AccountUpdateWithoutModifiedAbilitiesInput>, AccountUncheckedUpdateWithoutModifiedAbilitiesInput>
  }

  export type StatModiferUpdateOneWithoutAbilitySourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutAbilitySourceInput, StatModiferUncheckedCreateWithoutAbilitySourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutAbilitySourceInput
    upsert?: StatModiferUpsertWithoutAbilitySourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutAbilitySourceInput, StatModiferUpdateWithoutAbilitySourceInput>, StatModiferUncheckedUpdateWithoutAbilitySourceInput>
  }

  export type StatModiferUncheckedUpdateOneWithoutAbilitySourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutAbilitySourceInput, StatModiferUncheckedCreateWithoutAbilitySourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutAbilitySourceInput
    upsert?: StatModiferUpsertWithoutAbilitySourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutAbilitySourceInput, StatModiferUpdateWithoutAbilitySourceInput>, StatModiferUncheckedUpdateWithoutAbilitySourceInput>
  }

  export type AccountCreateNestedOneWithoutCreatedQuestsInput = {
    create?: XOR<AccountCreateWithoutCreatedQuestsInput, AccountUncheckedCreateWithoutCreatedQuestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedQuestsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutModifiedQuestsInput = {
    create?: XOR<AccountCreateWithoutModifiedQuestsInput, AccountUncheckedCreateWithoutModifiedQuestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedQuestsInput
    connect?: AccountWhereUniqueInput
  }

  export type CharacterQuestCreateNestedManyWithoutQuestInput = {
    create?: XOR<CharacterQuestCreateWithoutQuestInput, CharacterQuestUncheckedCreateWithoutQuestInput> | CharacterQuestCreateWithoutQuestInput[] | CharacterQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutQuestInput | CharacterQuestCreateOrConnectWithoutQuestInput[]
    createMany?: CharacterQuestCreateManyQuestInputEnvelope
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
  }

  export type StatModiferCreateNestedOneWithoutQuestSourceInput = {
    create?: XOR<StatModiferCreateWithoutQuestSourceInput, StatModiferUncheckedCreateWithoutQuestSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutQuestSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type AppliedTagCreateNestedOneWithoutQuestTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutQuestTagSourceInput, AppliedTagUncheckedCreateWithoutQuestTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutQuestTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type CharacterQuestUncheckedCreateNestedManyWithoutQuestInput = {
    create?: XOR<CharacterQuestCreateWithoutQuestInput, CharacterQuestUncheckedCreateWithoutQuestInput> | CharacterQuestCreateWithoutQuestInput[] | CharacterQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutQuestInput | CharacterQuestCreateOrConnectWithoutQuestInput[]
    createMany?: CharacterQuestCreateManyQuestInputEnvelope
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
  }

  export type StatModiferUncheckedCreateNestedOneWithoutQuestSourceInput = {
    create?: XOR<StatModiferCreateWithoutQuestSourceInput, StatModiferUncheckedCreateWithoutQuestSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutQuestSourceInput
    connect?: StatModiferWhereUniqueInput
  }

  export type AppliedTagUncheckedCreateNestedOneWithoutQuestTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutQuestTagSourceInput, AppliedTagUncheckedCreateWithoutQuestTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutQuestTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutCreatedQuestsNestedInput = {
    create?: XOR<AccountCreateWithoutCreatedQuestsInput, AccountUncheckedCreateWithoutCreatedQuestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCreatedQuestsInput
    upsert?: AccountUpsertWithoutCreatedQuestsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCreatedQuestsInput, AccountUpdateWithoutCreatedQuestsInput>, AccountUncheckedUpdateWithoutCreatedQuestsInput>
  }

  export type AccountUpdateOneRequiredWithoutModifiedQuestsNestedInput = {
    create?: XOR<AccountCreateWithoutModifiedQuestsInput, AccountUncheckedCreateWithoutModifiedQuestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutModifiedQuestsInput
    upsert?: AccountUpsertWithoutModifiedQuestsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutModifiedQuestsInput, AccountUpdateWithoutModifiedQuestsInput>, AccountUncheckedUpdateWithoutModifiedQuestsInput>
  }

  export type CharacterQuestUpdateManyWithoutQuestNestedInput = {
    create?: XOR<CharacterQuestCreateWithoutQuestInput, CharacterQuestUncheckedCreateWithoutQuestInput> | CharacterQuestCreateWithoutQuestInput[] | CharacterQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutQuestInput | CharacterQuestCreateOrConnectWithoutQuestInput[]
    upsert?: CharacterQuestUpsertWithWhereUniqueWithoutQuestInput | CharacterQuestUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: CharacterQuestCreateManyQuestInputEnvelope
    set?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    disconnect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    delete?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    update?: CharacterQuestUpdateWithWhereUniqueWithoutQuestInput | CharacterQuestUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: CharacterQuestUpdateManyWithWhereWithoutQuestInput | CharacterQuestUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: CharacterQuestScalarWhereInput | CharacterQuestScalarWhereInput[]
  }

  export type StatModiferUpdateOneWithoutQuestSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutQuestSourceInput, StatModiferUncheckedCreateWithoutQuestSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutQuestSourceInput
    upsert?: StatModiferUpsertWithoutQuestSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutQuestSourceInput, StatModiferUpdateWithoutQuestSourceInput>, StatModiferUncheckedUpdateWithoutQuestSourceInput>
  }

  export type AppliedTagUpdateOneWithoutQuestTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutQuestTagSourceInput, AppliedTagUncheckedCreateWithoutQuestTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutQuestTagSourceInput
    upsert?: AppliedTagUpsertWithoutQuestTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutQuestTagSourceInput, AppliedTagUpdateWithoutQuestTagSourceInput>, AppliedTagUncheckedUpdateWithoutQuestTagSourceInput>
  }

  export type CharacterQuestUncheckedUpdateManyWithoutQuestNestedInput = {
    create?: XOR<CharacterQuestCreateWithoutQuestInput, CharacterQuestUncheckedCreateWithoutQuestInput> | CharacterQuestCreateWithoutQuestInput[] | CharacterQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: CharacterQuestCreateOrConnectWithoutQuestInput | CharacterQuestCreateOrConnectWithoutQuestInput[]
    upsert?: CharacterQuestUpsertWithWhereUniqueWithoutQuestInput | CharacterQuestUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: CharacterQuestCreateManyQuestInputEnvelope
    set?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    disconnect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    delete?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    connect?: CharacterQuestWhereUniqueInput | CharacterQuestWhereUniqueInput[]
    update?: CharacterQuestUpdateWithWhereUniqueWithoutQuestInput | CharacterQuestUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: CharacterQuestUpdateManyWithWhereWithoutQuestInput | CharacterQuestUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: CharacterQuestScalarWhereInput | CharacterQuestScalarWhereInput[]
  }

  export type StatModiferUncheckedUpdateOneWithoutQuestSourceNestedInput = {
    create?: XOR<StatModiferCreateWithoutQuestSourceInput, StatModiferUncheckedCreateWithoutQuestSourceInput>
    connectOrCreate?: StatModiferCreateOrConnectWithoutQuestSourceInput
    upsert?: StatModiferUpsertWithoutQuestSourceInput
    disconnect?: StatModiferWhereInput | boolean
    delete?: StatModiferWhereInput | boolean
    connect?: StatModiferWhereUniqueInput
    update?: XOR<XOR<StatModiferUpdateToOneWithWhereWithoutQuestSourceInput, StatModiferUpdateWithoutQuestSourceInput>, StatModiferUncheckedUpdateWithoutQuestSourceInput>
  }

  export type AppliedTagUncheckedUpdateOneWithoutQuestTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutQuestTagSourceInput, AppliedTagUncheckedCreateWithoutQuestTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutQuestTagSourceInput
    upsert?: AppliedTagUpsertWithoutQuestTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutQuestTagSourceInput, AppliedTagUpdateWithoutQuestTagSourceInput>, AppliedTagUncheckedUpdateWithoutQuestTagSourceInput>
  }

  export type ItemCreateNestedOneWithoutStatModiferInput = {
    create?: XOR<ItemCreateWithoutStatModiferInput, ItemUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStatModiferInput
    connect?: ItemWhereUniqueInput
  }

  export type QuestCreateNestedOneWithoutStatModiferInput = {
    create?: XOR<QuestCreateWithoutStatModiferInput, QuestUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: QuestCreateOrConnectWithoutStatModiferInput
    connect?: QuestWhereUniqueInput
  }

  export type AbilityCreateNestedOneWithoutStatModiferInput = {
    create?: XOR<AbilityCreateWithoutStatModiferInput, AbilityUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: AbilityCreateOrConnectWithoutStatModiferInput
    connect?: AbilityWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutStatModiferInput = {
    create?: XOR<SkillCreateWithoutStatModiferInput, SkillUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: SkillCreateOrConnectWithoutStatModiferInput
    connect?: SkillWhereUniqueInput
  }

  export type SpellCreateNestedOneWithoutStatModiferInput = {
    create?: XOR<SpellCreateWithoutStatModiferInput, SpellUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: SpellCreateOrConnectWithoutStatModiferInput
    connect?: SpellWhereUniqueInput
  }

  export type PotionCreateNestedOneWithoutStatModiferInput = {
    create?: XOR<PotionCreateWithoutStatModiferInput, PotionUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: PotionCreateOrConnectWithoutStatModiferInput
    connect?: PotionWhereUniqueInput
  }

  export type EnumStatModifierTypeFieldUpdateOperationsInput = {
    set?: $Enums.StatModifierType
  }

  export type ItemUpdateOneWithoutStatModiferNestedInput = {
    create?: XOR<ItemCreateWithoutStatModiferInput, ItemUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStatModiferInput
    upsert?: ItemUpsertWithoutStatModiferInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutStatModiferInput, ItemUpdateWithoutStatModiferInput>, ItemUncheckedUpdateWithoutStatModiferInput>
  }

  export type QuestUpdateOneWithoutStatModiferNestedInput = {
    create?: XOR<QuestCreateWithoutStatModiferInput, QuestUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: QuestCreateOrConnectWithoutStatModiferInput
    upsert?: QuestUpsertWithoutStatModiferInput
    disconnect?: QuestWhereInput | boolean
    delete?: QuestWhereInput | boolean
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutStatModiferInput, QuestUpdateWithoutStatModiferInput>, QuestUncheckedUpdateWithoutStatModiferInput>
  }

  export type AbilityUpdateOneWithoutStatModiferNestedInput = {
    create?: XOR<AbilityCreateWithoutStatModiferInput, AbilityUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: AbilityCreateOrConnectWithoutStatModiferInput
    upsert?: AbilityUpsertWithoutStatModiferInput
    disconnect?: AbilityWhereInput | boolean
    delete?: AbilityWhereInput | boolean
    connect?: AbilityWhereUniqueInput
    update?: XOR<XOR<AbilityUpdateToOneWithWhereWithoutStatModiferInput, AbilityUpdateWithoutStatModiferInput>, AbilityUncheckedUpdateWithoutStatModiferInput>
  }

  export type SkillUpdateOneWithoutStatModiferNestedInput = {
    create?: XOR<SkillCreateWithoutStatModiferInput, SkillUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: SkillCreateOrConnectWithoutStatModiferInput
    upsert?: SkillUpsertWithoutStatModiferInput
    disconnect?: SkillWhereInput | boolean
    delete?: SkillWhereInput | boolean
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutStatModiferInput, SkillUpdateWithoutStatModiferInput>, SkillUncheckedUpdateWithoutStatModiferInput>
  }

  export type SpellUpdateOneWithoutStatModiferNestedInput = {
    create?: XOR<SpellCreateWithoutStatModiferInput, SpellUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: SpellCreateOrConnectWithoutStatModiferInput
    upsert?: SpellUpsertWithoutStatModiferInput
    disconnect?: SpellWhereInput | boolean
    delete?: SpellWhereInput | boolean
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutStatModiferInput, SpellUpdateWithoutStatModiferInput>, SpellUncheckedUpdateWithoutStatModiferInput>
  }

  export type PotionUpdateOneWithoutStatModiferNestedInput = {
    create?: XOR<PotionCreateWithoutStatModiferInput, PotionUncheckedCreateWithoutStatModiferInput>
    connectOrCreate?: PotionCreateOrConnectWithoutStatModiferInput
    upsert?: PotionUpsertWithoutStatModiferInput
    disconnect?: PotionWhereInput | boolean
    delete?: PotionWhereInput | boolean
    connect?: PotionWhereUniqueInput
    update?: XOR<XOR<PotionUpdateToOneWithWhereWithoutStatModiferInput, PotionUpdateWithoutStatModiferInput>, PotionUncheckedUpdateWithoutStatModiferInput>
  }

  export type AccountCreateNestedOneWithoutArticleInput = {
    create?: XOR<AccountCreateWithoutArticleInput, AccountUncheckedCreateWithoutArticleInput>
    connectOrCreate?: AccountCreateOrConnectWithoutArticleInput
    connect?: AccountWhereUniqueInput
  }

  export type ArticleVersionCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
  }

  export type AppliedTagCreateNestedOneWithoutArticleTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutArticleTagSourceInput, AppliedTagUncheckedCreateWithoutArticleTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutArticleTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type ArticleVersionUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
  }

  export type AppliedTagUncheckedCreateNestedOneWithoutArticleTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutArticleTagSourceInput, AppliedTagUncheckedCreateWithoutArticleTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutArticleTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutArticleNestedInput = {
    create?: XOR<AccountCreateWithoutArticleInput, AccountUncheckedCreateWithoutArticleInput>
    connectOrCreate?: AccountCreateOrConnectWithoutArticleInput
    upsert?: AccountUpsertWithoutArticleInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutArticleInput, AccountUpdateWithoutArticleInput>, AccountUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleVersionUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleVersionUpsertWithWhereUniqueWithoutArticleInput | ArticleVersionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    set?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    disconnect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    delete?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    update?: ArticleVersionUpdateWithWhereUniqueWithoutArticleInput | ArticleVersionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleVersionUpdateManyWithWhereWithoutArticleInput | ArticleVersionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
  }

  export type AppliedTagUpdateOneWithoutArticleTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutArticleTagSourceInput, AppliedTagUncheckedCreateWithoutArticleTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutArticleTagSourceInput
    upsert?: AppliedTagUpsertWithoutArticleTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutArticleTagSourceInput, AppliedTagUpdateWithoutArticleTagSourceInput>, AppliedTagUncheckedUpdateWithoutArticleTagSourceInput>
  }

  export type ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleVersionUpsertWithWhereUniqueWithoutArticleInput | ArticleVersionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    set?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    disconnect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    delete?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    update?: ArticleVersionUpdateWithWhereUniqueWithoutArticleInput | ArticleVersionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleVersionUpdateManyWithWhereWithoutArticleInput | ArticleVersionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
  }

  export type AppliedTagUncheckedUpdateOneWithoutArticleTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutArticleTagSourceInput, AppliedTagUncheckedCreateWithoutArticleTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutArticleTagSourceInput
    upsert?: AppliedTagUpsertWithoutArticleTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutArticleTagSourceInput, AppliedTagUpdateWithoutArticleTagSourceInput>, AppliedTagUncheckedUpdateWithoutArticleTagSourceInput>
  }

  export type AccountCreateNestedOneWithoutArticleVersionInput = {
    create?: XOR<AccountCreateWithoutArticleVersionInput, AccountUncheckedCreateWithoutArticleVersionInput>
    connectOrCreate?: AccountCreateOrConnectWithoutArticleVersionInput
    connect?: AccountWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutArticleContentInput = {
    create?: XOR<ArticleCreateWithoutArticleContentInput, ArticleUncheckedCreateWithoutArticleContentInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleContentInput
    connect?: ArticleWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutArticleVersionNestedInput = {
    create?: XOR<AccountCreateWithoutArticleVersionInput, AccountUncheckedCreateWithoutArticleVersionInput>
    connectOrCreate?: AccountCreateOrConnectWithoutArticleVersionInput
    upsert?: AccountUpsertWithoutArticleVersionInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutArticleVersionInput, AccountUpdateWithoutArticleVersionInput>, AccountUncheckedUpdateWithoutArticleVersionInput>
  }

  export type ArticleUpdateOneRequiredWithoutArticleContentNestedInput = {
    create?: XOR<ArticleCreateWithoutArticleContentInput, ArticleUncheckedCreateWithoutArticleContentInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleContentInput
    upsert?: ArticleUpsertWithoutArticleContentInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutArticleContentInput, ArticleUpdateWithoutArticleContentInput>, ArticleUncheckedUpdateWithoutArticleContentInput>
  }

  export type AccountCreateNestedOneWithoutTagInput = {
    create?: XOR<AccountCreateWithoutTagInput, AccountUncheckedCreateWithoutTagInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTagInput
    connect?: AccountWhereUniqueInput
  }

  export type AppliedTagCreateNestedManyWithoutTagInput = {
    create?: XOR<AppliedTagCreateWithoutTagInput, AppliedTagUncheckedCreateWithoutTagInput> | AppliedTagCreateWithoutTagInput[] | AppliedTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: AppliedTagCreateOrConnectWithoutTagInput | AppliedTagCreateOrConnectWithoutTagInput[]
    createMany?: AppliedTagCreateManyTagInputEnvelope
    connect?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
  }

  export type AppliedTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<AppliedTagCreateWithoutTagInput, AppliedTagUncheckedCreateWithoutTagInput> | AppliedTagCreateWithoutTagInput[] | AppliedTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: AppliedTagCreateOrConnectWithoutTagInput | AppliedTagCreateOrConnectWithoutTagInput[]
    createMany?: AppliedTagCreateManyTagInputEnvelope
    connect?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutTagNestedInput = {
    create?: XOR<AccountCreateWithoutTagInput, AccountUncheckedCreateWithoutTagInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTagInput
    upsert?: AccountUpsertWithoutTagInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTagInput, AccountUpdateWithoutTagInput>, AccountUncheckedUpdateWithoutTagInput>
  }

  export type AppliedTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<AppliedTagCreateWithoutTagInput, AppliedTagUncheckedCreateWithoutTagInput> | AppliedTagCreateWithoutTagInput[] | AppliedTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: AppliedTagCreateOrConnectWithoutTagInput | AppliedTagCreateOrConnectWithoutTagInput[]
    upsert?: AppliedTagUpsertWithWhereUniqueWithoutTagInput | AppliedTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: AppliedTagCreateManyTagInputEnvelope
    set?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    disconnect?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    delete?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    connect?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    update?: AppliedTagUpdateWithWhereUniqueWithoutTagInput | AppliedTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: AppliedTagUpdateManyWithWhereWithoutTagInput | AppliedTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: AppliedTagScalarWhereInput | AppliedTagScalarWhereInput[]
  }

  export type AppliedTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<AppliedTagCreateWithoutTagInput, AppliedTagUncheckedCreateWithoutTagInput> | AppliedTagCreateWithoutTagInput[] | AppliedTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: AppliedTagCreateOrConnectWithoutTagInput | AppliedTagCreateOrConnectWithoutTagInput[]
    upsert?: AppliedTagUpsertWithWhereUniqueWithoutTagInput | AppliedTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: AppliedTagCreateManyTagInputEnvelope
    set?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    disconnect?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    delete?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    connect?: AppliedTagWhereUniqueInput | AppliedTagWhereUniqueInput[]
    update?: AppliedTagUpdateWithWhereUniqueWithoutTagInput | AppliedTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: AppliedTagUpdateManyWithWhereWithoutTagInput | AppliedTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: AppliedTagScalarWhereInput | AppliedTagScalarWhereInput[]
  }

  export type TagCreateNestedOneWithoutAppliedTagInput = {
    create?: XOR<TagCreateWithoutAppliedTagInput, TagUncheckedCreateWithoutAppliedTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutAppliedTagInput
    connect?: TagWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutArticleTagSourceInput = {
    create?: XOR<ArticleCreateWithoutArticleTagSourceInput, ArticleUncheckedCreateWithoutArticleTagSourceInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleTagSourceInput
    connect?: ArticleWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutItemTagSourceInput = {
    create?: XOR<ItemCreateWithoutItemTagSourceInput, ItemUncheckedCreateWithoutItemTagSourceInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemTagSourceInput
    connect?: ItemWhereUniqueInput
  }

  export type MobCreateNestedOneWithoutMobTagSourceInput = {
    create?: XOR<MobCreateWithoutMobTagSourceInput, MobUncheckedCreateWithoutMobTagSourceInput>
    connectOrCreate?: MobCreateOrConnectWithoutMobTagSourceInput
    connect?: MobWhereUniqueInput
  }

  export type QuestCreateNestedOneWithoutQuestTagSourceInput = {
    create?: XOR<QuestCreateWithoutQuestTagSourceInput, QuestUncheckedCreateWithoutQuestTagSourceInput>
    connectOrCreate?: QuestCreateOrConnectWithoutQuestTagSourceInput
    connect?: QuestWhereUniqueInput
  }

  export type EnumTagTypeFieldUpdateOperationsInput = {
    set?: $Enums.TagType
  }

  export type TagUpdateOneRequiredWithoutAppliedTagNestedInput = {
    create?: XOR<TagCreateWithoutAppliedTagInput, TagUncheckedCreateWithoutAppliedTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutAppliedTagInput
    upsert?: TagUpsertWithoutAppliedTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutAppliedTagInput, TagUpdateWithoutAppliedTagInput>, TagUncheckedUpdateWithoutAppliedTagInput>
  }

  export type ArticleUpdateOneWithoutArticleTagSourceNestedInput = {
    create?: XOR<ArticleCreateWithoutArticleTagSourceInput, ArticleUncheckedCreateWithoutArticleTagSourceInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticleTagSourceInput
    upsert?: ArticleUpsertWithoutArticleTagSourceInput
    disconnect?: ArticleWhereInput | boolean
    delete?: ArticleWhereInput | boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutArticleTagSourceInput, ArticleUpdateWithoutArticleTagSourceInput>, ArticleUncheckedUpdateWithoutArticleTagSourceInput>
  }

  export type ItemUpdateOneWithoutItemTagSourceNestedInput = {
    create?: XOR<ItemCreateWithoutItemTagSourceInput, ItemUncheckedCreateWithoutItemTagSourceInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemTagSourceInput
    upsert?: ItemUpsertWithoutItemTagSourceInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutItemTagSourceInput, ItemUpdateWithoutItemTagSourceInput>, ItemUncheckedUpdateWithoutItemTagSourceInput>
  }

  export type MobUpdateOneWithoutMobTagSourceNestedInput = {
    create?: XOR<MobCreateWithoutMobTagSourceInput, MobUncheckedCreateWithoutMobTagSourceInput>
    connectOrCreate?: MobCreateOrConnectWithoutMobTagSourceInput
    upsert?: MobUpsertWithoutMobTagSourceInput
    disconnect?: MobWhereInput | boolean
    delete?: MobWhereInput | boolean
    connect?: MobWhereUniqueInput
    update?: XOR<XOR<MobUpdateToOneWithWhereWithoutMobTagSourceInput, MobUpdateWithoutMobTagSourceInput>, MobUncheckedUpdateWithoutMobTagSourceInput>
  }

  export type QuestUpdateOneWithoutQuestTagSourceNestedInput = {
    create?: XOR<QuestCreateWithoutQuestTagSourceInput, QuestUncheckedCreateWithoutQuestTagSourceInput>
    connectOrCreate?: QuestCreateOrConnectWithoutQuestTagSourceInput
    upsert?: QuestUpsertWithoutQuestTagSourceInput
    disconnect?: QuestWhereInput | boolean
    delete?: QuestWhereInput | boolean
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutQuestTagSourceInput, QuestUpdateWithoutQuestTagSourceInput>, QuestUncheckedUpdateWithoutQuestTagSourceInput>
  }

  export type AppliedTagCreateNestedOneWithoutMobTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutMobTagSourceInput, AppliedTagUncheckedCreateWithoutMobTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutMobTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type AreaCreateNestedOneWithoutMobInput = {
    create?: XOR<AreaCreateWithoutMobInput, AreaUncheckedCreateWithoutMobInput>
    connectOrCreate?: AreaCreateOrConnectWithoutMobInput
    connect?: AreaWhereUniqueInput
  }

  export type AppliedTagUncheckedCreateNestedOneWithoutMobTagSourceInput = {
    create?: XOR<AppliedTagCreateWithoutMobTagSourceInput, AppliedTagUncheckedCreateWithoutMobTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutMobTagSourceInput
    connect?: AppliedTagWhereUniqueInput
  }

  export type AppliedTagUpdateOneWithoutMobTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutMobTagSourceInput, AppliedTagUncheckedCreateWithoutMobTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutMobTagSourceInput
    upsert?: AppliedTagUpsertWithoutMobTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutMobTagSourceInput, AppliedTagUpdateWithoutMobTagSourceInput>, AppliedTagUncheckedUpdateWithoutMobTagSourceInput>
  }

  export type AreaUpdateOneWithoutMobNestedInput = {
    create?: XOR<AreaCreateWithoutMobInput, AreaUncheckedCreateWithoutMobInput>
    connectOrCreate?: AreaCreateOrConnectWithoutMobInput
    upsert?: AreaUpsertWithoutMobInput
    disconnect?: AreaWhereInput | boolean
    delete?: AreaWhereInput | boolean
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutMobInput, AreaUpdateWithoutMobInput>, AreaUncheckedUpdateWithoutMobInput>
  }

  export type AppliedTagUncheckedUpdateOneWithoutMobTagSourceNestedInput = {
    create?: XOR<AppliedTagCreateWithoutMobTagSourceInput, AppliedTagUncheckedCreateWithoutMobTagSourceInput>
    connectOrCreate?: AppliedTagCreateOrConnectWithoutMobTagSourceInput
    upsert?: AppliedTagUpsertWithoutMobTagSourceInput
    disconnect?: AppliedTagWhereInput | boolean
    delete?: AppliedTagWhereInput | boolean
    connect?: AppliedTagWhereUniqueInput
    update?: XOR<XOR<AppliedTagUpdateToOneWithWhereWithoutMobTagSourceInput, AppliedTagUpdateWithoutMobTagSourceInput>, AppliedTagUncheckedUpdateWithoutMobTagSourceInput>
  }

  export type AccountCreateNestedOneWithoutAreaInput = {
    create?: XOR<AccountCreateWithoutAreaInput, AccountUncheckedCreateWithoutAreaInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAreaInput
    connect?: AccountWhereUniqueInput
  }

  export type MobCreateNestedManyWithoutAreaInput = {
    create?: XOR<MobCreateWithoutAreaInput, MobUncheckedCreateWithoutAreaInput> | MobCreateWithoutAreaInput[] | MobUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MobCreateOrConnectWithoutAreaInput | MobCreateOrConnectWithoutAreaInput[]
    createMany?: MobCreateManyAreaInputEnvelope
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
  }

  export type MobUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<MobCreateWithoutAreaInput, MobUncheckedCreateWithoutAreaInput> | MobCreateWithoutAreaInput[] | MobUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MobCreateOrConnectWithoutAreaInput | MobCreateOrConnectWithoutAreaInput[]
    createMany?: MobCreateManyAreaInputEnvelope
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
  }

  export type AccountUpdateOneWithoutAreaNestedInput = {
    create?: XOR<AccountCreateWithoutAreaInput, AccountUncheckedCreateWithoutAreaInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAreaInput
    upsert?: AccountUpsertWithoutAreaInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAreaInput, AccountUpdateWithoutAreaInput>, AccountUncheckedUpdateWithoutAreaInput>
  }

  export type MobUpdateManyWithoutAreaNestedInput = {
    create?: XOR<MobCreateWithoutAreaInput, MobUncheckedCreateWithoutAreaInput> | MobCreateWithoutAreaInput[] | MobUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MobCreateOrConnectWithoutAreaInput | MobCreateOrConnectWithoutAreaInput[]
    upsert?: MobUpsertWithWhereUniqueWithoutAreaInput | MobUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: MobCreateManyAreaInputEnvelope
    set?: MobWhereUniqueInput | MobWhereUniqueInput[]
    disconnect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    delete?: MobWhereUniqueInput | MobWhereUniqueInput[]
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    update?: MobUpdateWithWhereUniqueWithoutAreaInput | MobUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: MobUpdateManyWithWhereWithoutAreaInput | MobUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: MobScalarWhereInput | MobScalarWhereInput[]
  }

  export type MobUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<MobCreateWithoutAreaInput, MobUncheckedCreateWithoutAreaInput> | MobCreateWithoutAreaInput[] | MobUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: MobCreateOrConnectWithoutAreaInput | MobCreateOrConnectWithoutAreaInput[]
    upsert?: MobUpsertWithWhereUniqueWithoutAreaInput | MobUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: MobCreateManyAreaInputEnvelope
    set?: MobWhereUniqueInput | MobWhereUniqueInput[]
    disconnect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    delete?: MobWhereUniqueInput | MobWhereUniqueInput[]
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    update?: MobUpdateWithWhereUniqueWithoutAreaInput | MobUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: MobUpdateManyWithWhereWithoutAreaInput | MobUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: MobScalarWhereInput | MobScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutChangeLogInput = {
    create?: XOR<AccountCreateWithoutChangeLogInput, AccountUncheckedCreateWithoutChangeLogInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChangeLogInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneWithoutChangeLogNestedInput = {
    create?: XOR<AccountCreateWithoutChangeLogInput, AccountUncheckedCreateWithoutChangeLogInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChangeLogInput
    upsert?: AccountUpsertWithoutChangeLogInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutChangeLogInput, AccountUpdateWithoutChangeLogInput>, AccountUncheckedUpdateWithoutChangeLogInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAlignNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Align | EnumAlignFieldRefInput<$PrismaModel> | null
    in?: $Enums.Align[] | null
    notIn?: $Enums.Align[] | null
    not?: NestedEnumAlignNullableFilter<$PrismaModel> | $Enums.Align | null
  }

  export type NestedEnumAlignNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Align | EnumAlignFieldRefInput<$PrismaModel> | null
    in?: $Enums.Align[] | null
    notIn?: $Enums.Align[] | null
    not?: NestedEnumAlignNullableWithAggregatesFilter<$PrismaModel> | $Enums.Align | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAlignNullableFilter<$PrismaModel>
    _max?: NestedEnumAlignNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumWeaponStatNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponStat | EnumWeaponStatFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponStat[] | null
    notIn?: $Enums.WeaponStat[] | null
    not?: NestedEnumWeaponStatNullableFilter<$PrismaModel> | $Enums.WeaponStat | null
  }

  export type NestedEnumWeaponTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | null
    notIn?: $Enums.WeaponType[] | null
    not?: NestedEnumWeaponTypeNullableFilter<$PrismaModel> | $Enums.WeaponType | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumWeaponStatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponStat | EnumWeaponStatFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponStat[] | null
    notIn?: $Enums.WeaponStat[] | null
    not?: NestedEnumWeaponStatNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeaponStat | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeaponStatNullableFilter<$PrismaModel>
    _max?: NestedEnumWeaponStatNullableFilter<$PrismaModel>
  }

  export type NestedEnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | null
    notIn?: $Enums.WeaponType[] | null
    not?: NestedEnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeaponType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatModifierTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatModifierType | EnumStatModifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatModifierType[]
    notIn?: $Enums.StatModifierType[]
    not?: NestedEnumStatModifierTypeFilter<$PrismaModel> | $Enums.StatModifierType
  }

  export type NestedEnumStatModifierTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatModifierType | EnumStatModifierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatModifierType[]
    notIn?: $Enums.StatModifierType[]
    not?: NestedEnumStatModifierTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatModifierType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatModifierTypeFilter<$PrismaModel>
    _max?: NestedEnumStatModifierTypeFilter<$PrismaModel>
  }

  export type NestedEnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[]
    notIn?: $Enums.TagType[]
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type NestedEnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[]
    notIn?: $Enums.TagType[]
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type AccountNotificationCreateWithoutAccountInput = {
    notificationId: number
    read?: boolean | null
    readDate?: Date | string | null
  }

  export type AccountNotificationUncheckedCreateWithoutAccountInput = {
    id?: number
    notificationId: number
    read?: boolean | null
    readDate?: Date | string | null
  }

  export type AccountNotificationCreateOrConnectWithoutAccountInput = {
    where: AccountNotificationWhereUniqueInput
    create: XOR<AccountNotificationCreateWithoutAccountInput, AccountNotificationUncheckedCreateWithoutAccountInput>
  }

  export type AccountNotificationCreateManyAccountInputEnvelope = {
    data: AccountNotificationCreateManyAccountInput | AccountNotificationCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AccountPasswordCreateWithoutAccountInput = {
    passwordHash: string
  }

  export type AccountPasswordUncheckedCreateWithoutAccountInput = {
    id?: number
    passwordHash: string
  }

  export type AccountPasswordCreateOrConnectWithoutAccountInput = {
    where: AccountPasswordWhereUniqueInput
    create: XOR<AccountPasswordCreateWithoutAccountInput, AccountPasswordUncheckedCreateWithoutAccountInput>
  }

  export type AccountPasswordCreateManyAccountInputEnvelope = {
    data: AccountPasswordCreateManyAccountInput | AccountPasswordCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CharacterCreateWithoutAccountInput = {
    mudId?: number | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
    CharacterVersion?: CharacterVersionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutAccountInput = {
    id?: number
    mudId?: number | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
    CharacterVersion?: CharacterVersionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutAccountInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput>
  }

  export type CharacterCreateManyAccountInputEnvelope = {
    data: CharacterCreateManyAccountInput | CharacterCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type NetworkHistoryCreateWithoutAccountInput = {
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutNetworkHistoryInput
  }

  export type NetworkHistoryUncheckedCreateWithoutAccountInput = {
    id?: number
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutNetworkHistoryInput
  }

  export type NetworkHistoryCreateOrConnectWithoutAccountInput = {
    where: NetworkHistoryWhereUniqueInput
    create: XOR<NetworkHistoryCreateWithoutAccountInput, NetworkHistoryUncheckedCreateWithoutAccountInput>
  }

  export type NetworkHistoryCreateManyAccountInputEnvelope = {
    data: NetworkHistoryCreateManyAccountInput | NetworkHistoryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type NetworkBlacklistCreateWithoutAccountInput = {
    issueDate: Date | string
    termDate: Date | string
    NetworkHistory: NetworkHistoryCreateNestedOneWithoutNetworkBlacklistInput
  }

  export type NetworkBlacklistUncheckedCreateWithoutAccountInput = {
    id?: number
    networkHistoryId: number
    issueDate: Date | string
    termDate: Date | string
  }

  export type NetworkBlacklistCreateOrConnectWithoutAccountInput = {
    where: NetworkBlacklistWhereUniqueInput
    create: XOR<NetworkBlacklistCreateWithoutAccountInput, NetworkBlacklistUncheckedCreateWithoutAccountInput>
  }

  export type NetworkBlacklistCreateManyAccountInputEnvelope = {
    data: NetworkBlacklistCreateManyAccountInput | NetworkBlacklistCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutAccountInput = {
    createdDate: Date | string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    content?: string | null
  }

  export type NotificationUncheckedCreateWithoutAccountInput = {
    id?: number
    createdDate: Date | string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    content?: string | null
  }

  export type NotificationCreateOrConnectWithoutAccountInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
  }

  export type NotificationCreateManyAccountInputEnvelope = {
    data: NotificationCreateManyAccountInput | NotificationCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutCreatedItemsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ModifiedItems?: AccountCreateNestedOneWithoutModifiedItemsInput
    ItemSpell?: ItemSpellCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUncheckedCreateWithoutCreatedItemsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponUncheckedCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemCreateOrConnectWithoutCreatedItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCreatedItemsInput, ItemUncheckedCreateWithoutCreatedItemsInput>
  }

  export type ItemCreateManyCreatedItemsInputEnvelope = {
    data: ItemCreateManyCreatedItemsInput | ItemCreateManyCreatedItemsInput[]
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutModifiedItemsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    CreatedItems: AccountCreateNestedOneWithoutCreatedItemsInput
    ItemSpell?: ItemSpellCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUncheckedCreateWithoutModifiedItemsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponUncheckedCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemCreateOrConnectWithoutModifiedItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutModifiedItemsInput, ItemUncheckedCreateWithoutModifiedItemsInput>
  }

  export type ItemCreateManyModifiedItemsInputEnvelope = {
    data: ItemCreateManyModifiedItemsInput | ItemCreateManyModifiedItemsInput[]
    skipDuplicates?: boolean
  }

  export type SpellCreateWithoutCreatedSpellsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellCreateNestedManyWithoutSpellInput
    ModifiedSpells: AccountCreateNestedOneWithoutModifiedSpellsInput
    StatModifer?: StatModiferCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellUncheckedCreateWithoutCreatedSpellsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutSpellInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellCreateOrConnectWithoutCreatedSpellsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutCreatedSpellsInput, SpellUncheckedCreateWithoutCreatedSpellsInput>
  }

  export type SpellCreateManyCreatedSpellsInputEnvelope = {
    data: SpellCreateManyCreatedSpellsInput | SpellCreateManyCreatedSpellsInput[]
    skipDuplicates?: boolean
  }

  export type SpellCreateWithoutModifiedSpellsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellCreateNestedManyWithoutSpellInput
    CreatedSpells: AccountCreateNestedOneWithoutCreatedSpellsInput
    StatModifer?: StatModiferCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellUncheckedCreateWithoutModifiedSpellsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutSpellInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellCreateOrConnectWithoutModifiedSpellsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutModifiedSpellsInput, SpellUncheckedCreateWithoutModifiedSpellsInput>
  }

  export type SpellCreateManyModifiedSpellsInputEnvelope = {
    data: SpellCreateManyModifiedSpellsInput | SpellCreateManyModifiedSpellsInput[]
    skipDuplicates?: boolean
  }

  export type PotionCreateWithoutCreatedPotionsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
    ModifiedPotions: AccountCreateNestedOneWithoutModifiedPotionsInput
    StatModifer?: StatModiferCreateNestedOneWithoutPotionSourceInput
  }

  export type PotionUncheckedCreateWithoutCreatedPotionsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutPotionSourceInput
  }

  export type PotionCreateOrConnectWithoutCreatedPotionsInput = {
    where: PotionWhereUniqueInput
    create: XOR<PotionCreateWithoutCreatedPotionsInput, PotionUncheckedCreateWithoutCreatedPotionsInput>
  }

  export type PotionCreateManyCreatedPotionsInputEnvelope = {
    data: PotionCreateManyCreatedPotionsInput | PotionCreateManyCreatedPotionsInput[]
    skipDuplicates?: boolean
  }

  export type PotionCreateWithoutModifiedPotionsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
    CreatedPotions: AccountCreateNestedOneWithoutCreatedPotionsInput
    StatModifer?: StatModiferCreateNestedOneWithoutPotionSourceInput
  }

  export type PotionUncheckedCreateWithoutModifiedPotionsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutPotionSourceInput
  }

  export type PotionCreateOrConnectWithoutModifiedPotionsInput = {
    where: PotionWhereUniqueInput
    create: XOR<PotionCreateWithoutModifiedPotionsInput, PotionUncheckedCreateWithoutModifiedPotionsInput>
  }

  export type PotionCreateManyModifiedPotionsInputEnvelope = {
    data: PotionCreateManyModifiedPotionsInput | PotionCreateManyModifiedPotionsInput[]
    skipDuplicates?: boolean
  }

  export type SkillCreateWithoutCreatedSkillsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
    ModifiedSkills: AccountCreateNestedOneWithoutModifiedSkillsInput
    StatModifer?: StatModiferCreateNestedOneWithoutSkillSourceInput
  }

  export type SkillUncheckedCreateWithoutCreatedSkillsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutSkillSourceInput
  }

  export type SkillCreateOrConnectWithoutCreatedSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCreatedSkillsInput, SkillUncheckedCreateWithoutCreatedSkillsInput>
  }

  export type SkillCreateManyCreatedSkillsInputEnvelope = {
    data: SkillCreateManyCreatedSkillsInput | SkillCreateManyCreatedSkillsInput[]
    skipDuplicates?: boolean
  }

  export type SkillCreateWithoutModifiedSkillsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
    CreatedSkills: AccountCreateNestedOneWithoutCreatedSkillsInput
    StatModifer?: StatModiferCreateNestedOneWithoutSkillSourceInput
  }

  export type SkillUncheckedCreateWithoutModifiedSkillsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutSkillSourceInput
  }

  export type SkillCreateOrConnectWithoutModifiedSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutModifiedSkillsInput, SkillUncheckedCreateWithoutModifiedSkillsInput>
  }

  export type SkillCreateManyModifiedSkillsInputEnvelope = {
    data: SkillCreateManyModifiedSkillsInput | SkillCreateManyModifiedSkillsInput[]
    skipDuplicates?: boolean
  }

  export type AbilityCreateWithoutCreatedAbilitiesInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
    ModifiedAbilities: AccountCreateNestedOneWithoutModifiedAbilitiesInput
    StatModifer?: StatModiferCreateNestedOneWithoutAbilitySourceInput
  }

  export type AbilityUncheckedCreateWithoutCreatedAbilitiesInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutAbilitySourceInput
  }

  export type AbilityCreateOrConnectWithoutCreatedAbilitiesInput = {
    where: AbilityWhereUniqueInput
    create: XOR<AbilityCreateWithoutCreatedAbilitiesInput, AbilityUncheckedCreateWithoutCreatedAbilitiesInput>
  }

  export type AbilityCreateManyCreatedAbilitiesInputEnvelope = {
    data: AbilityCreateManyCreatedAbilitiesInput | AbilityCreateManyCreatedAbilitiesInput[]
    skipDuplicates?: boolean
  }

  export type AbilityCreateWithoutModifiedAbilitiesInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
    CreatedAbilities: AccountCreateNestedOneWithoutCreatedAbilitiesInput
    StatModifer?: StatModiferCreateNestedOneWithoutAbilitySourceInput
  }

  export type AbilityUncheckedCreateWithoutModifiedAbilitiesInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutAbilitySourceInput
  }

  export type AbilityCreateOrConnectWithoutModifiedAbilitiesInput = {
    where: AbilityWhereUniqueInput
    create: XOR<AbilityCreateWithoutModifiedAbilitiesInput, AbilityUncheckedCreateWithoutModifiedAbilitiesInput>
  }

  export type AbilityCreateManyModifiedAbilitiesInputEnvelope = {
    data: AbilityCreateManyModifiedAbilitiesInput | AbilityCreateManyModifiedAbilitiesInput[]
    skipDuplicates?: boolean
  }

  export type QuestCreateWithoutCreatedQuestsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    ModifiedQuests: AccountCreateNestedOneWithoutModifiedQuestsInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestUncheckedCreateWithoutCreatedQuestsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagUncheckedCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestCreateOrConnectWithoutCreatedQuestsInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutCreatedQuestsInput, QuestUncheckedCreateWithoutCreatedQuestsInput>
  }

  export type QuestCreateManyCreatedQuestsInputEnvelope = {
    data: QuestCreateManyCreatedQuestsInput | QuestCreateManyCreatedQuestsInput[]
    skipDuplicates?: boolean
  }

  export type QuestCreateWithoutModifiedQuestsInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CreatedQuests: AccountCreateNestedOneWithoutCreatedQuestsInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestUncheckedCreateWithoutModifiedQuestsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagUncheckedCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestCreateOrConnectWithoutModifiedQuestsInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutModifiedQuestsInput, QuestUncheckedCreateWithoutModifiedQuestsInput>
  }

  export type QuestCreateManyModifiedQuestsInputEnvelope = {
    data: QuestCreateManyModifiedQuestsInput | QuestCreateManyModifiedQuestsInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutAuthorInput = {
    createdDate?: Date | string
    isProtected?: boolean
    ArticleContent?: ArticleVersionCreateNestedManyWithoutArticleInput
    ArticleTagSource?: AppliedTagCreateNestedOneWithoutArticleTagSourceInput
  }

  export type ArticleUncheckedCreateWithoutAuthorInput = {
    id?: number
    createdDate?: Date | string
    isProtected?: boolean
    ArticleContent?: ArticleVersionUncheckedCreateNestedManyWithoutArticleInput
    ArticleTagSource?: AppliedTagUncheckedCreateNestedOneWithoutArticleTagSourceInput
  }

  export type ArticleCreateOrConnectWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleCreateManyAuthorInputEnvelope = {
    data: ArticleCreateManyAuthorInput | ArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ArticleVersionCreateWithoutEditorInput = {
    modifiedDate?: Date | string
    content: string
    isCurrent: boolean
    version?: string | null
    Article: ArticleCreateNestedOneWithoutArticleContentInput
  }

  export type ArticleVersionUncheckedCreateWithoutEditorInput = {
    id?: number
    articleId: number
    modifiedDate?: Date | string
    content: string
    isCurrent: boolean
    version?: string | null
  }

  export type ArticleVersionCreateOrConnectWithoutEditorInput = {
    where: ArticleVersionWhereUniqueInput
    create: XOR<ArticleVersionCreateWithoutEditorInput, ArticleVersionUncheckedCreateWithoutEditorInput>
  }

  export type ArticleVersionCreateManyEditorInputEnvelope = {
    data: ArticleVersionCreateManyEditorInput | ArticleVersionCreateManyEditorInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutCreatorInput = {
    createdDate?: Date | string
    tag: string
    AppliedTag?: AppliedTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutCreatorInput = {
    id?: number
    createdDate?: Date | string
    tag: string
    AppliedTag?: AppliedTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutCreatorInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCreatorInput, TagUncheckedCreateWithoutCreatorInput>
  }

  export type TagCreateManyCreatorInputEnvelope = {
    data: TagCreateManyCreatorInput | TagCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AreaCreateWithoutAuthorInput = {
    mudId?: number | null
    name: string
    releaseDate?: Date | string | null
    Mob?: MobCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutAuthorInput = {
    id?: number
    mudId?: number | null
    name: string
    releaseDate?: Date | string | null
    Mob?: MobUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutAuthorInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutAuthorInput, AreaUncheckedCreateWithoutAuthorInput>
  }

  export type AreaCreateManyAuthorInputEnvelope = {
    data: AreaCreateManyAuthorInput | AreaCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ChangeLogCreateWithoutCreatorInput = {
    createdDate: Date | string
    content?: string | null
    version?: string | null
    releaseDate?: Date | string | null
  }

  export type ChangeLogUncheckedCreateWithoutCreatorInput = {
    id?: number
    createdDate: Date | string
    content?: string | null
    version?: string | null
    releaseDate?: Date | string | null
  }

  export type ChangeLogCreateOrConnectWithoutCreatorInput = {
    where: ChangeLogWhereUniqueInput
    create: XOR<ChangeLogCreateWithoutCreatorInput, ChangeLogUncheckedCreateWithoutCreatorInput>
  }

  export type ChangeLogCreateManyCreatorInputEnvelope = {
    data: ChangeLogCreateManyCreatorInput | ChangeLogCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AccountNotificationUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountNotificationWhereUniqueInput
    update: XOR<AccountNotificationUpdateWithoutAccountInput, AccountNotificationUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountNotificationCreateWithoutAccountInput, AccountNotificationUncheckedCreateWithoutAccountInput>
  }

  export type AccountNotificationUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountNotificationWhereUniqueInput
    data: XOR<AccountNotificationUpdateWithoutAccountInput, AccountNotificationUncheckedUpdateWithoutAccountInput>
  }

  export type AccountNotificationUpdateManyWithWhereWithoutAccountInput = {
    where: AccountNotificationScalarWhereInput
    data: XOR<AccountNotificationUpdateManyMutationInput, AccountNotificationUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountNotificationScalarWhereInput = {
    AND?: AccountNotificationScalarWhereInput | AccountNotificationScalarWhereInput[]
    OR?: AccountNotificationScalarWhereInput[]
    NOT?: AccountNotificationScalarWhereInput | AccountNotificationScalarWhereInput[]
    id?: IntFilter<"AccountNotification"> | number
    accountId?: IntFilter<"AccountNotification"> | number
    notificationId?: IntFilter<"AccountNotification"> | number
    read?: BoolNullableFilter<"AccountNotification"> | boolean | null
    readDate?: DateTimeNullableFilter<"AccountNotification"> | Date | string | null
  }

  export type AccountPasswordUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountPasswordWhereUniqueInput
    update: XOR<AccountPasswordUpdateWithoutAccountInput, AccountPasswordUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountPasswordCreateWithoutAccountInput, AccountPasswordUncheckedCreateWithoutAccountInput>
  }

  export type AccountPasswordUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountPasswordWhereUniqueInput
    data: XOR<AccountPasswordUpdateWithoutAccountInput, AccountPasswordUncheckedUpdateWithoutAccountInput>
  }

  export type AccountPasswordUpdateManyWithWhereWithoutAccountInput = {
    where: AccountPasswordScalarWhereInput
    data: XOR<AccountPasswordUpdateManyMutationInput, AccountPasswordUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountPasswordScalarWhereInput = {
    AND?: AccountPasswordScalarWhereInput | AccountPasswordScalarWhereInput[]
    OR?: AccountPasswordScalarWhereInput[]
    NOT?: AccountPasswordScalarWhereInput | AccountPasswordScalarWhereInput[]
    id?: IntFilter<"AccountPassword"> | number
    accountId?: IntFilter<"AccountPassword"> | number
    passwordHash?: StringFilter<"AccountPassword"> | string
  }

  export type CharacterUpsertWithWhereUniqueWithoutAccountInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutAccountInput, CharacterUncheckedUpdateWithoutAccountInput>
    create: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutAccountInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutAccountInput, CharacterUncheckedUpdateWithoutAccountInput>
  }

  export type CharacterUpdateManyWithWhereWithoutAccountInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutAccountInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: IntFilter<"Character"> | number
    mudId?: IntNullableFilter<"Character"> | number | null
    accountId?: IntFilter<"Character"> | number
    createdDate?: DateTimeFilter<"Character"> | Date | string
    modifiedDate?: DateTimeFilter<"Character"> | Date | string
    name?: StringFilter<"Character"> | string
    description?: StringNullableFilter<"Character"> | string | null
    level?: IntNullableFilter<"Character"> | number | null
  }

  export type NetworkHistoryUpsertWithWhereUniqueWithoutAccountInput = {
    where: NetworkHistoryWhereUniqueInput
    update: XOR<NetworkHistoryUpdateWithoutAccountInput, NetworkHistoryUncheckedUpdateWithoutAccountInput>
    create: XOR<NetworkHistoryCreateWithoutAccountInput, NetworkHistoryUncheckedCreateWithoutAccountInput>
  }

  export type NetworkHistoryUpdateWithWhereUniqueWithoutAccountInput = {
    where: NetworkHistoryWhereUniqueInput
    data: XOR<NetworkHistoryUpdateWithoutAccountInput, NetworkHistoryUncheckedUpdateWithoutAccountInput>
  }

  export type NetworkHistoryUpdateManyWithWhereWithoutAccountInput = {
    where: NetworkHistoryScalarWhereInput
    data: XOR<NetworkHistoryUpdateManyMutationInput, NetworkHistoryUncheckedUpdateManyWithoutAccountInput>
  }

  export type NetworkHistoryScalarWhereInput = {
    AND?: NetworkHistoryScalarWhereInput | NetworkHistoryScalarWhereInput[]
    OR?: NetworkHistoryScalarWhereInput[]
    NOT?: NetworkHistoryScalarWhereInput | NetworkHistoryScalarWhereInput[]
    id?: IntFilter<"NetworkHistory"> | number
    accountId?: IntFilter<"NetworkHistory"> | number
    createdDate?: DateTimeFilter<"NetworkHistory"> | Date | string
    loginDate?: DateTimeFilter<"NetworkHistory"> | Date | string
    ipAddress?: StringFilter<"NetworkHistory"> | string
  }

  export type NetworkBlacklistUpsertWithWhereUniqueWithoutAccountInput = {
    where: NetworkBlacklistWhereUniqueInput
    update: XOR<NetworkBlacklistUpdateWithoutAccountInput, NetworkBlacklistUncheckedUpdateWithoutAccountInput>
    create: XOR<NetworkBlacklistCreateWithoutAccountInput, NetworkBlacklistUncheckedCreateWithoutAccountInput>
  }

  export type NetworkBlacklistUpdateWithWhereUniqueWithoutAccountInput = {
    where: NetworkBlacklistWhereUniqueInput
    data: XOR<NetworkBlacklistUpdateWithoutAccountInput, NetworkBlacklistUncheckedUpdateWithoutAccountInput>
  }

  export type NetworkBlacklistUpdateManyWithWhereWithoutAccountInput = {
    where: NetworkBlacklistScalarWhereInput
    data: XOR<NetworkBlacklistUpdateManyMutationInput, NetworkBlacklistUncheckedUpdateManyWithoutAccountInput>
  }

  export type NetworkBlacklistScalarWhereInput = {
    AND?: NetworkBlacklistScalarWhereInput | NetworkBlacklistScalarWhereInput[]
    OR?: NetworkBlacklistScalarWhereInput[]
    NOT?: NetworkBlacklistScalarWhereInput | NetworkBlacklistScalarWhereInput[]
    id?: IntFilter<"NetworkBlacklist"> | number
    networkHistoryId?: IntFilter<"NetworkBlacklist"> | number
    issueDate?: DateTimeFilter<"NetworkBlacklist"> | Date | string
    termDate?: DateTimeFilter<"NetworkBlacklist"> | Date | string
    issuer?: IntFilter<"NetworkBlacklist"> | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutAccountInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAccountInput, NotificationUncheckedUpdateWithoutAccountInput>
    create: XOR<NotificationCreateWithoutAccountInput, NotificationUncheckedCreateWithoutAccountInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAccountInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAccountInput, NotificationUncheckedUpdateWithoutAccountInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAccountInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAccountInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    createdDate?: DateTimeFilter<"Notification"> | Date | string
    createdBy?: IntFilter<"Notification"> | number
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    description?: StringNullableFilter<"Notification"> | string | null
    content?: StringNullableFilter<"Notification"> | string | null
  }

  export type ItemUpsertWithWhereUniqueWithoutCreatedItemsInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCreatedItemsInput, ItemUncheckedUpdateWithoutCreatedItemsInput>
    create: XOR<ItemCreateWithoutCreatedItemsInput, ItemUncheckedCreateWithoutCreatedItemsInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCreatedItemsInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCreatedItemsInput, ItemUncheckedUpdateWithoutCreatedItemsInput>
  }

  export type ItemUpdateManyWithWhereWithoutCreatedItemsInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutCreatedItemsInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: IntFilter<"Item"> | number
    createdDate?: DateTimeFilter<"Item"> | Date | string
    createdBy?: IntFilter<"Item"> | number
    modifiedDate?: DateTimeNullableFilter<"Item"> | Date | string | null
    modifiedBy?: IntNullableFilter<"Item"> | number | null
    shortDescription?: StringFilter<"Item"> | string
    longDescription?: StringNullableFilter<"Item"> | string | null
    timer?: IntNullableFilter<"Item"> | number | null
    align?: EnumAlignNullableFilter<"Item"> | $Enums.Align | null
    rent?: IntNullableFilter<"Item"> | number | null
    preservable?: BoolNullableFilter<"Item"> | boolean | null
    netStat?: IntNullableFilter<"Item"> | number | null
    notes?: StringNullableFilter<"Item"> | string | null
    weight?: FloatNullableFilter<"Item"> | number | null
    slots?: StringNullableFilter<"Item"> | string | null
    isBonded?: BoolNullableFilter<"Item"> | boolean | null
    isCastable?: BoolNullableFilter<"Item"> | boolean | null
    isHeroic?: BoolNullableFilter<"Item"> | boolean | null
    isLevelRequired?: BoolNullableFilter<"Item"> | boolean | null
    isLight?: BoolNullableFilter<"Item"> | boolean | null
    isLimited?: BoolNullableFilter<"Item"> | boolean | null
    isSoulbound?: BoolNullableFilter<"Item"> | boolean | null
    isUnique?: BoolNullableFilter<"Item"> | boolean | null
  }

  export type ItemUpsertWithWhereUniqueWithoutModifiedItemsInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutModifiedItemsInput, ItemUncheckedUpdateWithoutModifiedItemsInput>
    create: XOR<ItemCreateWithoutModifiedItemsInput, ItemUncheckedCreateWithoutModifiedItemsInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutModifiedItemsInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutModifiedItemsInput, ItemUncheckedUpdateWithoutModifiedItemsInput>
  }

  export type ItemUpdateManyWithWhereWithoutModifiedItemsInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutModifiedItemsInput>
  }

  export type SpellUpsertWithWhereUniqueWithoutCreatedSpellsInput = {
    where: SpellWhereUniqueInput
    update: XOR<SpellUpdateWithoutCreatedSpellsInput, SpellUncheckedUpdateWithoutCreatedSpellsInput>
    create: XOR<SpellCreateWithoutCreatedSpellsInput, SpellUncheckedCreateWithoutCreatedSpellsInput>
  }

  export type SpellUpdateWithWhereUniqueWithoutCreatedSpellsInput = {
    where: SpellWhereUniqueInput
    data: XOR<SpellUpdateWithoutCreatedSpellsInput, SpellUncheckedUpdateWithoutCreatedSpellsInput>
  }

  export type SpellUpdateManyWithWhereWithoutCreatedSpellsInput = {
    where: SpellScalarWhereInput
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyWithoutCreatedSpellsInput>
  }

  export type SpellScalarWhereInput = {
    AND?: SpellScalarWhereInput | SpellScalarWhereInput[]
    OR?: SpellScalarWhereInput[]
    NOT?: SpellScalarWhereInput | SpellScalarWhereInput[]
    id?: IntFilter<"Spell"> | number
    createdDate?: DateTimeFilter<"Spell"> | Date | string
    createdBy?: IntFilter<"Spell"> | number
    modifiedDate?: DateTimeFilter<"Spell"> | Date | string
    modifiedBy?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    description?: StringNullableFilter<"Spell"> | string | null
    notes?: StringNullableFilter<"Spell"> | string | null
    words?: StringNullableFilter<"Spell"> | string | null
    levelRequirement?: IntNullableFilter<"Spell"> | number | null
  }

  export type SpellUpsertWithWhereUniqueWithoutModifiedSpellsInput = {
    where: SpellWhereUniqueInput
    update: XOR<SpellUpdateWithoutModifiedSpellsInput, SpellUncheckedUpdateWithoutModifiedSpellsInput>
    create: XOR<SpellCreateWithoutModifiedSpellsInput, SpellUncheckedCreateWithoutModifiedSpellsInput>
  }

  export type SpellUpdateWithWhereUniqueWithoutModifiedSpellsInput = {
    where: SpellWhereUniqueInput
    data: XOR<SpellUpdateWithoutModifiedSpellsInput, SpellUncheckedUpdateWithoutModifiedSpellsInput>
  }

  export type SpellUpdateManyWithWhereWithoutModifiedSpellsInput = {
    where: SpellScalarWhereInput
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyWithoutModifiedSpellsInput>
  }

  export type PotionUpsertWithWhereUniqueWithoutCreatedPotionsInput = {
    where: PotionWhereUniqueInput
    update: XOR<PotionUpdateWithoutCreatedPotionsInput, PotionUncheckedUpdateWithoutCreatedPotionsInput>
    create: XOR<PotionCreateWithoutCreatedPotionsInput, PotionUncheckedCreateWithoutCreatedPotionsInput>
  }

  export type PotionUpdateWithWhereUniqueWithoutCreatedPotionsInput = {
    where: PotionWhereUniqueInput
    data: XOR<PotionUpdateWithoutCreatedPotionsInput, PotionUncheckedUpdateWithoutCreatedPotionsInput>
  }

  export type PotionUpdateManyWithWhereWithoutCreatedPotionsInput = {
    where: PotionScalarWhereInput
    data: XOR<PotionUpdateManyMutationInput, PotionUncheckedUpdateManyWithoutCreatedPotionsInput>
  }

  export type PotionScalarWhereInput = {
    AND?: PotionScalarWhereInput | PotionScalarWhereInput[]
    OR?: PotionScalarWhereInput[]
    NOT?: PotionScalarWhereInput | PotionScalarWhereInput[]
    id?: IntFilter<"Potion"> | number
    createdDate?: DateTimeFilter<"Potion"> | Date | string
    createdBy?: IntFilter<"Potion"> | number
    modifiedDate?: DateTimeFilter<"Potion"> | Date | string
    modifiedBy?: IntFilter<"Potion"> | number
    name?: StringFilter<"Potion"> | string
    description?: StringNullableFilter<"Potion"> | string | null
    notes?: StringNullableFilter<"Potion"> | string | null
    duration?: IntNullableFilter<"Potion"> | number | null
  }

  export type PotionUpsertWithWhereUniqueWithoutModifiedPotionsInput = {
    where: PotionWhereUniqueInput
    update: XOR<PotionUpdateWithoutModifiedPotionsInput, PotionUncheckedUpdateWithoutModifiedPotionsInput>
    create: XOR<PotionCreateWithoutModifiedPotionsInput, PotionUncheckedCreateWithoutModifiedPotionsInput>
  }

  export type PotionUpdateWithWhereUniqueWithoutModifiedPotionsInput = {
    where: PotionWhereUniqueInput
    data: XOR<PotionUpdateWithoutModifiedPotionsInput, PotionUncheckedUpdateWithoutModifiedPotionsInput>
  }

  export type PotionUpdateManyWithWhereWithoutModifiedPotionsInput = {
    where: PotionScalarWhereInput
    data: XOR<PotionUpdateManyMutationInput, PotionUncheckedUpdateManyWithoutModifiedPotionsInput>
  }

  export type SkillUpsertWithWhereUniqueWithoutCreatedSkillsInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutCreatedSkillsInput, SkillUncheckedUpdateWithoutCreatedSkillsInput>
    create: XOR<SkillCreateWithoutCreatedSkillsInput, SkillUncheckedCreateWithoutCreatedSkillsInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutCreatedSkillsInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutCreatedSkillsInput, SkillUncheckedUpdateWithoutCreatedSkillsInput>
  }

  export type SkillUpdateManyWithWhereWithoutCreatedSkillsInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutCreatedSkillsInput>
  }

  export type SkillScalarWhereInput = {
    AND?: SkillScalarWhereInput | SkillScalarWhereInput[]
    OR?: SkillScalarWhereInput[]
    NOT?: SkillScalarWhereInput | SkillScalarWhereInput[]
    id?: IntFilter<"Skill"> | number
    createdDate?: DateTimeFilter<"Skill"> | Date | string
    createdBy?: IntFilter<"Skill"> | number
    modifiedDate?: DateTimeFilter<"Skill"> | Date | string
    modifiedBy?: IntFilter<"Skill"> | number
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    notes?: StringNullableFilter<"Skill"> | string | null
    trainable?: BoolNullableFilter<"Skill"> | boolean | null
    levelRequirement?: IntFilter<"Skill"> | number
  }

  export type SkillUpsertWithWhereUniqueWithoutModifiedSkillsInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutModifiedSkillsInput, SkillUncheckedUpdateWithoutModifiedSkillsInput>
    create: XOR<SkillCreateWithoutModifiedSkillsInput, SkillUncheckedCreateWithoutModifiedSkillsInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutModifiedSkillsInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutModifiedSkillsInput, SkillUncheckedUpdateWithoutModifiedSkillsInput>
  }

  export type SkillUpdateManyWithWhereWithoutModifiedSkillsInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutModifiedSkillsInput>
  }

  export type AbilityUpsertWithWhereUniqueWithoutCreatedAbilitiesInput = {
    where: AbilityWhereUniqueInput
    update: XOR<AbilityUpdateWithoutCreatedAbilitiesInput, AbilityUncheckedUpdateWithoutCreatedAbilitiesInput>
    create: XOR<AbilityCreateWithoutCreatedAbilitiesInput, AbilityUncheckedCreateWithoutCreatedAbilitiesInput>
  }

  export type AbilityUpdateWithWhereUniqueWithoutCreatedAbilitiesInput = {
    where: AbilityWhereUniqueInput
    data: XOR<AbilityUpdateWithoutCreatedAbilitiesInput, AbilityUncheckedUpdateWithoutCreatedAbilitiesInput>
  }

  export type AbilityUpdateManyWithWhereWithoutCreatedAbilitiesInput = {
    where: AbilityScalarWhereInput
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyWithoutCreatedAbilitiesInput>
  }

  export type AbilityScalarWhereInput = {
    AND?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
    OR?: AbilityScalarWhereInput[]
    NOT?: AbilityScalarWhereInput | AbilityScalarWhereInput[]
    id?: IntFilter<"Ability"> | number
    createdDate?: DateTimeFilter<"Ability"> | Date | string
    createdBy?: IntFilter<"Ability"> | number
    modifiedDate?: DateTimeFilter<"Ability"> | Date | string
    modifiedBy?: IntFilter<"Ability"> | number
    name?: StringFilter<"Ability"> | string
    description?: StringNullableFilter<"Ability"> | string | null
    notes?: StringNullableFilter<"Ability"> | string | null
    firstRankPoints?: IntNullableFilter<"Ability"> | number | null
    secondRankPoints?: IntNullableFilter<"Ability"> | number | null
    thirdRankPoints?: IntNullableFilter<"Ability"> | number | null
    fourthRankPoints?: IntNullableFilter<"Ability"> | number | null
    fifthRankPoints?: IntNullableFilter<"Ability"> | number | null
    sixthRankPoints?: IntNullableFilter<"Ability"> | number | null
  }

  export type AbilityUpsertWithWhereUniqueWithoutModifiedAbilitiesInput = {
    where: AbilityWhereUniqueInput
    update: XOR<AbilityUpdateWithoutModifiedAbilitiesInput, AbilityUncheckedUpdateWithoutModifiedAbilitiesInput>
    create: XOR<AbilityCreateWithoutModifiedAbilitiesInput, AbilityUncheckedCreateWithoutModifiedAbilitiesInput>
  }

  export type AbilityUpdateWithWhereUniqueWithoutModifiedAbilitiesInput = {
    where: AbilityWhereUniqueInput
    data: XOR<AbilityUpdateWithoutModifiedAbilitiesInput, AbilityUncheckedUpdateWithoutModifiedAbilitiesInput>
  }

  export type AbilityUpdateManyWithWhereWithoutModifiedAbilitiesInput = {
    where: AbilityScalarWhereInput
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyWithoutModifiedAbilitiesInput>
  }

  export type QuestUpsertWithWhereUniqueWithoutCreatedQuestsInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutCreatedQuestsInput, QuestUncheckedUpdateWithoutCreatedQuestsInput>
    create: XOR<QuestCreateWithoutCreatedQuestsInput, QuestUncheckedCreateWithoutCreatedQuestsInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutCreatedQuestsInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutCreatedQuestsInput, QuestUncheckedUpdateWithoutCreatedQuestsInput>
  }

  export type QuestUpdateManyWithWhereWithoutCreatedQuestsInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutCreatedQuestsInput>
  }

  export type QuestScalarWhereInput = {
    AND?: QuestScalarWhereInput | QuestScalarWhereInput[]
    OR?: QuestScalarWhereInput[]
    NOT?: QuestScalarWhereInput | QuestScalarWhereInput[]
    id?: IntFilter<"Quest"> | number
    createdDate?: DateTimeFilter<"Quest"> | Date | string
    createdBy?: IntFilter<"Quest"> | number
    modifiedDate?: DateTimeFilter<"Quest"> | Date | string
    modifiedBy?: IntFilter<"Quest"> | number
    name?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    notes?: StringNullableFilter<"Quest"> | string | null
    whoises?: StringNullableFilter<"Quest"> | string | null
    pretitles?: StringNullableFilter<"Quest"> | string | null
    post_titles?: StringNullableFilter<"Quest"> | string | null
    experience?: IntNullableFilter<"Quest"> | number | null
  }

  export type QuestUpsertWithWhereUniqueWithoutModifiedQuestsInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutModifiedQuestsInput, QuestUncheckedUpdateWithoutModifiedQuestsInput>
    create: XOR<QuestCreateWithoutModifiedQuestsInput, QuestUncheckedCreateWithoutModifiedQuestsInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutModifiedQuestsInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutModifiedQuestsInput, QuestUncheckedUpdateWithoutModifiedQuestsInput>
  }

  export type QuestUpdateManyWithWhereWithoutModifiedQuestsInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutModifiedQuestsInput>
  }

  export type ArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type ArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    OR?: ArticleScalarWhereInput[]
    NOT?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    id?: IntFilter<"Article"> | number
    createdDate?: DateTimeFilter<"Article"> | Date | string
    authorId?: IntFilter<"Article"> | number
    isProtected?: BoolFilter<"Article"> | boolean
  }

  export type ArticleVersionUpsertWithWhereUniqueWithoutEditorInput = {
    where: ArticleVersionWhereUniqueInput
    update: XOR<ArticleVersionUpdateWithoutEditorInput, ArticleVersionUncheckedUpdateWithoutEditorInput>
    create: XOR<ArticleVersionCreateWithoutEditorInput, ArticleVersionUncheckedCreateWithoutEditorInput>
  }

  export type ArticleVersionUpdateWithWhereUniqueWithoutEditorInput = {
    where: ArticleVersionWhereUniqueInput
    data: XOR<ArticleVersionUpdateWithoutEditorInput, ArticleVersionUncheckedUpdateWithoutEditorInput>
  }

  export type ArticleVersionUpdateManyWithWhereWithoutEditorInput = {
    where: ArticleVersionScalarWhereInput
    data: XOR<ArticleVersionUpdateManyMutationInput, ArticleVersionUncheckedUpdateManyWithoutEditorInput>
  }

  export type ArticleVersionScalarWhereInput = {
    AND?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
    OR?: ArticleVersionScalarWhereInput[]
    NOT?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
    id?: IntFilter<"ArticleVersion"> | number
    articleId?: IntFilter<"ArticleVersion"> | number
    modifiedDate?: DateTimeFilter<"ArticleVersion"> | Date | string
    editorId?: IntFilter<"ArticleVersion"> | number
    content?: StringFilter<"ArticleVersion"> | string
    isCurrent?: BoolFilter<"ArticleVersion"> | boolean
    version?: StringNullableFilter<"ArticleVersion"> | string | null
  }

  export type TagUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutCreatorInput, TagUncheckedUpdateWithoutCreatorInput>
    create: XOR<TagCreateWithoutCreatorInput, TagUncheckedCreateWithoutCreatorInput>
  }

  export type TagUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutCreatorInput, TagUncheckedUpdateWithoutCreatorInput>
  }

  export type TagUpdateManyWithWhereWithoutCreatorInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    createdDate?: DateTimeFilter<"Tag"> | Date | string
    createdBy?: IntFilter<"Tag"> | number
    tag?: StringFilter<"Tag"> | string
  }

  export type AreaUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AreaWhereUniqueInput
    update: XOR<AreaUpdateWithoutAuthorInput, AreaUncheckedUpdateWithoutAuthorInput>
    create: XOR<AreaCreateWithoutAuthorInput, AreaUncheckedCreateWithoutAuthorInput>
  }

  export type AreaUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AreaWhereUniqueInput
    data: XOR<AreaUpdateWithoutAuthorInput, AreaUncheckedUpdateWithoutAuthorInput>
  }

  export type AreaUpdateManyWithWhereWithoutAuthorInput = {
    where: AreaScalarWhereInput
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AreaScalarWhereInput = {
    AND?: AreaScalarWhereInput | AreaScalarWhereInput[]
    OR?: AreaScalarWhereInput[]
    NOT?: AreaScalarWhereInput | AreaScalarWhereInput[]
    id?: IntFilter<"Area"> | number
    mudId?: IntNullableFilter<"Area"> | number | null
    name?: StringFilter<"Area"> | string
    authorId?: IntNullableFilter<"Area"> | number | null
    releaseDate?: DateTimeNullableFilter<"Area"> | Date | string | null
  }

  export type ChangeLogUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ChangeLogWhereUniqueInput
    update: XOR<ChangeLogUpdateWithoutCreatorInput, ChangeLogUncheckedUpdateWithoutCreatorInput>
    create: XOR<ChangeLogCreateWithoutCreatorInput, ChangeLogUncheckedCreateWithoutCreatorInput>
  }

  export type ChangeLogUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ChangeLogWhereUniqueInput
    data: XOR<ChangeLogUpdateWithoutCreatorInput, ChangeLogUncheckedUpdateWithoutCreatorInput>
  }

  export type ChangeLogUpdateManyWithWhereWithoutCreatorInput = {
    where: ChangeLogScalarWhereInput
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ChangeLogScalarWhereInput = {
    AND?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    OR?: ChangeLogScalarWhereInput[]
    NOT?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    id?: IntFilter<"ChangeLog"> | number
    createdDate?: DateTimeFilter<"ChangeLog"> | Date | string
    createdBy?: IntFilter<"ChangeLog"> | number
    content?: StringNullableFilter<"ChangeLog"> | string | null
    version?: StringNullableFilter<"ChangeLog"> | string | null
    releaseDate?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
  }

  export type AccountCreateWithoutAccountNotificationInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutAccountNotificationInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutAccountNotificationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccountNotificationInput, AccountUncheckedCreateWithoutAccountNotificationInput>
  }

  export type AccountUpsertWithoutAccountNotificationInput = {
    update: XOR<AccountUpdateWithoutAccountNotificationInput, AccountUncheckedUpdateWithoutAccountNotificationInput>
    create: XOR<AccountCreateWithoutAccountNotificationInput, AccountUncheckedCreateWithoutAccountNotificationInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAccountNotificationInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAccountNotificationInput, AccountUncheckedUpdateWithoutAccountNotificationInput>
  }

  export type AccountUpdateWithoutAccountNotificationInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccountNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateWithoutAccountPasswordInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutAccountPasswordInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutAccountPasswordInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccountPasswordInput, AccountUncheckedCreateWithoutAccountPasswordInput>
  }

  export type AccountUpsertWithoutAccountPasswordInput = {
    update: XOR<AccountUpdateWithoutAccountPasswordInput, AccountUncheckedUpdateWithoutAccountPasswordInput>
    create: XOR<AccountCreateWithoutAccountPasswordInput, AccountUncheckedCreateWithoutAccountPasswordInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAccountPasswordInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAccountPasswordInput, AccountUncheckedUpdateWithoutAccountPasswordInput>
  }

  export type AccountUpdateWithoutAccountPasswordInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccountPasswordInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateWithoutNetworkHistoryInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutNetworkHistoryInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutNetworkHistoryInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutNetworkHistoryInput, AccountUncheckedCreateWithoutNetworkHistoryInput>
  }

  export type NetworkBlacklistCreateWithoutNetworkHistoryInput = {
    issueDate: Date | string
    termDate: Date | string
    Account: AccountCreateNestedOneWithoutNetworkBlacklistInput
  }

  export type NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput = {
    id?: number
    issueDate: Date | string
    termDate: Date | string
    issuer: number
  }

  export type NetworkBlacklistCreateOrConnectWithoutNetworkHistoryInput = {
    where: NetworkBlacklistWhereUniqueInput
    create: XOR<NetworkBlacklistCreateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput>
  }

  export type NetworkBlacklistCreateManyNetworkHistoryInputEnvelope = {
    data: NetworkBlacklistCreateManyNetworkHistoryInput | NetworkBlacklistCreateManyNetworkHistoryInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutNetworkHistoryInput = {
    update: XOR<AccountUpdateWithoutNetworkHistoryInput, AccountUncheckedUpdateWithoutNetworkHistoryInput>
    create: XOR<AccountCreateWithoutNetworkHistoryInput, AccountUncheckedCreateWithoutNetworkHistoryInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutNetworkHistoryInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutNetworkHistoryInput, AccountUncheckedUpdateWithoutNetworkHistoryInput>
  }

  export type AccountUpdateWithoutNetworkHistoryInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutNetworkHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type NetworkBlacklistUpsertWithWhereUniqueWithoutNetworkHistoryInput = {
    where: NetworkBlacklistWhereUniqueInput
    update: XOR<NetworkBlacklistUpdateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedUpdateWithoutNetworkHistoryInput>
    create: XOR<NetworkBlacklistCreateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedCreateWithoutNetworkHistoryInput>
  }

  export type NetworkBlacklistUpdateWithWhereUniqueWithoutNetworkHistoryInput = {
    where: NetworkBlacklistWhereUniqueInput
    data: XOR<NetworkBlacklistUpdateWithoutNetworkHistoryInput, NetworkBlacklistUncheckedUpdateWithoutNetworkHistoryInput>
  }

  export type NetworkBlacklistUpdateManyWithWhereWithoutNetworkHistoryInput = {
    where: NetworkBlacklistScalarWhereInput
    data: XOR<NetworkBlacklistUpdateManyMutationInput, NetworkBlacklistUncheckedUpdateManyWithoutNetworkHistoryInput>
  }

  export type NetworkHistoryCreateWithoutNetworkBlacklistInput = {
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
    Account: AccountCreateNestedOneWithoutNetworkHistoryInput
  }

  export type NetworkHistoryUncheckedCreateWithoutNetworkBlacklistInput = {
    id?: number
    accountId: number
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
  }

  export type NetworkHistoryCreateOrConnectWithoutNetworkBlacklistInput = {
    where: NetworkHistoryWhereUniqueInput
    create: XOR<NetworkHistoryCreateWithoutNetworkBlacklistInput, NetworkHistoryUncheckedCreateWithoutNetworkBlacklistInput>
  }

  export type AccountCreateWithoutNetworkBlacklistInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutNetworkBlacklistInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutNetworkBlacklistInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutNetworkBlacklistInput, AccountUncheckedCreateWithoutNetworkBlacklistInput>
  }

  export type NetworkHistoryUpsertWithoutNetworkBlacklistInput = {
    update: XOR<NetworkHistoryUpdateWithoutNetworkBlacklistInput, NetworkHistoryUncheckedUpdateWithoutNetworkBlacklistInput>
    create: XOR<NetworkHistoryCreateWithoutNetworkBlacklistInput, NetworkHistoryUncheckedCreateWithoutNetworkBlacklistInput>
    where?: NetworkHistoryWhereInput
  }

  export type NetworkHistoryUpdateToOneWithWhereWithoutNetworkBlacklistInput = {
    where?: NetworkHistoryWhereInput
    data: XOR<NetworkHistoryUpdateWithoutNetworkBlacklistInput, NetworkHistoryUncheckedUpdateWithoutNetworkBlacklistInput>
  }

  export type NetworkHistoryUpdateWithoutNetworkBlacklistInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    Account?: AccountUpdateOneRequiredWithoutNetworkHistoryNestedInput
  }

  export type NetworkHistoryUncheckedUpdateWithoutNetworkBlacklistInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUpsertWithoutNetworkBlacklistInput = {
    update: XOR<AccountUpdateWithoutNetworkBlacklistInput, AccountUncheckedUpdateWithoutNetworkBlacklistInput>
    create: XOR<AccountCreateWithoutNetworkBlacklistInput, AccountUncheckedCreateWithoutNetworkBlacklistInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutNetworkBlacklistInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutNetworkBlacklistInput, AccountUncheckedUpdateWithoutNetworkBlacklistInput>
  }

  export type AccountUpdateWithoutNetworkBlacklistInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutNetworkBlacklistInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateWithoutNotificationInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutNotificationInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutNotificationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
  }

  export type AccountUpsertWithoutNotificationInput = {
    update: XOR<AccountUpdateWithoutNotificationInput, AccountUncheckedUpdateWithoutNotificationInput>
    create: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutNotificationInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutNotificationInput, AccountUncheckedUpdateWithoutNotificationInput>
  }

  export type AccountUpdateWithoutNotificationInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateWithoutCharacterInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutCharacterInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutCharacterInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCharacterInput, AccountUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterVersionCreateWithoutCharacterInput = {
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    CharacterStat?: CharacterStatCreateNestedOneWithoutCharacterVersionInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutCharacterVersionInput
    CharacterEquipment?: CharacterEquipmentCreateNestedOneWithoutCharacterVersionInput
  }

  export type CharacterVersionUncheckedCreateWithoutCharacterInput = {
    id?: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    characterEquipmentId?: number | null
    CharacterStat?: CharacterStatUncheckedCreateNestedOneWithoutCharacterVersionInput
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutCharacterVersionInput
  }

  export type CharacterVersionCreateOrConnectWithoutCharacterInput = {
    where: CharacterVersionWhereUniqueInput
    create: XOR<CharacterVersionCreateWithoutCharacterInput, CharacterVersionUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterVersionCreateManyCharacterInputEnvelope = {
    data: CharacterVersionCreateManyCharacterInput | CharacterVersionCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutCharacterInput = {
    update: XOR<AccountUpdateWithoutCharacterInput, AccountUncheckedUpdateWithoutCharacterInput>
    create: XOR<AccountCreateWithoutCharacterInput, AccountUncheckedCreateWithoutCharacterInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCharacterInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCharacterInput, AccountUncheckedUpdateWithoutCharacterInput>
  }

  export type AccountUpdateWithoutCharacterInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CharacterVersionUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterVersionWhereUniqueInput
    update: XOR<CharacterVersionUpdateWithoutCharacterInput, CharacterVersionUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterVersionCreateWithoutCharacterInput, CharacterVersionUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterVersionUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterVersionWhereUniqueInput
    data: XOR<CharacterVersionUpdateWithoutCharacterInput, CharacterVersionUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterVersionUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterVersionScalarWhereInput
    data: XOR<CharacterVersionUpdateManyMutationInput, CharacterVersionUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterVersionScalarWhereInput = {
    AND?: CharacterVersionScalarWhereInput | CharacterVersionScalarWhereInput[]
    OR?: CharacterVersionScalarWhereInput[]
    NOT?: CharacterVersionScalarWhereInput | CharacterVersionScalarWhereInput[]
    id?: IntFilter<"CharacterVersion"> | number
    characterId?: IntFilter<"CharacterVersion"> | number
    equipmentId?: IntFilter<"CharacterVersion"> | number
    statsId?: IntFilter<"CharacterVersion"> | number
    createdDate?: DateTimeFilter<"CharacterVersion"> | Date | string
    modifiedDate?: DateTimeFilter<"CharacterVersion"> | Date | string
    version?: StringFilter<"CharacterVersion"> | string
    hometown?: StringNullableFilter<"CharacterVersion"> | string | null
    characterEquipmentId?: IntNullableFilter<"CharacterVersion"> | number | null
  }

  export type CharacterCreateWithoutCharacterVersionInput = {
    mudId?: number | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
    Account: AccountCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutCharacterVersionInput = {
    id?: number
    mudId?: number | null
    accountId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
  }

  export type CharacterCreateOrConnectWithoutCharacterVersionInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutCharacterVersionInput, CharacterUncheckedCreateWithoutCharacterVersionInput>
  }

  export type CharacterStatCreateWithoutCharacterVersionInput = {
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    strSwap?: number | null
    minSwap?: number | null
    dexSwap?: number | null
    conSwap?: number | null
    perSwap?: number | null
    spiSwap?: number | null
  }

  export type CharacterStatUncheckedCreateWithoutCharacterVersionInput = {
    id?: number
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    strSwap?: number | null
    minSwap?: number | null
    dexSwap?: number | null
    conSwap?: number | null
    perSwap?: number | null
    spiSwap?: number | null
  }

  export type CharacterStatCreateOrConnectWithoutCharacterVersionInput = {
    where: CharacterStatWhereUniqueInput
    create: XOR<CharacterStatCreateWithoutCharacterVersionInput, CharacterStatUncheckedCreateWithoutCharacterVersionInput>
  }

  export type CharacterQuestCreateWithoutCharacterVersionInput = {
    Quest: QuestCreateNestedOneWithoutCharacterQuestInput
  }

  export type CharacterQuestUncheckedCreateWithoutCharacterVersionInput = {
    id?: number
    questId: number
  }

  export type CharacterQuestCreateOrConnectWithoutCharacterVersionInput = {
    where: CharacterQuestWhereUniqueInput
    create: XOR<CharacterQuestCreateWithoutCharacterVersionInput, CharacterQuestUncheckedCreateWithoutCharacterVersionInput>
  }

  export type CharacterQuestCreateManyCharacterVersionInputEnvelope = {
    data: CharacterQuestCreateManyCharacterVersionInput | CharacterQuestCreateManyCharacterVersionInput[]
    skipDuplicates?: boolean
  }

  export type CharacterEquipmentCreateWithoutCharacterVersionInput = {
    light?: number | null
    finger1?: number | null
    finger2?: number | null
    neck1?: number | null
    neck2?: number | null
    body?: number | null
    head?: number | null
    hands?: number | null
    feet?: number | null
    face?: number | null
    arms?: number | null
    legs?: number | null
    about?: number | null
    waist?: number | null
    wrist1?: number | null
    wrist2?: number | null
    wield?: number | null
    hold1?: number | null
    hold2?: number | null
    hold3?: number | null
    ear1?: number | null
    ear2?: number | null
    arm?: number | null
    amulet?: number | null
    aux?: number | null
  }

  export type CharacterEquipmentUncheckedCreateWithoutCharacterVersionInput = {
    id?: number
    light?: number | null
    finger1?: number | null
    finger2?: number | null
    neck1?: number | null
    neck2?: number | null
    body?: number | null
    head?: number | null
    hands?: number | null
    feet?: number | null
    face?: number | null
    arms?: number | null
    legs?: number | null
    about?: number | null
    waist?: number | null
    wrist1?: number | null
    wrist2?: number | null
    wield?: number | null
    hold1?: number | null
    hold2?: number | null
    hold3?: number | null
    ear1?: number | null
    ear2?: number | null
    arm?: number | null
    amulet?: number | null
    aux?: number | null
  }

  export type CharacterEquipmentCreateOrConnectWithoutCharacterVersionInput = {
    where: CharacterEquipmentWhereUniqueInput
    create: XOR<CharacterEquipmentCreateWithoutCharacterVersionInput, CharacterEquipmentUncheckedCreateWithoutCharacterVersionInput>
  }

  export type CharacterUpsertWithoutCharacterVersionInput = {
    update: XOR<CharacterUpdateWithoutCharacterVersionInput, CharacterUncheckedUpdateWithoutCharacterVersionInput>
    create: XOR<CharacterCreateWithoutCharacterVersionInput, CharacterUncheckedCreateWithoutCharacterVersionInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutCharacterVersionInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutCharacterVersionInput, CharacterUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterUpdateWithoutCharacterVersionInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    Account?: AccountUpdateOneRequiredWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutCharacterVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterStatUpsertWithoutCharacterVersionInput = {
    update: XOR<CharacterStatUpdateWithoutCharacterVersionInput, CharacterStatUncheckedUpdateWithoutCharacterVersionInput>
    create: XOR<CharacterStatCreateWithoutCharacterVersionInput, CharacterStatUncheckedCreateWithoutCharacterVersionInput>
    where?: CharacterStatWhereInput
  }

  export type CharacterStatUpdateToOneWithWhereWithoutCharacterVersionInput = {
    where?: CharacterStatWhereInput
    data: XOR<CharacterStatUpdateWithoutCharacterVersionInput, CharacterStatUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterStatUpdateWithoutCharacterVersionInput = {
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    strSwap?: NullableIntFieldUpdateOperationsInput | number | null
    minSwap?: NullableIntFieldUpdateOperationsInput | number | null
    dexSwap?: NullableIntFieldUpdateOperationsInput | number | null
    conSwap?: NullableIntFieldUpdateOperationsInput | number | null
    perSwap?: NullableIntFieldUpdateOperationsInput | number | null
    spiSwap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterStatUncheckedUpdateWithoutCharacterVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    strSwap?: NullableIntFieldUpdateOperationsInput | number | null
    minSwap?: NullableIntFieldUpdateOperationsInput | number | null
    dexSwap?: NullableIntFieldUpdateOperationsInput | number | null
    conSwap?: NullableIntFieldUpdateOperationsInput | number | null
    perSwap?: NullableIntFieldUpdateOperationsInput | number | null
    spiSwap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterQuestUpsertWithWhereUniqueWithoutCharacterVersionInput = {
    where: CharacterQuestWhereUniqueInput
    update: XOR<CharacterQuestUpdateWithoutCharacterVersionInput, CharacterQuestUncheckedUpdateWithoutCharacterVersionInput>
    create: XOR<CharacterQuestCreateWithoutCharacterVersionInput, CharacterQuestUncheckedCreateWithoutCharacterVersionInput>
  }

  export type CharacterQuestUpdateWithWhereUniqueWithoutCharacterVersionInput = {
    where: CharacterQuestWhereUniqueInput
    data: XOR<CharacterQuestUpdateWithoutCharacterVersionInput, CharacterQuestUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterQuestUpdateManyWithWhereWithoutCharacterVersionInput = {
    where: CharacterQuestScalarWhereInput
    data: XOR<CharacterQuestUpdateManyMutationInput, CharacterQuestUncheckedUpdateManyWithoutCharacterVersionInput>
  }

  export type CharacterQuestScalarWhereInput = {
    AND?: CharacterQuestScalarWhereInput | CharacterQuestScalarWhereInput[]
    OR?: CharacterQuestScalarWhereInput[]
    NOT?: CharacterQuestScalarWhereInput | CharacterQuestScalarWhereInput[]
    id?: IntFilter<"CharacterQuest"> | number
    characterVersionId?: IntFilter<"CharacterQuest"> | number
    questId?: IntFilter<"CharacterQuest"> | number
  }

  export type CharacterEquipmentUpsertWithoutCharacterVersionInput = {
    update: XOR<CharacterEquipmentUpdateWithoutCharacterVersionInput, CharacterEquipmentUncheckedUpdateWithoutCharacterVersionInput>
    create: XOR<CharacterEquipmentCreateWithoutCharacterVersionInput, CharacterEquipmentUncheckedCreateWithoutCharacterVersionInput>
    where?: CharacterEquipmentWhereInput
  }

  export type CharacterEquipmentUpdateToOneWithWhereWithoutCharacterVersionInput = {
    where?: CharacterEquipmentWhereInput
    data: XOR<CharacterEquipmentUpdateWithoutCharacterVersionInput, CharacterEquipmentUncheckedUpdateWithoutCharacterVersionInput>
  }

  export type CharacterEquipmentUpdateWithoutCharacterVersionInput = {
    light?: NullableIntFieldUpdateOperationsInput | number | null
    finger1?: NullableIntFieldUpdateOperationsInput | number | null
    finger2?: NullableIntFieldUpdateOperationsInput | number | null
    neck1?: NullableIntFieldUpdateOperationsInput | number | null
    neck2?: NullableIntFieldUpdateOperationsInput | number | null
    body?: NullableIntFieldUpdateOperationsInput | number | null
    head?: NullableIntFieldUpdateOperationsInput | number | null
    hands?: NullableIntFieldUpdateOperationsInput | number | null
    feet?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    arms?: NullableIntFieldUpdateOperationsInput | number | null
    legs?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableIntFieldUpdateOperationsInput | number | null
    waist?: NullableIntFieldUpdateOperationsInput | number | null
    wrist1?: NullableIntFieldUpdateOperationsInput | number | null
    wrist2?: NullableIntFieldUpdateOperationsInput | number | null
    wield?: NullableIntFieldUpdateOperationsInput | number | null
    hold1?: NullableIntFieldUpdateOperationsInput | number | null
    hold2?: NullableIntFieldUpdateOperationsInput | number | null
    hold3?: NullableIntFieldUpdateOperationsInput | number | null
    ear1?: NullableIntFieldUpdateOperationsInput | number | null
    ear2?: NullableIntFieldUpdateOperationsInput | number | null
    arm?: NullableIntFieldUpdateOperationsInput | number | null
    amulet?: NullableIntFieldUpdateOperationsInput | number | null
    aux?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterEquipmentUncheckedUpdateWithoutCharacterVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    light?: NullableIntFieldUpdateOperationsInput | number | null
    finger1?: NullableIntFieldUpdateOperationsInput | number | null
    finger2?: NullableIntFieldUpdateOperationsInput | number | null
    neck1?: NullableIntFieldUpdateOperationsInput | number | null
    neck2?: NullableIntFieldUpdateOperationsInput | number | null
    body?: NullableIntFieldUpdateOperationsInput | number | null
    head?: NullableIntFieldUpdateOperationsInput | number | null
    hands?: NullableIntFieldUpdateOperationsInput | number | null
    feet?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    arms?: NullableIntFieldUpdateOperationsInput | number | null
    legs?: NullableIntFieldUpdateOperationsInput | number | null
    about?: NullableIntFieldUpdateOperationsInput | number | null
    waist?: NullableIntFieldUpdateOperationsInput | number | null
    wrist1?: NullableIntFieldUpdateOperationsInput | number | null
    wrist2?: NullableIntFieldUpdateOperationsInput | number | null
    wield?: NullableIntFieldUpdateOperationsInput | number | null
    hold1?: NullableIntFieldUpdateOperationsInput | number | null
    hold2?: NullableIntFieldUpdateOperationsInput | number | null
    hold3?: NullableIntFieldUpdateOperationsInput | number | null
    ear1?: NullableIntFieldUpdateOperationsInput | number | null
    ear2?: NullableIntFieldUpdateOperationsInput | number | null
    arm?: NullableIntFieldUpdateOperationsInput | number | null
    amulet?: NullableIntFieldUpdateOperationsInput | number | null
    aux?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterVersionCreateWithoutCharacterStatInput = {
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    Character: CharacterCreateNestedOneWithoutCharacterVersionInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutCharacterVersionInput
    CharacterEquipment?: CharacterEquipmentCreateNestedOneWithoutCharacterVersionInput
  }

  export type CharacterVersionUncheckedCreateWithoutCharacterStatInput = {
    id?: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    characterEquipmentId?: number | null
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutCharacterVersionInput
  }

  export type CharacterVersionCreateOrConnectWithoutCharacterStatInput = {
    where: CharacterVersionWhereUniqueInput
    create: XOR<CharacterVersionCreateWithoutCharacterStatInput, CharacterVersionUncheckedCreateWithoutCharacterStatInput>
  }

  export type CharacterVersionUpsertWithoutCharacterStatInput = {
    update: XOR<CharacterVersionUpdateWithoutCharacterStatInput, CharacterVersionUncheckedUpdateWithoutCharacterStatInput>
    create: XOR<CharacterVersionCreateWithoutCharacterStatInput, CharacterVersionUncheckedCreateWithoutCharacterStatInput>
    where?: CharacterVersionWhereInput
  }

  export type CharacterVersionUpdateToOneWithWhereWithoutCharacterStatInput = {
    where?: CharacterVersionWhereInput
    data: XOR<CharacterVersionUpdateWithoutCharacterStatInput, CharacterVersionUncheckedUpdateWithoutCharacterStatInput>
  }

  export type CharacterVersionUpdateWithoutCharacterStatInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    Character?: CharacterUpdateOneRequiredWithoutCharacterVersionNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutCharacterVersionNestedInput
    CharacterEquipment?: CharacterEquipmentUpdateOneWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionUncheckedUpdateWithoutCharacterStatInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    characterEquipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionCreateWithoutCharacterQuestInput = {
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    Character: CharacterCreateNestedOneWithoutCharacterVersionInput
    CharacterStat?: CharacterStatCreateNestedOneWithoutCharacterVersionInput
    CharacterEquipment?: CharacterEquipmentCreateNestedOneWithoutCharacterVersionInput
  }

  export type CharacterVersionUncheckedCreateWithoutCharacterQuestInput = {
    id?: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    characterEquipmentId?: number | null
    CharacterStat?: CharacterStatUncheckedCreateNestedOneWithoutCharacterVersionInput
  }

  export type CharacterVersionCreateOrConnectWithoutCharacterQuestInput = {
    where: CharacterVersionWhereUniqueInput
    create: XOR<CharacterVersionCreateWithoutCharacterQuestInput, CharacterVersionUncheckedCreateWithoutCharacterQuestInput>
  }

  export type QuestCreateWithoutCharacterQuestInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CreatedQuests: AccountCreateNestedOneWithoutCreatedQuestsInput
    ModifiedQuests: AccountCreateNestedOneWithoutModifiedQuestsInput
    StatModifer?: StatModiferCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestUncheckedCreateWithoutCharacterQuestInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutQuestSourceInput
    QuestTagSource?: AppliedTagUncheckedCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestCreateOrConnectWithoutCharacterQuestInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutCharacterQuestInput, QuestUncheckedCreateWithoutCharacterQuestInput>
  }

  export type CharacterVersionUpsertWithoutCharacterQuestInput = {
    update: XOR<CharacterVersionUpdateWithoutCharacterQuestInput, CharacterVersionUncheckedUpdateWithoutCharacterQuestInput>
    create: XOR<CharacterVersionCreateWithoutCharacterQuestInput, CharacterVersionUncheckedCreateWithoutCharacterQuestInput>
    where?: CharacterVersionWhereInput
  }

  export type CharacterVersionUpdateToOneWithWhereWithoutCharacterQuestInput = {
    where?: CharacterVersionWhereInput
    data: XOR<CharacterVersionUpdateWithoutCharacterQuestInput, CharacterVersionUncheckedUpdateWithoutCharacterQuestInput>
  }

  export type CharacterVersionUpdateWithoutCharacterQuestInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    Character?: CharacterUpdateOneRequiredWithoutCharacterVersionNestedInput
    CharacterStat?: CharacterStatUpdateOneWithoutCharacterVersionNestedInput
    CharacterEquipment?: CharacterEquipmentUpdateOneWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionUncheckedUpdateWithoutCharacterQuestInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    characterEquipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterStat?: CharacterStatUncheckedUpdateOneWithoutCharacterVersionNestedInput
  }

  export type QuestUpsertWithoutCharacterQuestInput = {
    update: XOR<QuestUpdateWithoutCharacterQuestInput, QuestUncheckedUpdateWithoutCharacterQuestInput>
    create: XOR<QuestCreateWithoutCharacterQuestInput, QuestUncheckedCreateWithoutCharacterQuestInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutCharacterQuestInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutCharacterQuestInput, QuestUncheckedUpdateWithoutCharacterQuestInput>
  }

  export type QuestUpdateWithoutCharacterQuestInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedQuests?: AccountUpdateOneRequiredWithoutCreatedQuestsNestedInput
    ModifiedQuests?: AccountUpdateOneRequiredWithoutModifiedQuestsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestUncheckedUpdateWithoutCharacterQuestInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUncheckedUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type CharacterVersionCreateWithoutCharacterEquipmentInput = {
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    Character: CharacterCreateNestedOneWithoutCharacterVersionInput
    CharacterStat?: CharacterStatCreateNestedOneWithoutCharacterVersionInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutCharacterVersionInput
  }

  export type CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput = {
    id?: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    CharacterStat?: CharacterStatUncheckedCreateNestedOneWithoutCharacterVersionInput
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutCharacterVersionInput
  }

  export type CharacterVersionCreateOrConnectWithoutCharacterEquipmentInput = {
    where: CharacterVersionWhereUniqueInput
    create: XOR<CharacterVersionCreateWithoutCharacterEquipmentInput, CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput>
  }

  export type CharacterVersionCreateManyCharacterEquipmentInputEnvelope = {
    data: CharacterVersionCreateManyCharacterEquipmentInput | CharacterVersionCreateManyCharacterEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type CharacterVersionUpsertWithWhereUniqueWithoutCharacterEquipmentInput = {
    where: CharacterVersionWhereUniqueInput
    update: XOR<CharacterVersionUpdateWithoutCharacterEquipmentInput, CharacterVersionUncheckedUpdateWithoutCharacterEquipmentInput>
    create: XOR<CharacterVersionCreateWithoutCharacterEquipmentInput, CharacterVersionUncheckedCreateWithoutCharacterEquipmentInput>
  }

  export type CharacterVersionUpdateWithWhereUniqueWithoutCharacterEquipmentInput = {
    where: CharacterVersionWhereUniqueInput
    data: XOR<CharacterVersionUpdateWithoutCharacterEquipmentInput, CharacterVersionUncheckedUpdateWithoutCharacterEquipmentInput>
  }

  export type CharacterVersionUpdateManyWithWhereWithoutCharacterEquipmentInput = {
    where: CharacterVersionScalarWhereInput
    data: XOR<CharacterVersionUpdateManyMutationInput, CharacterVersionUncheckedUpdateManyWithoutCharacterEquipmentInput>
  }

  export type AccountCreateWithoutCreatedItemsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutCreatedItemsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutCreatedItemsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCreatedItemsInput, AccountUncheckedCreateWithoutCreatedItemsInput>
  }

  export type AccountCreateWithoutModifiedItemsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutModifiedItemsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutModifiedItemsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModifiedItemsInput, AccountUncheckedCreateWithoutModifiedItemsInput>
  }

  export type ItemSpellCreateWithoutItemInput = {
    Spell: SpellCreateNestedOneWithoutItemSpellInput
  }

  export type ItemSpellUncheckedCreateWithoutItemInput = {
    id?: number
    spellId: number
  }

  export type ItemSpellCreateOrConnectWithoutItemInput = {
    where: ItemSpellWhereUniqueInput
    create: XOR<ItemSpellCreateWithoutItemInput, ItemSpellUncheckedCreateWithoutItemInput>
  }

  export type ItemSpellCreateManyItemInputEnvelope = {
    data: ItemSpellCreateManyItemInput | ItemSpellCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemWeaponCreateWithoutItemInput = {
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
    AmmoItem: ItemCreateNestedOneWithoutAmmoItemInput
  }

  export type ItemWeaponUncheckedCreateWithoutItemInput = {
    id?: number
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    ammoTypeId: number
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
  }

  export type ItemWeaponCreateOrConnectWithoutItemInput = {
    where: ItemWeaponWhereUniqueInput
    create: XOR<ItemWeaponCreateWithoutItemInput, ItemWeaponUncheckedCreateWithoutItemInput>
  }

  export type ItemWeaponCreateWithoutAmmoItemInput = {
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
    Item: ItemCreateNestedOneWithoutItemWeaponInput
  }

  export type ItemWeaponUncheckedCreateWithoutAmmoItemInput = {
    id?: number
    itemId: number
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
  }

  export type ItemWeaponCreateOrConnectWithoutAmmoItemInput = {
    where: ItemWeaponWhereUniqueInput
    create: XOR<ItemWeaponCreateWithoutAmmoItemInput, ItemWeaponUncheckedCreateWithoutAmmoItemInput>
  }

  export type ItemWeaponCreateManyAmmoItemInputEnvelope = {
    data: ItemWeaponCreateManyAmmoItemInput | ItemWeaponCreateManyAmmoItemInput[]
    skipDuplicates?: boolean
  }

  export type StatModiferCreateWithoutItemSourceInput = {
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
    QuestSource?: QuestCreateNestedOneWithoutStatModiferInput
    AbilitySource?: AbilityCreateNestedOneWithoutStatModiferInput
    SkillSource?: SkillCreateNestedOneWithoutStatModiferInput
    SpellSource?: SpellCreateNestedOneWithoutStatModiferInput
    PotionSource?: PotionCreateNestedOneWithoutStatModiferInput
  }

  export type StatModiferUncheckedCreateWithoutItemSourceInput = {
    id?: number
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferCreateOrConnectWithoutItemSourceInput = {
    where: StatModiferWhereUniqueInput
    create: XOR<StatModiferCreateWithoutItemSourceInput, StatModiferUncheckedCreateWithoutItemSourceInput>
  }

  export type AppliedTagCreateWithoutItemTagSourceInput = {
    typeId: $Enums.TagType
    Tag: TagCreateNestedOneWithoutAppliedTagInput
    ArticleTagSource?: ArticleCreateNestedOneWithoutArticleTagSourceInput
    MobTagSource?: MobCreateNestedOneWithoutMobTagSourceInput
    QuestTagSource?: QuestCreateNestedOneWithoutQuestTagSourceInput
  }

  export type AppliedTagUncheckedCreateWithoutItemTagSourceInput = {
    id?: number
    typeId: $Enums.TagType
    tagId: number
  }

  export type AppliedTagCreateOrConnectWithoutItemTagSourceInput = {
    where: AppliedTagWhereUniqueInput
    create: XOR<AppliedTagCreateWithoutItemTagSourceInput, AppliedTagUncheckedCreateWithoutItemTagSourceInput>
  }

  export type AccountUpsertWithoutCreatedItemsInput = {
    update: XOR<AccountUpdateWithoutCreatedItemsInput, AccountUncheckedUpdateWithoutCreatedItemsInput>
    create: XOR<AccountCreateWithoutCreatedItemsInput, AccountUncheckedCreateWithoutCreatedItemsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCreatedItemsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCreatedItemsInput, AccountUncheckedUpdateWithoutCreatedItemsInput>
  }

  export type AccountUpdateWithoutCreatedItemsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutCreatedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUpsertWithoutModifiedItemsInput = {
    update: XOR<AccountUpdateWithoutModifiedItemsInput, AccountUncheckedUpdateWithoutModifiedItemsInput>
    create: XOR<AccountCreateWithoutModifiedItemsInput, AccountUncheckedCreateWithoutModifiedItemsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModifiedItemsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModifiedItemsInput, AccountUncheckedUpdateWithoutModifiedItemsInput>
  }

  export type AccountUpdateWithoutModifiedItemsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutModifiedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ItemSpellUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemSpellWhereUniqueInput
    update: XOR<ItemSpellUpdateWithoutItemInput, ItemSpellUncheckedUpdateWithoutItemInput>
    create: XOR<ItemSpellCreateWithoutItemInput, ItemSpellUncheckedCreateWithoutItemInput>
  }

  export type ItemSpellUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemSpellWhereUniqueInput
    data: XOR<ItemSpellUpdateWithoutItemInput, ItemSpellUncheckedUpdateWithoutItemInput>
  }

  export type ItemSpellUpdateManyWithWhereWithoutItemInput = {
    where: ItemSpellScalarWhereInput
    data: XOR<ItemSpellUpdateManyMutationInput, ItemSpellUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemSpellScalarWhereInput = {
    AND?: ItemSpellScalarWhereInput | ItemSpellScalarWhereInput[]
    OR?: ItemSpellScalarWhereInput[]
    NOT?: ItemSpellScalarWhereInput | ItemSpellScalarWhereInput[]
    id?: IntFilter<"ItemSpell"> | number
    itemId?: IntFilter<"ItemSpell"> | number
    spellId?: IntFilter<"ItemSpell"> | number
  }

  export type ItemWeaponUpsertWithoutItemInput = {
    update: XOR<ItemWeaponUpdateWithoutItemInput, ItemWeaponUncheckedUpdateWithoutItemInput>
    create: XOR<ItemWeaponCreateWithoutItemInput, ItemWeaponUncheckedCreateWithoutItemInput>
    where?: ItemWeaponWhereInput
  }

  export type ItemWeaponUpdateToOneWithWhereWithoutItemInput = {
    where?: ItemWeaponWhereInput
    data: XOR<ItemWeaponUpdateWithoutItemInput, ItemWeaponUncheckedUpdateWithoutItemInput>
  }

  export type ItemWeaponUpdateWithoutItemInput = {
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    AmmoItem?: ItemUpdateOneRequiredWithoutAmmoItemNestedInput
  }

  export type ItemWeaponUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    ammoTypeId?: IntFieldUpdateOperationsInput | number
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
  }

  export type ItemWeaponUpsertWithWhereUniqueWithoutAmmoItemInput = {
    where: ItemWeaponWhereUniqueInput
    update: XOR<ItemWeaponUpdateWithoutAmmoItemInput, ItemWeaponUncheckedUpdateWithoutAmmoItemInput>
    create: XOR<ItemWeaponCreateWithoutAmmoItemInput, ItemWeaponUncheckedCreateWithoutAmmoItemInput>
  }

  export type ItemWeaponUpdateWithWhereUniqueWithoutAmmoItemInput = {
    where: ItemWeaponWhereUniqueInput
    data: XOR<ItemWeaponUpdateWithoutAmmoItemInput, ItemWeaponUncheckedUpdateWithoutAmmoItemInput>
  }

  export type ItemWeaponUpdateManyWithWhereWithoutAmmoItemInput = {
    where: ItemWeaponScalarWhereInput
    data: XOR<ItemWeaponUpdateManyMutationInput, ItemWeaponUncheckedUpdateManyWithoutAmmoItemInput>
  }

  export type ItemWeaponScalarWhereInput = {
    AND?: ItemWeaponScalarWhereInput | ItemWeaponScalarWhereInput[]
    OR?: ItemWeaponScalarWhereInput[]
    NOT?: ItemWeaponScalarWhereInput | ItemWeaponScalarWhereInput[]
    id?: IntFilter<"ItemWeapon"> | number
    itemId?: IntFilter<"ItemWeapon"> | number
    quality?: IntNullableFilter<"ItemWeapon"> | number | null
    speed?: IntNullableFilter<"ItemWeapon"> | number | null
    isHoldable?: BoolFilter<"ItemWeapon"> | boolean
    isTwoHanded?: BoolFilter<"ItemWeapon"> | boolean
    ammoCapacity?: IntNullableFilter<"ItemWeapon"> | number | null
    ammoTypeId?: IntFilter<"ItemWeapon"> | number
    shotAccuracy?: IntNullableFilter<"ItemWeapon"> | number | null
    maxDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    minDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    avgDamage?: IntNullableFilter<"ItemWeapon"> | number | null
    stat?: EnumWeaponStatNullableFilter<"ItemWeapon"> | $Enums.WeaponStat | null
    type?: EnumWeaponTypeNullableFilter<"ItemWeapon"> | $Enums.WeaponType | null
  }

  export type StatModiferUpsertWithoutItemSourceInput = {
    update: XOR<StatModiferUpdateWithoutItemSourceInput, StatModiferUncheckedUpdateWithoutItemSourceInput>
    create: XOR<StatModiferCreateWithoutItemSourceInput, StatModiferUncheckedCreateWithoutItemSourceInput>
    where?: StatModiferWhereInput
  }

  export type StatModiferUpdateToOneWithWhereWithoutItemSourceInput = {
    where?: StatModiferWhereInput
    data: XOR<StatModiferUpdateWithoutItemSourceInput, StatModiferUncheckedUpdateWithoutItemSourceInput>
  }

  export type StatModiferUpdateWithoutItemSourceInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
    QuestSource?: QuestUpdateOneWithoutStatModiferNestedInput
    AbilitySource?: AbilityUpdateOneWithoutStatModiferNestedInput
    SkillSource?: SkillUpdateOneWithoutStatModiferNestedInput
    SpellSource?: SpellUpdateOneWithoutStatModiferNestedInput
    PotionSource?: PotionUpdateOneWithoutStatModiferNestedInput
  }

  export type StatModiferUncheckedUpdateWithoutItemSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AppliedTagUpsertWithoutItemTagSourceInput = {
    update: XOR<AppliedTagUpdateWithoutItemTagSourceInput, AppliedTagUncheckedUpdateWithoutItemTagSourceInput>
    create: XOR<AppliedTagCreateWithoutItemTagSourceInput, AppliedTagUncheckedCreateWithoutItemTagSourceInput>
    where?: AppliedTagWhereInput
  }

  export type AppliedTagUpdateToOneWithWhereWithoutItemTagSourceInput = {
    where?: AppliedTagWhereInput
    data: XOR<AppliedTagUpdateWithoutItemTagSourceInput, AppliedTagUncheckedUpdateWithoutItemTagSourceInput>
  }

  export type AppliedTagUpdateWithoutItemTagSourceInput = {
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    Tag?: TagUpdateOneRequiredWithoutAppliedTagNestedInput
    ArticleTagSource?: ArticleUpdateOneWithoutArticleTagSourceNestedInput
    MobTagSource?: MobUpdateOneWithoutMobTagSourceNestedInput
    QuestTagSource?: QuestUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type AppliedTagUncheckedUpdateWithoutItemTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCreateWithoutItemWeaponInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    CreatedItems: AccountCreateNestedOneWithoutCreatedItemsInput
    ModifiedItems?: AccountCreateNestedOneWithoutModifiedItemsInput
    ItemSpell?: ItemSpellCreateNestedManyWithoutItemInput
    AmmoItem?: ItemWeaponCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUncheckedCreateWithoutItemWeaponInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutItemInput
    AmmoItem?: ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemCreateOrConnectWithoutItemWeaponInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemWeaponInput, ItemUncheckedCreateWithoutItemWeaponInput>
  }

  export type ItemCreateWithoutAmmoItemInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    CreatedItems: AccountCreateNestedOneWithoutCreatedItemsInput
    ModifiedItems?: AccountCreateNestedOneWithoutModifiedItemsInput
    ItemSpell?: ItemSpellCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponCreateNestedOneWithoutItemInput
    StatModifer?: StatModiferCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUncheckedCreateWithoutAmmoItemInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponUncheckedCreateNestedOneWithoutItemInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemCreateOrConnectWithoutAmmoItemInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutAmmoItemInput, ItemUncheckedCreateWithoutAmmoItemInput>
  }

  export type ItemUpsertWithoutItemWeaponInput = {
    update: XOR<ItemUpdateWithoutItemWeaponInput, ItemUncheckedUpdateWithoutItemWeaponInput>
    create: XOR<ItemCreateWithoutItemWeaponInput, ItemUncheckedCreateWithoutItemWeaponInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutItemWeaponInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutItemWeaponInput, ItemUncheckedUpdateWithoutItemWeaponInput>
  }

  export type ItemUpdateWithoutItemWeaponInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedItems?: AccountUpdateOneRequiredWithoutCreatedItemsNestedInput
    ModifiedItems?: AccountUpdateOneWithoutModifiedItemsNestedInput
    ItemSpell?: ItemSpellUpdateManyWithoutItemNestedInput
    AmmoItem?: ItemWeaponUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemWeaponInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutItemNestedInput
    AmmoItem?: ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUpsertWithoutAmmoItemInput = {
    update: XOR<ItemUpdateWithoutAmmoItemInput, ItemUncheckedUpdateWithoutAmmoItemInput>
    create: XOR<ItemCreateWithoutAmmoItemInput, ItemUncheckedCreateWithoutAmmoItemInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutAmmoItemInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutAmmoItemInput, ItemUncheckedUpdateWithoutAmmoItemInput>
  }

  export type ItemUpdateWithoutAmmoItemInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedItems?: AccountUpdateOneRequiredWithoutCreatedItemsNestedInput
    ModifiedItems?: AccountUpdateOneWithoutModifiedItemsNestedInput
    ItemSpell?: ItemSpellUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUpdateOneWithoutItemNestedInput
    StatModifer?: StatModiferUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateWithoutAmmoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUncheckedUpdateOneWithoutItemNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemCreateWithoutItemSpellInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    CreatedItems: AccountCreateNestedOneWithoutCreatedItemsInput
    ModifiedItems?: AccountCreateNestedOneWithoutModifiedItemsInput
    ItemWeapon?: ItemWeaponCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUncheckedCreateWithoutItemSpellInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemWeapon?: ItemWeaponUncheckedCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutItemSourceInput
    ItemTagSource?: AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemCreateOrConnectWithoutItemSpellInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemSpellInput, ItemUncheckedCreateWithoutItemSpellInput>
  }

  export type SpellCreateWithoutItemSpellInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    CreatedSpells: AccountCreateNestedOneWithoutCreatedSpellsInput
    ModifiedSpells: AccountCreateNestedOneWithoutModifiedSpellsInput
    StatModifer?: StatModiferCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellUncheckedCreateWithoutItemSpellInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutSpellSourceInput
  }

  export type SpellCreateOrConnectWithoutItemSpellInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutItemSpellInput, SpellUncheckedCreateWithoutItemSpellInput>
  }

  export type ItemUpsertWithoutItemSpellInput = {
    update: XOR<ItemUpdateWithoutItemSpellInput, ItemUncheckedUpdateWithoutItemSpellInput>
    create: XOR<ItemCreateWithoutItemSpellInput, ItemUncheckedCreateWithoutItemSpellInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutItemSpellInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutItemSpellInput, ItemUncheckedUpdateWithoutItemSpellInput>
  }

  export type ItemUpdateWithoutItemSpellInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedItems?: AccountUpdateOneRequiredWithoutCreatedItemsNestedInput
    ModifiedItems?: AccountUpdateOneWithoutModifiedItemsNestedInput
    ItemWeapon?: ItemWeaponUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemWeapon?: ItemWeaponUncheckedUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput
  }

  export type SpellUpsertWithoutItemSpellInput = {
    update: XOR<SpellUpdateWithoutItemSpellInput, SpellUncheckedUpdateWithoutItemSpellInput>
    create: XOR<SpellCreateWithoutItemSpellInput, SpellUncheckedCreateWithoutItemSpellInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutItemSpellInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutItemSpellInput, SpellUncheckedUpdateWithoutItemSpellInput>
  }

  export type SpellUpdateWithoutItemSpellInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedSpells?: AccountUpdateOneRequiredWithoutCreatedSpellsNestedInput
    ModifiedSpells?: AccountUpdateOneRequiredWithoutModifiedSpellsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutSpellSourceNestedInput
  }

  export type SpellUncheckedUpdateWithoutItemSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutSpellSourceNestedInput
  }

  export type ItemSpellCreateWithoutSpellInput = {
    Item: ItemCreateNestedOneWithoutItemSpellInput
  }

  export type ItemSpellUncheckedCreateWithoutSpellInput = {
    id?: number
    itemId: number
  }

  export type ItemSpellCreateOrConnectWithoutSpellInput = {
    where: ItemSpellWhereUniqueInput
    create: XOR<ItemSpellCreateWithoutSpellInput, ItemSpellUncheckedCreateWithoutSpellInput>
  }

  export type ItemSpellCreateManySpellInputEnvelope = {
    data: ItemSpellCreateManySpellInput | ItemSpellCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutCreatedSpellsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutCreatedSpellsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutCreatedSpellsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCreatedSpellsInput, AccountUncheckedCreateWithoutCreatedSpellsInput>
  }

  export type AccountCreateWithoutModifiedSpellsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutModifiedSpellsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutModifiedSpellsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModifiedSpellsInput, AccountUncheckedCreateWithoutModifiedSpellsInput>
  }

  export type StatModiferCreateWithoutSpellSourceInput = {
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
    ItemSource?: ItemCreateNestedOneWithoutStatModiferInput
    QuestSource?: QuestCreateNestedOneWithoutStatModiferInput
    AbilitySource?: AbilityCreateNestedOneWithoutStatModiferInput
    SkillSource?: SkillCreateNestedOneWithoutStatModiferInput
    PotionSource?: PotionCreateNestedOneWithoutStatModiferInput
  }

  export type StatModiferUncheckedCreateWithoutSpellSourceInput = {
    id?: number
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferCreateOrConnectWithoutSpellSourceInput = {
    where: StatModiferWhereUniqueInput
    create: XOR<StatModiferCreateWithoutSpellSourceInput, StatModiferUncheckedCreateWithoutSpellSourceInput>
  }

  export type ItemSpellUpsertWithWhereUniqueWithoutSpellInput = {
    where: ItemSpellWhereUniqueInput
    update: XOR<ItemSpellUpdateWithoutSpellInput, ItemSpellUncheckedUpdateWithoutSpellInput>
    create: XOR<ItemSpellCreateWithoutSpellInput, ItemSpellUncheckedCreateWithoutSpellInput>
  }

  export type ItemSpellUpdateWithWhereUniqueWithoutSpellInput = {
    where: ItemSpellWhereUniqueInput
    data: XOR<ItemSpellUpdateWithoutSpellInput, ItemSpellUncheckedUpdateWithoutSpellInput>
  }

  export type ItemSpellUpdateManyWithWhereWithoutSpellInput = {
    where: ItemSpellScalarWhereInput
    data: XOR<ItemSpellUpdateManyMutationInput, ItemSpellUncheckedUpdateManyWithoutSpellInput>
  }

  export type AccountUpsertWithoutCreatedSpellsInput = {
    update: XOR<AccountUpdateWithoutCreatedSpellsInput, AccountUncheckedUpdateWithoutCreatedSpellsInput>
    create: XOR<AccountCreateWithoutCreatedSpellsInput, AccountUncheckedCreateWithoutCreatedSpellsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCreatedSpellsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCreatedSpellsInput, AccountUncheckedUpdateWithoutCreatedSpellsInput>
  }

  export type AccountUpdateWithoutCreatedSpellsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutCreatedSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUpsertWithoutModifiedSpellsInput = {
    update: XOR<AccountUpdateWithoutModifiedSpellsInput, AccountUncheckedUpdateWithoutModifiedSpellsInput>
    create: XOR<AccountCreateWithoutModifiedSpellsInput, AccountUncheckedCreateWithoutModifiedSpellsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModifiedSpellsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModifiedSpellsInput, AccountUncheckedUpdateWithoutModifiedSpellsInput>
  }

  export type AccountUpdateWithoutModifiedSpellsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutModifiedSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StatModiferUpsertWithoutSpellSourceInput = {
    update: XOR<StatModiferUpdateWithoutSpellSourceInput, StatModiferUncheckedUpdateWithoutSpellSourceInput>
    create: XOR<StatModiferCreateWithoutSpellSourceInput, StatModiferUncheckedCreateWithoutSpellSourceInput>
    where?: StatModiferWhereInput
  }

  export type StatModiferUpdateToOneWithWhereWithoutSpellSourceInput = {
    where?: StatModiferWhereInput
    data: XOR<StatModiferUpdateWithoutSpellSourceInput, StatModiferUncheckedUpdateWithoutSpellSourceInput>
  }

  export type StatModiferUpdateWithoutSpellSourceInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSource?: ItemUpdateOneWithoutStatModiferNestedInput
    QuestSource?: QuestUpdateOneWithoutStatModiferNestedInput
    AbilitySource?: AbilityUpdateOneWithoutStatModiferNestedInput
    SkillSource?: SkillUpdateOneWithoutStatModiferNestedInput
    PotionSource?: PotionUpdateOneWithoutStatModiferNestedInput
  }

  export type StatModiferUncheckedUpdateWithoutSpellSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateWithoutCreatedPotionsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutCreatedPotionsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutCreatedPotionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCreatedPotionsInput, AccountUncheckedCreateWithoutCreatedPotionsInput>
  }

  export type AccountCreateWithoutModifiedPotionsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutModifiedPotionsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutModifiedPotionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModifiedPotionsInput, AccountUncheckedCreateWithoutModifiedPotionsInput>
  }

  export type StatModiferCreateWithoutPotionSourceInput = {
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
    ItemSource?: ItemCreateNestedOneWithoutStatModiferInput
    QuestSource?: QuestCreateNestedOneWithoutStatModiferInput
    AbilitySource?: AbilityCreateNestedOneWithoutStatModiferInput
    SkillSource?: SkillCreateNestedOneWithoutStatModiferInput
    SpellSource?: SpellCreateNestedOneWithoutStatModiferInput
  }

  export type StatModiferUncheckedCreateWithoutPotionSourceInput = {
    id?: number
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferCreateOrConnectWithoutPotionSourceInput = {
    where: StatModiferWhereUniqueInput
    create: XOR<StatModiferCreateWithoutPotionSourceInput, StatModiferUncheckedCreateWithoutPotionSourceInput>
  }

  export type AccountUpsertWithoutCreatedPotionsInput = {
    update: XOR<AccountUpdateWithoutCreatedPotionsInput, AccountUncheckedUpdateWithoutCreatedPotionsInput>
    create: XOR<AccountCreateWithoutCreatedPotionsInput, AccountUncheckedCreateWithoutCreatedPotionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCreatedPotionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCreatedPotionsInput, AccountUncheckedUpdateWithoutCreatedPotionsInput>
  }

  export type AccountUpdateWithoutCreatedPotionsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutCreatedPotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUpsertWithoutModifiedPotionsInput = {
    update: XOR<AccountUpdateWithoutModifiedPotionsInput, AccountUncheckedUpdateWithoutModifiedPotionsInput>
    create: XOR<AccountCreateWithoutModifiedPotionsInput, AccountUncheckedCreateWithoutModifiedPotionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModifiedPotionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModifiedPotionsInput, AccountUncheckedUpdateWithoutModifiedPotionsInput>
  }

  export type AccountUpdateWithoutModifiedPotionsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutModifiedPotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StatModiferUpsertWithoutPotionSourceInput = {
    update: XOR<StatModiferUpdateWithoutPotionSourceInput, StatModiferUncheckedUpdateWithoutPotionSourceInput>
    create: XOR<StatModiferCreateWithoutPotionSourceInput, StatModiferUncheckedCreateWithoutPotionSourceInput>
    where?: StatModiferWhereInput
  }

  export type StatModiferUpdateToOneWithWhereWithoutPotionSourceInput = {
    where?: StatModiferWhereInput
    data: XOR<StatModiferUpdateWithoutPotionSourceInput, StatModiferUncheckedUpdateWithoutPotionSourceInput>
  }

  export type StatModiferUpdateWithoutPotionSourceInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSource?: ItemUpdateOneWithoutStatModiferNestedInput
    QuestSource?: QuestUpdateOneWithoutStatModiferNestedInput
    AbilitySource?: AbilityUpdateOneWithoutStatModiferNestedInput
    SkillSource?: SkillUpdateOneWithoutStatModiferNestedInput
    SpellSource?: SpellUpdateOneWithoutStatModiferNestedInput
  }

  export type StatModiferUncheckedUpdateWithoutPotionSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateWithoutCreatedSkillsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutCreatedSkillsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutCreatedSkillsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCreatedSkillsInput, AccountUncheckedCreateWithoutCreatedSkillsInput>
  }

  export type AccountCreateWithoutModifiedSkillsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutModifiedSkillsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutModifiedSkillsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModifiedSkillsInput, AccountUncheckedCreateWithoutModifiedSkillsInput>
  }

  export type StatModiferCreateWithoutSkillSourceInput = {
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
    ItemSource?: ItemCreateNestedOneWithoutStatModiferInput
    QuestSource?: QuestCreateNestedOneWithoutStatModiferInput
    AbilitySource?: AbilityCreateNestedOneWithoutStatModiferInput
    SpellSource?: SpellCreateNestedOneWithoutStatModiferInput
    PotionSource?: PotionCreateNestedOneWithoutStatModiferInput
  }

  export type StatModiferUncheckedCreateWithoutSkillSourceInput = {
    id?: number
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferCreateOrConnectWithoutSkillSourceInput = {
    where: StatModiferWhereUniqueInput
    create: XOR<StatModiferCreateWithoutSkillSourceInput, StatModiferUncheckedCreateWithoutSkillSourceInput>
  }

  export type AccountUpsertWithoutCreatedSkillsInput = {
    update: XOR<AccountUpdateWithoutCreatedSkillsInput, AccountUncheckedUpdateWithoutCreatedSkillsInput>
    create: XOR<AccountCreateWithoutCreatedSkillsInput, AccountUncheckedCreateWithoutCreatedSkillsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCreatedSkillsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCreatedSkillsInput, AccountUncheckedUpdateWithoutCreatedSkillsInput>
  }

  export type AccountUpdateWithoutCreatedSkillsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutCreatedSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUpsertWithoutModifiedSkillsInput = {
    update: XOR<AccountUpdateWithoutModifiedSkillsInput, AccountUncheckedUpdateWithoutModifiedSkillsInput>
    create: XOR<AccountCreateWithoutModifiedSkillsInput, AccountUncheckedCreateWithoutModifiedSkillsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModifiedSkillsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModifiedSkillsInput, AccountUncheckedUpdateWithoutModifiedSkillsInput>
  }

  export type AccountUpdateWithoutModifiedSkillsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutModifiedSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StatModiferUpsertWithoutSkillSourceInput = {
    update: XOR<StatModiferUpdateWithoutSkillSourceInput, StatModiferUncheckedUpdateWithoutSkillSourceInput>
    create: XOR<StatModiferCreateWithoutSkillSourceInput, StatModiferUncheckedCreateWithoutSkillSourceInput>
    where?: StatModiferWhereInput
  }

  export type StatModiferUpdateToOneWithWhereWithoutSkillSourceInput = {
    where?: StatModiferWhereInput
    data: XOR<StatModiferUpdateWithoutSkillSourceInput, StatModiferUncheckedUpdateWithoutSkillSourceInput>
  }

  export type StatModiferUpdateWithoutSkillSourceInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSource?: ItemUpdateOneWithoutStatModiferNestedInput
    QuestSource?: QuestUpdateOneWithoutStatModiferNestedInput
    AbilitySource?: AbilityUpdateOneWithoutStatModiferNestedInput
    SpellSource?: SpellUpdateOneWithoutStatModiferNestedInput
    PotionSource?: PotionUpdateOneWithoutStatModiferNestedInput
  }

  export type StatModiferUncheckedUpdateWithoutSkillSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateWithoutCreatedAbilitiesInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutCreatedAbilitiesInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutCreatedAbilitiesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCreatedAbilitiesInput, AccountUncheckedCreateWithoutCreatedAbilitiesInput>
  }

  export type AccountCreateWithoutModifiedAbilitiesInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutModifiedAbilitiesInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutModifiedAbilitiesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModifiedAbilitiesInput, AccountUncheckedCreateWithoutModifiedAbilitiesInput>
  }

  export type StatModiferCreateWithoutAbilitySourceInput = {
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
    ItemSource?: ItemCreateNestedOneWithoutStatModiferInput
    QuestSource?: QuestCreateNestedOneWithoutStatModiferInput
    SkillSource?: SkillCreateNestedOneWithoutStatModiferInput
    SpellSource?: SpellCreateNestedOneWithoutStatModiferInput
    PotionSource?: PotionCreateNestedOneWithoutStatModiferInput
  }

  export type StatModiferUncheckedCreateWithoutAbilitySourceInput = {
    id?: number
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferCreateOrConnectWithoutAbilitySourceInput = {
    where: StatModiferWhereUniqueInput
    create: XOR<StatModiferCreateWithoutAbilitySourceInput, StatModiferUncheckedCreateWithoutAbilitySourceInput>
  }

  export type AccountUpsertWithoutCreatedAbilitiesInput = {
    update: XOR<AccountUpdateWithoutCreatedAbilitiesInput, AccountUncheckedUpdateWithoutCreatedAbilitiesInput>
    create: XOR<AccountCreateWithoutCreatedAbilitiesInput, AccountUncheckedCreateWithoutCreatedAbilitiesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCreatedAbilitiesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCreatedAbilitiesInput, AccountUncheckedUpdateWithoutCreatedAbilitiesInput>
  }

  export type AccountUpdateWithoutCreatedAbilitiesInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutCreatedAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUpsertWithoutModifiedAbilitiesInput = {
    update: XOR<AccountUpdateWithoutModifiedAbilitiesInput, AccountUncheckedUpdateWithoutModifiedAbilitiesInput>
    create: XOR<AccountCreateWithoutModifiedAbilitiesInput, AccountUncheckedCreateWithoutModifiedAbilitiesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModifiedAbilitiesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModifiedAbilitiesInput, AccountUncheckedUpdateWithoutModifiedAbilitiesInput>
  }

  export type AccountUpdateWithoutModifiedAbilitiesInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutModifiedAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StatModiferUpsertWithoutAbilitySourceInput = {
    update: XOR<StatModiferUpdateWithoutAbilitySourceInput, StatModiferUncheckedUpdateWithoutAbilitySourceInput>
    create: XOR<StatModiferCreateWithoutAbilitySourceInput, StatModiferUncheckedCreateWithoutAbilitySourceInput>
    where?: StatModiferWhereInput
  }

  export type StatModiferUpdateToOneWithWhereWithoutAbilitySourceInput = {
    where?: StatModiferWhereInput
    data: XOR<StatModiferUpdateWithoutAbilitySourceInput, StatModiferUncheckedUpdateWithoutAbilitySourceInput>
  }

  export type StatModiferUpdateWithoutAbilitySourceInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSource?: ItemUpdateOneWithoutStatModiferNestedInput
    QuestSource?: QuestUpdateOneWithoutStatModiferNestedInput
    SkillSource?: SkillUpdateOneWithoutStatModiferNestedInput
    SpellSource?: SpellUpdateOneWithoutStatModiferNestedInput
    PotionSource?: PotionUpdateOneWithoutStatModiferNestedInput
  }

  export type StatModiferUncheckedUpdateWithoutAbilitySourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateWithoutCreatedQuestsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutCreatedQuestsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutCreatedQuestsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCreatedQuestsInput, AccountUncheckedCreateWithoutCreatedQuestsInput>
  }

  export type AccountCreateWithoutModifiedQuestsInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutModifiedQuestsInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutModifiedQuestsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutModifiedQuestsInput, AccountUncheckedCreateWithoutModifiedQuestsInput>
  }

  export type CharacterQuestCreateWithoutQuestInput = {
    CharacterVersion: CharacterVersionCreateNestedOneWithoutCharacterQuestInput
  }

  export type CharacterQuestUncheckedCreateWithoutQuestInput = {
    id?: number
    characterVersionId: number
  }

  export type CharacterQuestCreateOrConnectWithoutQuestInput = {
    where: CharacterQuestWhereUniqueInput
    create: XOR<CharacterQuestCreateWithoutQuestInput, CharacterQuestUncheckedCreateWithoutQuestInput>
  }

  export type CharacterQuestCreateManyQuestInputEnvelope = {
    data: CharacterQuestCreateManyQuestInput | CharacterQuestCreateManyQuestInput[]
    skipDuplicates?: boolean
  }

  export type StatModiferCreateWithoutQuestSourceInput = {
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
    ItemSource?: ItemCreateNestedOneWithoutStatModiferInput
    AbilitySource?: AbilityCreateNestedOneWithoutStatModiferInput
    SkillSource?: SkillCreateNestedOneWithoutStatModiferInput
    SpellSource?: SpellCreateNestedOneWithoutStatModiferInput
    PotionSource?: PotionCreateNestedOneWithoutStatModiferInput
  }

  export type StatModiferUncheckedCreateWithoutQuestSourceInput = {
    id?: number
    type: $Enums.StatModifierType
    hp?: number | null
    mv?: number | null
    ma?: number | null
    ac?: number | null
    str?: number | null
    min?: number | null
    dex?: number | null
    con?: number | null
    per?: number | null
    spi?: number | null
    hpRegen?: number | null
    mvRegen?: number | null
    maRegen?: number | null
    damroll?: number | null
    hitroll?: number | null
    mitigation?: number | null
    spellDam?: number | null
    spellCrit?: number | null
    spellRedux?: number | null
    concentration?: number | null
    shotAccuracy?: number | null
    bonusAccuracy?: number | null
    ammoCapacity?: number | null
    parry?: number | null
    strCap?: number | null
    minCap?: number | null
    dexCap?: number | null
    conCap?: number | null
    perCap?: number | null
    spiCap?: number | null
  }

  export type StatModiferCreateOrConnectWithoutQuestSourceInput = {
    where: StatModiferWhereUniqueInput
    create: XOR<StatModiferCreateWithoutQuestSourceInput, StatModiferUncheckedCreateWithoutQuestSourceInput>
  }

  export type AppliedTagCreateWithoutQuestTagSourceInput = {
    typeId: $Enums.TagType
    Tag: TagCreateNestedOneWithoutAppliedTagInput
    ArticleTagSource?: ArticleCreateNestedOneWithoutArticleTagSourceInput
    ItemTagSource?: ItemCreateNestedOneWithoutItemTagSourceInput
    MobTagSource?: MobCreateNestedOneWithoutMobTagSourceInput
  }

  export type AppliedTagUncheckedCreateWithoutQuestTagSourceInput = {
    id?: number
    typeId: $Enums.TagType
    tagId: number
  }

  export type AppliedTagCreateOrConnectWithoutQuestTagSourceInput = {
    where: AppliedTagWhereUniqueInput
    create: XOR<AppliedTagCreateWithoutQuestTagSourceInput, AppliedTagUncheckedCreateWithoutQuestTagSourceInput>
  }

  export type AccountUpsertWithoutCreatedQuestsInput = {
    update: XOR<AccountUpdateWithoutCreatedQuestsInput, AccountUncheckedUpdateWithoutCreatedQuestsInput>
    create: XOR<AccountCreateWithoutCreatedQuestsInput, AccountUncheckedCreateWithoutCreatedQuestsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCreatedQuestsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCreatedQuestsInput, AccountUncheckedUpdateWithoutCreatedQuestsInput>
  }

  export type AccountUpdateWithoutCreatedQuestsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutCreatedQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUpsertWithoutModifiedQuestsInput = {
    update: XOR<AccountUpdateWithoutModifiedQuestsInput, AccountUncheckedUpdateWithoutModifiedQuestsInput>
    create: XOR<AccountCreateWithoutModifiedQuestsInput, AccountUncheckedCreateWithoutModifiedQuestsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutModifiedQuestsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutModifiedQuestsInput, AccountUncheckedUpdateWithoutModifiedQuestsInput>
  }

  export type AccountUpdateWithoutModifiedQuestsInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutModifiedQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CharacterQuestUpsertWithWhereUniqueWithoutQuestInput = {
    where: CharacterQuestWhereUniqueInput
    update: XOR<CharacterQuestUpdateWithoutQuestInput, CharacterQuestUncheckedUpdateWithoutQuestInput>
    create: XOR<CharacterQuestCreateWithoutQuestInput, CharacterQuestUncheckedCreateWithoutQuestInput>
  }

  export type CharacterQuestUpdateWithWhereUniqueWithoutQuestInput = {
    where: CharacterQuestWhereUniqueInput
    data: XOR<CharacterQuestUpdateWithoutQuestInput, CharacterQuestUncheckedUpdateWithoutQuestInput>
  }

  export type CharacterQuestUpdateManyWithWhereWithoutQuestInput = {
    where: CharacterQuestScalarWhereInput
    data: XOR<CharacterQuestUpdateManyMutationInput, CharacterQuestUncheckedUpdateManyWithoutQuestInput>
  }

  export type StatModiferUpsertWithoutQuestSourceInput = {
    update: XOR<StatModiferUpdateWithoutQuestSourceInput, StatModiferUncheckedUpdateWithoutQuestSourceInput>
    create: XOR<StatModiferCreateWithoutQuestSourceInput, StatModiferUncheckedCreateWithoutQuestSourceInput>
    where?: StatModiferWhereInput
  }

  export type StatModiferUpdateToOneWithWhereWithoutQuestSourceInput = {
    where?: StatModiferWhereInput
    data: XOR<StatModiferUpdateWithoutQuestSourceInput, StatModiferUncheckedUpdateWithoutQuestSourceInput>
  }

  export type StatModiferUpdateWithoutQuestSourceInput = {
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSource?: ItemUpdateOneWithoutStatModiferNestedInput
    AbilitySource?: AbilityUpdateOneWithoutStatModiferNestedInput
    SkillSource?: SkillUpdateOneWithoutStatModiferNestedInput
    SpellSource?: SpellUpdateOneWithoutStatModiferNestedInput
    PotionSource?: PotionUpdateOneWithoutStatModiferNestedInput
  }

  export type StatModiferUncheckedUpdateWithoutQuestSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumStatModifierTypeFieldUpdateOperationsInput | $Enums.StatModifierType
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    mv?: NullableIntFieldUpdateOperationsInput | number | null
    ma?: NullableIntFieldUpdateOperationsInput | number | null
    ac?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    con?: NullableIntFieldUpdateOperationsInput | number | null
    per?: NullableIntFieldUpdateOperationsInput | number | null
    spi?: NullableIntFieldUpdateOperationsInput | number | null
    hpRegen?: NullableIntFieldUpdateOperationsInput | number | null
    mvRegen?: NullableIntFieldUpdateOperationsInput | number | null
    maRegen?: NullableIntFieldUpdateOperationsInput | number | null
    damroll?: NullableIntFieldUpdateOperationsInput | number | null
    hitroll?: NullableIntFieldUpdateOperationsInput | number | null
    mitigation?: NullableIntFieldUpdateOperationsInput | number | null
    spellDam?: NullableIntFieldUpdateOperationsInput | number | null
    spellCrit?: NullableIntFieldUpdateOperationsInput | number | null
    spellRedux?: NullableIntFieldUpdateOperationsInput | number | null
    concentration?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    bonusAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    parry?: NullableIntFieldUpdateOperationsInput | number | null
    strCap?: NullableIntFieldUpdateOperationsInput | number | null
    minCap?: NullableIntFieldUpdateOperationsInput | number | null
    dexCap?: NullableIntFieldUpdateOperationsInput | number | null
    conCap?: NullableIntFieldUpdateOperationsInput | number | null
    perCap?: NullableIntFieldUpdateOperationsInput | number | null
    spiCap?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AppliedTagUpsertWithoutQuestTagSourceInput = {
    update: XOR<AppliedTagUpdateWithoutQuestTagSourceInput, AppliedTagUncheckedUpdateWithoutQuestTagSourceInput>
    create: XOR<AppliedTagCreateWithoutQuestTagSourceInput, AppliedTagUncheckedCreateWithoutQuestTagSourceInput>
    where?: AppliedTagWhereInput
  }

  export type AppliedTagUpdateToOneWithWhereWithoutQuestTagSourceInput = {
    where?: AppliedTagWhereInput
    data: XOR<AppliedTagUpdateWithoutQuestTagSourceInput, AppliedTagUncheckedUpdateWithoutQuestTagSourceInput>
  }

  export type AppliedTagUpdateWithoutQuestTagSourceInput = {
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    Tag?: TagUpdateOneRequiredWithoutAppliedTagNestedInput
    ArticleTagSource?: ArticleUpdateOneWithoutArticleTagSourceNestedInput
    ItemTagSource?: ItemUpdateOneWithoutItemTagSourceNestedInput
    MobTagSource?: MobUpdateOneWithoutMobTagSourceNestedInput
  }

  export type AppliedTagUncheckedUpdateWithoutQuestTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCreateWithoutStatModiferInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    CreatedItems: AccountCreateNestedOneWithoutCreatedItemsInput
    ModifiedItems?: AccountCreateNestedOneWithoutModifiedItemsInput
    ItemSpell?: ItemSpellCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponCreateNestedManyWithoutAmmoItemInput
    ItemTagSource?: AppliedTagCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemUncheckedCreateWithoutStatModiferInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponUncheckedCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput
    ItemTagSource?: AppliedTagUncheckedCreateNestedOneWithoutItemTagSourceInput
  }

  export type ItemCreateOrConnectWithoutStatModiferInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutStatModiferInput, ItemUncheckedCreateWithoutStatModiferInput>
  }

  export type QuestCreateWithoutStatModiferInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CreatedQuests: AccountCreateNestedOneWithoutCreatedQuestsInput
    ModifiedQuests: AccountCreateNestedOneWithoutModifiedQuestsInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutQuestInput
    QuestTagSource?: AppliedTagCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestUncheckedCreateWithoutStatModiferInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutQuestInput
    QuestTagSource?: AppliedTagUncheckedCreateNestedOneWithoutQuestTagSourceInput
  }

  export type QuestCreateOrConnectWithoutStatModiferInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutStatModiferInput, QuestUncheckedCreateWithoutStatModiferInput>
  }

  export type AbilityCreateWithoutStatModiferInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
    CreatedAbilities: AccountCreateNestedOneWithoutCreatedAbilitiesInput
    ModifiedAbilities: AccountCreateNestedOneWithoutModifiedAbilitiesInput
  }

  export type AbilityUncheckedCreateWithoutStatModiferInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
  }

  export type AbilityCreateOrConnectWithoutStatModiferInput = {
    where: AbilityWhereUniqueInput
    create: XOR<AbilityCreateWithoutStatModiferInput, AbilityUncheckedCreateWithoutStatModiferInput>
  }

  export type SkillCreateWithoutStatModiferInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
    CreatedSkills: AccountCreateNestedOneWithoutCreatedSkillsInput
    ModifiedSkills: AccountCreateNestedOneWithoutModifiedSkillsInput
  }

  export type SkillUncheckedCreateWithoutStatModiferInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
  }

  export type SkillCreateOrConnectWithoutStatModiferInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutStatModiferInput, SkillUncheckedCreateWithoutStatModiferInput>
  }

  export type SpellCreateWithoutStatModiferInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellCreateNestedManyWithoutSpellInput
    CreatedSpells: AccountCreateNestedOneWithoutCreatedSpellsInput
    ModifiedSpells: AccountCreateNestedOneWithoutModifiedSpellsInput
  }

  export type SpellUncheckedCreateWithoutStatModiferInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutStatModiferInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutStatModiferInput, SpellUncheckedCreateWithoutStatModiferInput>
  }

  export type PotionCreateWithoutStatModiferInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
    CreatedPotions: AccountCreateNestedOneWithoutCreatedPotionsInput
    ModifiedPotions: AccountCreateNestedOneWithoutModifiedPotionsInput
  }

  export type PotionUncheckedCreateWithoutStatModiferInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
  }

  export type PotionCreateOrConnectWithoutStatModiferInput = {
    where: PotionWhereUniqueInput
    create: XOR<PotionCreateWithoutStatModiferInput, PotionUncheckedCreateWithoutStatModiferInput>
  }

  export type ItemUpsertWithoutStatModiferInput = {
    update: XOR<ItemUpdateWithoutStatModiferInput, ItemUncheckedUpdateWithoutStatModiferInput>
    create: XOR<ItemCreateWithoutStatModiferInput, ItemUncheckedCreateWithoutStatModiferInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutStatModiferInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutStatModiferInput, ItemUncheckedUpdateWithoutStatModiferInput>
  }

  export type ItemUpdateWithoutStatModiferInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedItems?: AccountUpdateOneRequiredWithoutCreatedItemsNestedInput
    ModifiedItems?: AccountUpdateOneWithoutModifiedItemsNestedInput
    ItemSpell?: ItemSpellUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUpdateManyWithoutAmmoItemNestedInput
    ItemTagSource?: AppliedTagUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateWithoutStatModiferInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUncheckedUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput
    ItemTagSource?: AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput
  }

  export type QuestUpsertWithoutStatModiferInput = {
    update: XOR<QuestUpdateWithoutStatModiferInput, QuestUncheckedUpdateWithoutStatModiferInput>
    create: XOR<QuestCreateWithoutStatModiferInput, QuestUncheckedCreateWithoutStatModiferInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutStatModiferInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutStatModiferInput, QuestUncheckedUpdateWithoutStatModiferInput>
  }

  export type QuestUpdateWithoutStatModiferInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedQuests?: AccountUpdateOneRequiredWithoutCreatedQuestsNestedInput
    ModifiedQuests?: AccountUpdateOneRequiredWithoutModifiedQuestsNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutQuestNestedInput
    QuestTagSource?: AppliedTagUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestUncheckedUpdateWithoutStatModiferInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutQuestNestedInput
    QuestTagSource?: AppliedTagUncheckedUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type AbilityUpsertWithoutStatModiferInput = {
    update: XOR<AbilityUpdateWithoutStatModiferInput, AbilityUncheckedUpdateWithoutStatModiferInput>
    create: XOR<AbilityCreateWithoutStatModiferInput, AbilityUncheckedCreateWithoutStatModiferInput>
    where?: AbilityWhereInput
  }

  export type AbilityUpdateToOneWithWhereWithoutStatModiferInput = {
    where?: AbilityWhereInput
    data: XOR<AbilityUpdateWithoutStatModiferInput, AbilityUncheckedUpdateWithoutStatModiferInput>
  }

  export type AbilityUpdateWithoutStatModiferInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedAbilities?: AccountUpdateOneRequiredWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AccountUpdateOneRequiredWithoutModifiedAbilitiesNestedInput
  }

  export type AbilityUncheckedUpdateWithoutStatModiferInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SkillUpsertWithoutStatModiferInput = {
    update: XOR<SkillUpdateWithoutStatModiferInput, SkillUncheckedUpdateWithoutStatModiferInput>
    create: XOR<SkillCreateWithoutStatModiferInput, SkillUncheckedCreateWithoutStatModiferInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutStatModiferInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutStatModiferInput, SkillUncheckedUpdateWithoutStatModiferInput>
  }

  export type SkillUpdateWithoutStatModiferInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
    CreatedSkills?: AccountUpdateOneRequiredWithoutCreatedSkillsNestedInput
    ModifiedSkills?: AccountUpdateOneRequiredWithoutModifiedSkillsNestedInput
  }

  export type SkillUncheckedUpdateWithoutStatModiferInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
  }

  export type SpellUpsertWithoutStatModiferInput = {
    update: XOR<SpellUpdateWithoutStatModiferInput, SpellUncheckedUpdateWithoutStatModiferInput>
    create: XOR<SpellCreateWithoutStatModiferInput, SpellUncheckedCreateWithoutStatModiferInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutStatModiferInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutStatModiferInput, SpellUncheckedUpdateWithoutStatModiferInput>
  }

  export type SpellUpdateWithoutStatModiferInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUpdateManyWithoutSpellNestedInput
    CreatedSpells?: AccountUpdateOneRequiredWithoutCreatedSpellsNestedInput
    ModifiedSpells?: AccountUpdateOneRequiredWithoutModifiedSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutStatModiferInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type PotionUpsertWithoutStatModiferInput = {
    update: XOR<PotionUpdateWithoutStatModiferInput, PotionUncheckedUpdateWithoutStatModiferInput>
    create: XOR<PotionCreateWithoutStatModiferInput, PotionUncheckedCreateWithoutStatModiferInput>
    where?: PotionWhereInput
  }

  export type PotionUpdateToOneWithWhereWithoutStatModiferInput = {
    where?: PotionWhereInput
    data: XOR<PotionUpdateWithoutStatModiferInput, PotionUncheckedUpdateWithoutStatModiferInput>
  }

  export type PotionUpdateWithoutStatModiferInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedPotions?: AccountUpdateOneRequiredWithoutCreatedPotionsNestedInput
    ModifiedPotions?: AccountUpdateOneRequiredWithoutModifiedPotionsNestedInput
  }

  export type PotionUncheckedUpdateWithoutStatModiferInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateWithoutArticleInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutArticleInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutArticleInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutArticleInput, AccountUncheckedCreateWithoutArticleInput>
  }

  export type ArticleVersionCreateWithoutArticleInput = {
    modifiedDate?: Date | string
    content: string
    isCurrent: boolean
    version?: string | null
    Editor: AccountCreateNestedOneWithoutArticleVersionInput
  }

  export type ArticleVersionUncheckedCreateWithoutArticleInput = {
    id?: number
    modifiedDate?: Date | string
    editorId: number
    content: string
    isCurrent: boolean
    version?: string | null
  }

  export type ArticleVersionCreateOrConnectWithoutArticleInput = {
    where: ArticleVersionWhereUniqueInput
    create: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput>
  }

  export type ArticleVersionCreateManyArticleInputEnvelope = {
    data: ArticleVersionCreateManyArticleInput | ArticleVersionCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type AppliedTagCreateWithoutArticleTagSourceInput = {
    typeId: $Enums.TagType
    Tag: TagCreateNestedOneWithoutAppliedTagInput
    ItemTagSource?: ItemCreateNestedOneWithoutItemTagSourceInput
    MobTagSource?: MobCreateNestedOneWithoutMobTagSourceInput
    QuestTagSource?: QuestCreateNestedOneWithoutQuestTagSourceInput
  }

  export type AppliedTagUncheckedCreateWithoutArticleTagSourceInput = {
    id?: number
    typeId: $Enums.TagType
    tagId: number
  }

  export type AppliedTagCreateOrConnectWithoutArticleTagSourceInput = {
    where: AppliedTagWhereUniqueInput
    create: XOR<AppliedTagCreateWithoutArticleTagSourceInput, AppliedTagUncheckedCreateWithoutArticleTagSourceInput>
  }

  export type AccountUpsertWithoutArticleInput = {
    update: XOR<AccountUpdateWithoutArticleInput, AccountUncheckedUpdateWithoutArticleInput>
    create: XOR<AccountCreateWithoutArticleInput, AccountUncheckedCreateWithoutArticleInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutArticleInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutArticleInput, AccountUncheckedUpdateWithoutArticleInput>
  }

  export type AccountUpdateWithoutArticleInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ArticleVersionUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleVersionWhereUniqueInput
    update: XOR<ArticleVersionUpdateWithoutArticleInput, ArticleVersionUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput>
  }

  export type ArticleVersionUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleVersionWhereUniqueInput
    data: XOR<ArticleVersionUpdateWithoutArticleInput, ArticleVersionUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleVersionUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleVersionScalarWhereInput
    data: XOR<ArticleVersionUpdateManyMutationInput, ArticleVersionUncheckedUpdateManyWithoutArticleInput>
  }

  export type AppliedTagUpsertWithoutArticleTagSourceInput = {
    update: XOR<AppliedTagUpdateWithoutArticleTagSourceInput, AppliedTagUncheckedUpdateWithoutArticleTagSourceInput>
    create: XOR<AppliedTagCreateWithoutArticleTagSourceInput, AppliedTagUncheckedCreateWithoutArticleTagSourceInput>
    where?: AppliedTagWhereInput
  }

  export type AppliedTagUpdateToOneWithWhereWithoutArticleTagSourceInput = {
    where?: AppliedTagWhereInput
    data: XOR<AppliedTagUpdateWithoutArticleTagSourceInput, AppliedTagUncheckedUpdateWithoutArticleTagSourceInput>
  }

  export type AppliedTagUpdateWithoutArticleTagSourceInput = {
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    Tag?: TagUpdateOneRequiredWithoutAppliedTagNestedInput
    ItemTagSource?: ItemUpdateOneWithoutItemTagSourceNestedInput
    MobTagSource?: MobUpdateOneWithoutMobTagSourceNestedInput
    QuestTagSource?: QuestUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type AppliedTagUncheckedUpdateWithoutArticleTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCreateWithoutArticleVersionInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutArticleVersionInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutArticleVersionInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutArticleVersionInput, AccountUncheckedCreateWithoutArticleVersionInput>
  }

  export type ArticleCreateWithoutArticleContentInput = {
    createdDate?: Date | string
    isProtected?: boolean
    Author: AccountCreateNestedOneWithoutArticleInput
    ArticleTagSource?: AppliedTagCreateNestedOneWithoutArticleTagSourceInput
  }

  export type ArticleUncheckedCreateWithoutArticleContentInput = {
    id?: number
    createdDate?: Date | string
    authorId: number
    isProtected?: boolean
    ArticleTagSource?: AppliedTagUncheckedCreateNestedOneWithoutArticleTagSourceInput
  }

  export type ArticleCreateOrConnectWithoutArticleContentInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticleContentInput, ArticleUncheckedCreateWithoutArticleContentInput>
  }

  export type AccountUpsertWithoutArticleVersionInput = {
    update: XOR<AccountUpdateWithoutArticleVersionInput, AccountUncheckedUpdateWithoutArticleVersionInput>
    create: XOR<AccountCreateWithoutArticleVersionInput, AccountUncheckedCreateWithoutArticleVersionInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutArticleVersionInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutArticleVersionInput, AccountUncheckedUpdateWithoutArticleVersionInput>
  }

  export type AccountUpdateWithoutArticleVersionInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutArticleVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ArticleUpsertWithoutArticleContentInput = {
    update: XOR<ArticleUpdateWithoutArticleContentInput, ArticleUncheckedUpdateWithoutArticleContentInput>
    create: XOR<ArticleCreateWithoutArticleContentInput, ArticleUncheckedCreateWithoutArticleContentInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutArticleContentInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutArticleContentInput, ArticleUncheckedUpdateWithoutArticleContentInput>
  }

  export type ArticleUpdateWithoutArticleContentInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    Author?: AccountUpdateOneRequiredWithoutArticleNestedInput
    ArticleTagSource?: AppliedTagUpdateOneWithoutArticleTagSourceNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticleContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    ArticleTagSource?: AppliedTagUncheckedUpdateOneWithoutArticleTagSourceNestedInput
  }

  export type AccountCreateWithoutTagInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutTagInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutTagInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTagInput, AccountUncheckedCreateWithoutTagInput>
  }

  export type AppliedTagCreateWithoutTagInput = {
    typeId: $Enums.TagType
    ArticleTagSource?: ArticleCreateNestedOneWithoutArticleTagSourceInput
    ItemTagSource?: ItemCreateNestedOneWithoutItemTagSourceInput
    MobTagSource?: MobCreateNestedOneWithoutMobTagSourceInput
    QuestTagSource?: QuestCreateNestedOneWithoutQuestTagSourceInput
  }

  export type AppliedTagUncheckedCreateWithoutTagInput = {
    id?: number
    typeId: $Enums.TagType
    sourceId?: number | null
  }

  export type AppliedTagCreateOrConnectWithoutTagInput = {
    where: AppliedTagWhereUniqueInput
    create: XOR<AppliedTagCreateWithoutTagInput, AppliedTagUncheckedCreateWithoutTagInput>
  }

  export type AppliedTagCreateManyTagInputEnvelope = {
    data: AppliedTagCreateManyTagInput | AppliedTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutTagInput = {
    update: XOR<AccountUpdateWithoutTagInput, AccountUncheckedUpdateWithoutTagInput>
    create: XOR<AccountCreateWithoutTagInput, AccountUncheckedCreateWithoutTagInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTagInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTagInput, AccountUncheckedUpdateWithoutTagInput>
  }

  export type AccountUpdateWithoutTagInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AppliedTagUpsertWithWhereUniqueWithoutTagInput = {
    where: AppliedTagWhereUniqueInput
    update: XOR<AppliedTagUpdateWithoutTagInput, AppliedTagUncheckedUpdateWithoutTagInput>
    create: XOR<AppliedTagCreateWithoutTagInput, AppliedTagUncheckedCreateWithoutTagInput>
  }

  export type AppliedTagUpdateWithWhereUniqueWithoutTagInput = {
    where: AppliedTagWhereUniqueInput
    data: XOR<AppliedTagUpdateWithoutTagInput, AppliedTagUncheckedUpdateWithoutTagInput>
  }

  export type AppliedTagUpdateManyWithWhereWithoutTagInput = {
    where: AppliedTagScalarWhereInput
    data: XOR<AppliedTagUpdateManyMutationInput, AppliedTagUncheckedUpdateManyWithoutTagInput>
  }

  export type AppliedTagScalarWhereInput = {
    AND?: AppliedTagScalarWhereInput | AppliedTagScalarWhereInput[]
    OR?: AppliedTagScalarWhereInput[]
    NOT?: AppliedTagScalarWhereInput | AppliedTagScalarWhereInput[]
    id?: IntFilter<"AppliedTag"> | number
    typeId?: EnumTagTypeFilter<"AppliedTag"> | $Enums.TagType
    sourceId?: IntNullableFilter<"AppliedTag"> | number | null
    tagId?: IntFilter<"AppliedTag"> | number
  }

  export type TagCreateWithoutAppliedTagInput = {
    createdDate?: Date | string
    tag: string
    Creator: AccountCreateNestedOneWithoutTagInput
  }

  export type TagUncheckedCreateWithoutAppliedTagInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    tag: string
  }

  export type TagCreateOrConnectWithoutAppliedTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutAppliedTagInput, TagUncheckedCreateWithoutAppliedTagInput>
  }

  export type ArticleCreateWithoutArticleTagSourceInput = {
    createdDate?: Date | string
    isProtected?: boolean
    Author: AccountCreateNestedOneWithoutArticleInput
    ArticleContent?: ArticleVersionCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticleTagSourceInput = {
    id?: number
    createdDate?: Date | string
    authorId: number
    isProtected?: boolean
    ArticleContent?: ArticleVersionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticleTagSourceInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticleTagSourceInput, ArticleUncheckedCreateWithoutArticleTagSourceInput>
  }

  export type ItemCreateWithoutItemTagSourceInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    CreatedItems: AccountCreateNestedOneWithoutCreatedItemsInput
    ModifiedItems?: AccountCreateNestedOneWithoutModifiedItemsInput
    ItemSpell?: ItemSpellCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferCreateNestedOneWithoutItemSourceInput
  }

  export type ItemUncheckedCreateWithoutItemTagSourceInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
    ItemSpell?: ItemSpellUncheckedCreateNestedManyWithoutItemInput
    ItemWeapon?: ItemWeaponUncheckedCreateNestedOneWithoutItemInput
    AmmoItem?: ItemWeaponUncheckedCreateNestedManyWithoutAmmoItemInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutItemSourceInput
  }

  export type ItemCreateOrConnectWithoutItemTagSourceInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemTagSourceInput, ItemUncheckedCreateWithoutItemTagSourceInput>
  }

  export type MobCreateWithoutMobTagSourceInput = {
    mudId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
    Area?: AreaCreateNestedOneWithoutMobInput
  }

  export type MobUncheckedCreateWithoutMobTagSourceInput = {
    id?: number
    mudId?: number | null
    areaId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
  }

  export type MobCreateOrConnectWithoutMobTagSourceInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutMobTagSourceInput, MobUncheckedCreateWithoutMobTagSourceInput>
  }

  export type QuestCreateWithoutQuestTagSourceInput = {
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CreatedQuests: AccountCreateNestedOneWithoutCreatedQuestsInput
    ModifiedQuests: AccountCreateNestedOneWithoutModifiedQuestsInput
    CharacterQuest?: CharacterQuestCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferCreateNestedOneWithoutQuestSourceInput
  }

  export type QuestUncheckedCreateWithoutQuestTagSourceInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
    CharacterQuest?: CharacterQuestUncheckedCreateNestedManyWithoutQuestInput
    StatModifer?: StatModiferUncheckedCreateNestedOneWithoutQuestSourceInput
  }

  export type QuestCreateOrConnectWithoutQuestTagSourceInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutQuestTagSourceInput, QuestUncheckedCreateWithoutQuestTagSourceInput>
  }

  export type TagUpsertWithoutAppliedTagInput = {
    update: XOR<TagUpdateWithoutAppliedTagInput, TagUncheckedUpdateWithoutAppliedTagInput>
    create: XOR<TagCreateWithoutAppliedTagInput, TagUncheckedCreateWithoutAppliedTagInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutAppliedTagInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutAppliedTagInput, TagUncheckedUpdateWithoutAppliedTagInput>
  }

  export type TagUpdateWithoutAppliedTagInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    Creator?: AccountUpdateOneRequiredWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutAppliedTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleUpsertWithoutArticleTagSourceInput = {
    update: XOR<ArticleUpdateWithoutArticleTagSourceInput, ArticleUncheckedUpdateWithoutArticleTagSourceInput>
    create: XOR<ArticleCreateWithoutArticleTagSourceInput, ArticleUncheckedCreateWithoutArticleTagSourceInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutArticleTagSourceInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutArticleTagSourceInput, ArticleUncheckedUpdateWithoutArticleTagSourceInput>
  }

  export type ArticleUpdateWithoutArticleTagSourceInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    Author?: AccountUpdateOneRequiredWithoutArticleNestedInput
    ArticleContent?: ArticleVersionUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticleTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    ArticleContent?: ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ItemUpsertWithoutItemTagSourceInput = {
    update: XOR<ItemUpdateWithoutItemTagSourceInput, ItemUncheckedUpdateWithoutItemTagSourceInput>
    create: XOR<ItemCreateWithoutItemTagSourceInput, ItemUncheckedCreateWithoutItemTagSourceInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutItemTagSourceInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutItemTagSourceInput, ItemUncheckedUpdateWithoutItemTagSourceInput>
  }

  export type ItemUpdateWithoutItemTagSourceInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedItems?: AccountUpdateOneRequiredWithoutCreatedItemsNestedInput
    ModifiedItems?: AccountUpdateOneWithoutModifiedItemsNestedInput
    ItemSpell?: ItemSpellUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUpdateOneWithoutItemSourceNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUncheckedUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput
  }

  export type MobUpsertWithoutMobTagSourceInput = {
    update: XOR<MobUpdateWithoutMobTagSourceInput, MobUncheckedUpdateWithoutMobTagSourceInput>
    create: XOR<MobCreateWithoutMobTagSourceInput, MobUncheckedCreateWithoutMobTagSourceInput>
    where?: MobWhereInput
  }

  export type MobUpdateToOneWithWhereWithoutMobTagSourceInput = {
    where?: MobWhereInput
    data: XOR<MobUpdateWithoutMobTagSourceInput, MobUncheckedUpdateWithoutMobTagSourceInput>
  }

  export type MobUpdateWithoutMobTagSourceInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
    Area?: AreaUpdateOneWithoutMobNestedInput
  }

  export type MobUncheckedUpdateWithoutMobTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestUpsertWithoutQuestTagSourceInput = {
    update: XOR<QuestUpdateWithoutQuestTagSourceInput, QuestUncheckedUpdateWithoutQuestTagSourceInput>
    create: XOR<QuestCreateWithoutQuestTagSourceInput, QuestUncheckedCreateWithoutQuestTagSourceInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutQuestTagSourceInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutQuestTagSourceInput, QuestUncheckedUpdateWithoutQuestTagSourceInput>
  }

  export type QuestUpdateWithoutQuestTagSourceInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedQuests?: AccountUpdateOneRequiredWithoutCreatedQuestsNestedInput
    ModifiedQuests?: AccountUpdateOneRequiredWithoutModifiedQuestsNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUpdateOneWithoutQuestSourceNestedInput
  }

  export type QuestUncheckedUpdateWithoutQuestTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutQuestSourceNestedInput
  }

  export type AppliedTagCreateWithoutMobTagSourceInput = {
    typeId: $Enums.TagType
    Tag: TagCreateNestedOneWithoutAppliedTagInput
    ArticleTagSource?: ArticleCreateNestedOneWithoutArticleTagSourceInput
    ItemTagSource?: ItemCreateNestedOneWithoutItemTagSourceInput
    QuestTagSource?: QuestCreateNestedOneWithoutQuestTagSourceInput
  }

  export type AppliedTagUncheckedCreateWithoutMobTagSourceInput = {
    id?: number
    typeId: $Enums.TagType
    tagId: number
  }

  export type AppliedTagCreateOrConnectWithoutMobTagSourceInput = {
    where: AppliedTagWhereUniqueInput
    create: XOR<AppliedTagCreateWithoutMobTagSourceInput, AppliedTagUncheckedCreateWithoutMobTagSourceInput>
  }

  export type AreaCreateWithoutMobInput = {
    mudId?: number | null
    name: string
    releaseDate?: Date | string | null
    Author?: AccountCreateNestedOneWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutMobInput = {
    id?: number
    mudId?: number | null
    name: string
    authorId?: number | null
    releaseDate?: Date | string | null
  }

  export type AreaCreateOrConnectWithoutMobInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutMobInput, AreaUncheckedCreateWithoutMobInput>
  }

  export type AppliedTagUpsertWithoutMobTagSourceInput = {
    update: XOR<AppliedTagUpdateWithoutMobTagSourceInput, AppliedTagUncheckedUpdateWithoutMobTagSourceInput>
    create: XOR<AppliedTagCreateWithoutMobTagSourceInput, AppliedTagUncheckedCreateWithoutMobTagSourceInput>
    where?: AppliedTagWhereInput
  }

  export type AppliedTagUpdateToOneWithWhereWithoutMobTagSourceInput = {
    where?: AppliedTagWhereInput
    data: XOR<AppliedTagUpdateWithoutMobTagSourceInput, AppliedTagUncheckedUpdateWithoutMobTagSourceInput>
  }

  export type AppliedTagUpdateWithoutMobTagSourceInput = {
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    Tag?: TagUpdateOneRequiredWithoutAppliedTagNestedInput
    ArticleTagSource?: ArticleUpdateOneWithoutArticleTagSourceNestedInput
    ItemTagSource?: ItemUpdateOneWithoutItemTagSourceNestedInput
    QuestTagSource?: QuestUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type AppliedTagUncheckedUpdateWithoutMobTagSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type AreaUpsertWithoutMobInput = {
    update: XOR<AreaUpdateWithoutMobInput, AreaUncheckedUpdateWithoutMobInput>
    create: XOR<AreaCreateWithoutMobInput, AreaUncheckedCreateWithoutMobInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutMobInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutMobInput, AreaUncheckedUpdateWithoutMobInput>
  }

  export type AreaUpdateWithoutMobInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Author?: AccountUpdateOneWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutMobInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateWithoutAreaInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    ChangeLog?: ChangeLogCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutAreaInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    ChangeLog?: ChangeLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutAreaInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAreaInput, AccountUncheckedCreateWithoutAreaInput>
  }

  export type MobCreateWithoutAreaInput = {
    mudId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
    MobTagSource?: AppliedTagCreateNestedOneWithoutMobTagSourceInput
  }

  export type MobUncheckedCreateWithoutAreaInput = {
    id?: number
    mudId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
    MobTagSource?: AppliedTagUncheckedCreateNestedOneWithoutMobTagSourceInput
  }

  export type MobCreateOrConnectWithoutAreaInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutAreaInput, MobUncheckedCreateWithoutAreaInput>
  }

  export type MobCreateManyAreaInputEnvelope = {
    data: MobCreateManyAreaInput | MobCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutAreaInput = {
    update: XOR<AccountUpdateWithoutAreaInput, AccountUncheckedUpdateWithoutAreaInput>
    create: XOR<AccountCreateWithoutAreaInput, AccountUncheckedCreateWithoutAreaInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAreaInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAreaInput, AccountUncheckedUpdateWithoutAreaInput>
  }

  export type AccountUpdateWithoutAreaInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    ChangeLog?: ChangeLogUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    ChangeLog?: ChangeLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MobUpsertWithWhereUniqueWithoutAreaInput = {
    where: MobWhereUniqueInput
    update: XOR<MobUpdateWithoutAreaInput, MobUncheckedUpdateWithoutAreaInput>
    create: XOR<MobCreateWithoutAreaInput, MobUncheckedCreateWithoutAreaInput>
  }

  export type MobUpdateWithWhereUniqueWithoutAreaInput = {
    where: MobWhereUniqueInput
    data: XOR<MobUpdateWithoutAreaInput, MobUncheckedUpdateWithoutAreaInput>
  }

  export type MobUpdateManyWithWhereWithoutAreaInput = {
    where: MobScalarWhereInput
    data: XOR<MobUpdateManyMutationInput, MobUncheckedUpdateManyWithoutAreaInput>
  }

  export type MobScalarWhereInput = {
    AND?: MobScalarWhereInput | MobScalarWhereInput[]
    OR?: MobScalarWhereInput[]
    NOT?: MobScalarWhereInput | MobScalarWhereInput[]
    id?: IntFilter<"Mob"> | number
    mudId?: IntNullableFilter<"Mob"> | number | null
    areaId?: IntNullableFilter<"Mob"> | number | null
    shortDescription?: StringFilter<"Mob"> | string
    longDescription?: StringNullableFilter<"Mob"> | string | null
    level?: IntNullableFilter<"Mob"> | number | null
    isAggressive?: BoolFilter<"Mob"> | boolean
    experience?: IntNullableFilter<"Mob"> | number | null
    gold?: IntNullableFilter<"Mob"> | number | null
  }

  export type AccountCreateWithoutChangeLogInput = {
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordCreateNestedManyWithoutAccountInput
    Character?: CharacterCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionCreateNestedManyWithoutEditorInput
    Tag?: TagCreateNestedManyWithoutCreatorInput
    Area?: AreaCreateNestedManyWithoutAuthorInput
  }

  export type AccountUncheckedCreateWithoutChangeLogInput = {
    id?: number
    mudId?: string | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    firstName?: string | null
    lastName?: string | null
    email: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedCreateNestedManyWithoutAccountInput
    AccountPassword?: AccountPasswordUncheckedCreateNestedManyWithoutAccountInput
    Character?: CharacterUncheckedCreateNestedManyWithoutAccountInput
    NetworkHistory?: NetworkHistoryUncheckedCreateNestedManyWithoutAccountInput
    NetworkBlacklist?: NetworkBlacklistUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAccountInput
    CreatedItems?: ItemUncheckedCreateNestedManyWithoutCreatedItemsInput
    ModifiedItems?: ItemUncheckedCreateNestedManyWithoutModifiedItemsInput
    CreatedSpells?: SpellUncheckedCreateNestedManyWithoutCreatedSpellsInput
    ModifiedSpells?: SpellUncheckedCreateNestedManyWithoutModifiedSpellsInput
    CreatedPotions?: PotionUncheckedCreateNestedManyWithoutCreatedPotionsInput
    ModifiedPotions?: PotionUncheckedCreateNestedManyWithoutModifiedPotionsInput
    CreatedSkills?: SkillUncheckedCreateNestedManyWithoutCreatedSkillsInput
    ModifiedSkills?: SkillUncheckedCreateNestedManyWithoutModifiedSkillsInput
    CreatedAbilities?: AbilityUncheckedCreateNestedManyWithoutCreatedAbilitiesInput
    ModifiedAbilities?: AbilityUncheckedCreateNestedManyWithoutModifiedAbilitiesInput
    CreatedQuests?: QuestUncheckedCreateNestedManyWithoutCreatedQuestsInput
    ModifiedQuests?: QuestUncheckedCreateNestedManyWithoutModifiedQuestsInput
    Article?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    ArticleVersion?: ArticleVersionUncheckedCreateNestedManyWithoutEditorInput
    Tag?: TagUncheckedCreateNestedManyWithoutCreatorInput
    Area?: AreaUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AccountCreateOrConnectWithoutChangeLogInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutChangeLogInput, AccountUncheckedCreateWithoutChangeLogInput>
  }

  export type AccountUpsertWithoutChangeLogInput = {
    update: XOR<AccountUpdateWithoutChangeLogInput, AccountUncheckedUpdateWithoutChangeLogInput>
    create: XOR<AccountCreateWithoutChangeLogInput, AccountUncheckedCreateWithoutChangeLogInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutChangeLogInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutChangeLogInput, AccountUncheckedUpdateWithoutChangeLogInput>
  }

  export type AccountUpdateWithoutChangeLogInput = {
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUpdateManyWithoutAccountNestedInput
    Character?: CharacterUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUpdateManyWithoutEditorNestedInput
    Tag?: TagUpdateManyWithoutCreatorNestedInput
    Area?: AreaUpdateManyWithoutAuthorNestedInput
  }

  export type AccountUncheckedUpdateWithoutChangeLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    roles?: NullableJsonNullValueInput | InputJsonValue
    AccountNotification?: AccountNotificationUncheckedUpdateManyWithoutAccountNestedInput
    AccountPassword?: AccountPasswordUncheckedUpdateManyWithoutAccountNestedInput
    Character?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
    NetworkHistory?: NetworkHistoryUncheckedUpdateManyWithoutAccountNestedInput
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAccountNestedInput
    CreatedItems?: ItemUncheckedUpdateManyWithoutCreatedItemsNestedInput
    ModifiedItems?: ItemUncheckedUpdateManyWithoutModifiedItemsNestedInput
    CreatedSpells?: SpellUncheckedUpdateManyWithoutCreatedSpellsNestedInput
    ModifiedSpells?: SpellUncheckedUpdateManyWithoutModifiedSpellsNestedInput
    CreatedPotions?: PotionUncheckedUpdateManyWithoutCreatedPotionsNestedInput
    ModifiedPotions?: PotionUncheckedUpdateManyWithoutModifiedPotionsNestedInput
    CreatedSkills?: SkillUncheckedUpdateManyWithoutCreatedSkillsNestedInput
    ModifiedSkills?: SkillUncheckedUpdateManyWithoutModifiedSkillsNestedInput
    CreatedAbilities?: AbilityUncheckedUpdateManyWithoutCreatedAbilitiesNestedInput
    ModifiedAbilities?: AbilityUncheckedUpdateManyWithoutModifiedAbilitiesNestedInput
    CreatedQuests?: QuestUncheckedUpdateManyWithoutCreatedQuestsNestedInput
    ModifiedQuests?: QuestUncheckedUpdateManyWithoutModifiedQuestsNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    ArticleVersion?: ArticleVersionUncheckedUpdateManyWithoutEditorNestedInput
    Tag?: TagUncheckedUpdateManyWithoutCreatorNestedInput
    Area?: AreaUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AccountNotificationCreateManyAccountInput = {
    id?: number
    notificationId: number
    read?: boolean | null
    readDate?: Date | string | null
  }

  export type AccountPasswordCreateManyAccountInput = {
    id?: number
    passwordHash: string
  }

  export type CharacterCreateManyAccountInput = {
    id?: number
    mudId?: number | null
    createdDate?: Date | string
    modifiedDate?: Date | string
    name: string
    description?: string | null
    level?: number | null
  }

  export type NetworkHistoryCreateManyAccountInput = {
    id?: number
    createdDate?: Date | string
    loginDate?: Date | string
    ipAddress: string
  }

  export type NetworkBlacklistCreateManyAccountInput = {
    id?: number
    networkHistoryId: number
    issueDate: Date | string
    termDate: Date | string
  }

  export type NotificationCreateManyAccountInput = {
    id?: number
    createdDate: Date | string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    content?: string | null
  }

  export type ItemCreateManyCreatedItemsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string | null
    modifiedBy?: number | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
  }

  export type ItemCreateManyModifiedItemsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string | null
    shortDescription: string
    longDescription?: string | null
    timer?: number | null
    align?: $Enums.Align | null
    rent?: number | null
    preservable?: boolean | null
    netStat?: number | null
    notes?: string | null
    weight?: number | null
    slots?: string | null
    isBonded?: boolean | null
    isCastable?: boolean | null
    isHeroic?: boolean | null
    isLevelRequired?: boolean | null
    isLight?: boolean | null
    isLimited?: boolean | null
    isSoulbound?: boolean | null
    isUnique?: boolean | null
  }

  export type SpellCreateManyCreatedSpellsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
  }

  export type SpellCreateManyModifiedSpellsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    words?: string | null
    levelRequirement?: number | null
  }

  export type PotionCreateManyCreatedPotionsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
  }

  export type PotionCreateManyModifiedPotionsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    duration?: number | null
  }

  export type SkillCreateManyCreatedSkillsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
  }

  export type SkillCreateManyModifiedSkillsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    trainable?: boolean | null
    levelRequirement: number
  }

  export type AbilityCreateManyCreatedAbilitiesInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
  }

  export type AbilityCreateManyModifiedAbilitiesInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    firstRankPoints?: number | null
    secondRankPoints?: number | null
    thirdRankPoints?: number | null
    fourthRankPoints?: number | null
    fifthRankPoints?: number | null
    sixthRankPoints?: number | null
  }

  export type QuestCreateManyCreatedQuestsInput = {
    id?: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    modifiedBy: number
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
  }

  export type QuestCreateManyModifiedQuestsInput = {
    id?: number
    createdDate?: Date | string
    createdBy: number
    modifiedDate?: Date | string
    name: string
    description?: string | null
    notes?: string | null
    whoises?: string | null
    pretitles?: string | null
    post_titles?: string | null
    experience?: number | null
  }

  export type ArticleCreateManyAuthorInput = {
    id?: number
    createdDate?: Date | string
    isProtected?: boolean
  }

  export type ArticleVersionCreateManyEditorInput = {
    id?: number
    articleId: number
    modifiedDate?: Date | string
    content: string
    isCurrent: boolean
    version?: string | null
  }

  export type TagCreateManyCreatorInput = {
    id?: number
    createdDate?: Date | string
    tag: string
  }

  export type AreaCreateManyAuthorInput = {
    id?: number
    mudId?: number | null
    name: string
    releaseDate?: Date | string | null
  }

  export type ChangeLogCreateManyCreatorInput = {
    id?: number
    createdDate: Date | string
    content?: string | null
    version?: string | null
    releaseDate?: Date | string | null
  }

  export type AccountNotificationUpdateWithoutAccountInput = {
    notificationId?: IntFieldUpdateOperationsInput | number
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    readDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountNotificationUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    readDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountNotificationUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    readDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountPasswordUpdateWithoutAccountInput = {
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type AccountPasswordUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type AccountPasswordUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordHash?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterUpdateWithoutAccountInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterVersion?: CharacterVersionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterVersion?: CharacterVersionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NetworkHistoryUpdateWithoutAccountInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    NetworkBlacklist?: NetworkBlacklistUpdateManyWithoutNetworkHistoryNestedInput
  }

  export type NetworkHistoryUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    NetworkBlacklist?: NetworkBlacklistUncheckedUpdateManyWithoutNetworkHistoryNestedInput
  }

  export type NetworkHistoryUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkBlacklistUpdateWithoutAccountInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
    NetworkHistory?: NetworkHistoryUpdateOneRequiredWithoutNetworkBlacklistNestedInput
  }

  export type NetworkBlacklistUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    networkHistoryId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkBlacklistUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    networkHistoryId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutAccountInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemUpdateWithoutCreatedItemsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ModifiedItems?: AccountUpdateOneWithoutModifiedItemsNestedInput
    ItemSpell?: ItemSpellUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateWithoutCreatedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUncheckedUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutCreatedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifiedBy?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ItemUpdateWithoutModifiedItemsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CreatedItems?: AccountUpdateOneRequiredWithoutCreatedItemsNestedInput
    ItemSpell?: ItemSpellUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateWithoutModifiedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutItemNestedInput
    ItemWeapon?: ItemWeaponUncheckedUpdateOneWithoutItemNestedInput
    AmmoItem?: ItemWeaponUncheckedUpdateManyWithoutAmmoItemNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutItemSourceNestedInput
    ItemTagSource?: AppliedTagUncheckedUpdateOneWithoutItemTagSourceNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutModifiedItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    timer?: NullableIntFieldUpdateOperationsInput | number | null
    align?: NullableEnumAlignFieldUpdateOperationsInput | $Enums.Align | null
    rent?: NullableIntFieldUpdateOperationsInput | number | null
    preservable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netStat?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    slots?: NullableStringFieldUpdateOperationsInput | string | null
    isBonded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isCastable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isHeroic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLevelRequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLimited?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isSoulbound?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isUnique?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SpellUpdateWithoutCreatedSpellsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUpdateManyWithoutSpellNestedInput
    ModifiedSpells?: AccountUpdateOneRequiredWithoutModifiedSpellsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutSpellSourceNestedInput
  }

  export type SpellUncheckedUpdateWithoutCreatedSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutSpellNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutSpellSourceNestedInput
  }

  export type SpellUncheckedUpdateManyWithoutCreatedSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellUpdateWithoutModifiedSpellsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUpdateManyWithoutSpellNestedInput
    CreatedSpells?: AccountUpdateOneRequiredWithoutCreatedSpellsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutSpellSourceNestedInput
  }

  export type SpellUncheckedUpdateWithoutModifiedSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
    ItemSpell?: ItemSpellUncheckedUpdateManyWithoutSpellNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutSpellSourceNestedInput
  }

  export type SpellUncheckedUpdateManyWithoutModifiedSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    words?: NullableStringFieldUpdateOperationsInput | string | null
    levelRequirement?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PotionUpdateWithoutCreatedPotionsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ModifiedPotions?: AccountUpdateOneRequiredWithoutModifiedPotionsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutPotionSourceNestedInput
  }

  export type PotionUncheckedUpdateWithoutCreatedPotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutPotionSourceNestedInput
  }

  export type PotionUncheckedUpdateManyWithoutCreatedPotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PotionUpdateWithoutModifiedPotionsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedPotions?: AccountUpdateOneRequiredWithoutCreatedPotionsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutPotionSourceNestedInput
  }

  export type PotionUncheckedUpdateWithoutModifiedPotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutPotionSourceNestedInput
  }

  export type PotionUncheckedUpdateManyWithoutModifiedPotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SkillUpdateWithoutCreatedSkillsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
    ModifiedSkills?: AccountUpdateOneRequiredWithoutModifiedSkillsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutSkillSourceNestedInput
  }

  export type SkillUncheckedUpdateWithoutCreatedSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
    StatModifer?: StatModiferUncheckedUpdateOneWithoutSkillSourceNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutCreatedSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
  }

  export type SkillUpdateWithoutModifiedSkillsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
    CreatedSkills?: AccountUpdateOneRequiredWithoutCreatedSkillsNestedInput
    StatModifer?: StatModiferUpdateOneWithoutSkillSourceNestedInput
  }

  export type SkillUncheckedUpdateWithoutModifiedSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
    StatModifer?: StatModiferUncheckedUpdateOneWithoutSkillSourceNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutModifiedSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trainable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    levelRequirement?: IntFieldUpdateOperationsInput | number
  }

  export type AbilityUpdateWithoutCreatedAbilitiesInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    ModifiedAbilities?: AccountUpdateOneRequiredWithoutModifiedAbilitiesNestedInput
    StatModifer?: StatModiferUpdateOneWithoutAbilitySourceNestedInput
  }

  export type AbilityUncheckedUpdateWithoutCreatedAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutAbilitySourceNestedInput
  }

  export type AbilityUncheckedUpdateManyWithoutCreatedAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AbilityUpdateWithoutModifiedAbilitiesInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedAbilities?: AccountUpdateOneRequiredWithoutCreatedAbilitiesNestedInput
    StatModifer?: StatModiferUpdateOneWithoutAbilitySourceNestedInput
  }

  export type AbilityUncheckedUpdateWithoutModifiedAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    StatModifer?: StatModiferUncheckedUpdateOneWithoutAbilitySourceNestedInput
  }

  export type AbilityUncheckedUpdateManyWithoutModifiedAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    firstRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    secondRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    thirdRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fourthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    fifthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
    sixthRankPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestUpdateWithoutCreatedQuestsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    ModifiedQuests?: AccountUpdateOneRequiredWithoutModifiedQuestsNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestUncheckedUpdateWithoutCreatedQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUncheckedUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestUncheckedUpdateManyWithoutCreatedQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedBy?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestUpdateWithoutModifiedQuestsInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CreatedQuests?: AccountUpdateOneRequiredWithoutCreatedQuestsNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestUncheckedUpdateWithoutModifiedQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutQuestNestedInput
    StatModifer?: StatModiferUncheckedUpdateOneWithoutQuestSourceNestedInput
    QuestTagSource?: AppliedTagUncheckedUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type QuestUncheckedUpdateManyWithoutModifiedQuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    whoises?: NullableStringFieldUpdateOperationsInput | string | null
    pretitles?: NullableStringFieldUpdateOperationsInput | string | null
    post_titles?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArticleUpdateWithoutAuthorInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    ArticleContent?: ArticleVersionUpdateManyWithoutArticleNestedInput
    ArticleTagSource?: AppliedTagUpdateOneWithoutArticleTagSourceNestedInput
  }

  export type ArticleUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    ArticleContent?: ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
    ArticleTagSource?: AppliedTagUncheckedUpdateOneWithoutArticleTagSourceNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isProtected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArticleVersionUpdateWithoutEditorInput = {
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
    Article?: ArticleUpdateOneRequiredWithoutArticleContentNestedInput
  }

  export type ArticleVersionUncheckedUpdateWithoutEditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleVersionUncheckedUpdateManyWithoutEditorInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutCreatorInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    AppliedTag?: AppliedTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    AppliedTag?: AppliedTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type AreaUpdateWithoutAuthorInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Mob?: MobUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Mob?: MobUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeLogUpdateWithoutCreatorInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeLogUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeLogUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NetworkBlacklistCreateManyNetworkHistoryInput = {
    id?: number
    issueDate: Date | string
    termDate: Date | string
    issuer: number
  }

  export type NetworkBlacklistUpdateWithoutNetworkHistoryInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUpdateOneRequiredWithoutNetworkBlacklistNestedInput
  }

  export type NetworkBlacklistUncheckedUpdateWithoutNetworkHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IntFieldUpdateOperationsInput | number
  }

  export type NetworkBlacklistUncheckedUpdateManyWithoutNetworkHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    termDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterVersionCreateManyCharacterInput = {
    id?: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
    characterEquipmentId?: number | null
  }

  export type CharacterVersionUpdateWithoutCharacterInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    CharacterStat?: CharacterStatUpdateOneWithoutCharacterVersionNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutCharacterVersionNestedInput
    CharacterEquipment?: CharacterEquipmentUpdateOneWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionUncheckedUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    characterEquipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    CharacterStat?: CharacterStatUncheckedUpdateOneWithoutCharacterVersionNestedInput
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionUncheckedUpdateManyWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    characterEquipmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterQuestCreateManyCharacterVersionInput = {
    id?: number
    questId: number
  }

  export type CharacterQuestUpdateWithoutCharacterVersionInput = {
    Quest?: QuestUpdateOneRequiredWithoutCharacterQuestNestedInput
  }

  export type CharacterQuestUncheckedUpdateWithoutCharacterVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterQuestUncheckedUpdateManyWithoutCharacterVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterVersionCreateManyCharacterEquipmentInput = {
    id?: number
    characterId: number
    equipmentId: number
    statsId: number
    createdDate?: Date | string
    modifiedDate?: Date | string
    version: string
    hometown?: string | null
  }

  export type CharacterVersionUpdateWithoutCharacterEquipmentInput = {
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    Character?: CharacterUpdateOneRequiredWithoutCharacterVersionNestedInput
    CharacterStat?: CharacterStatUpdateOneWithoutCharacterVersionNestedInput
    CharacterQuest?: CharacterQuestUpdateManyWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionUncheckedUpdateWithoutCharacterEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    CharacterStat?: CharacterStatUncheckedUpdateOneWithoutCharacterVersionNestedInput
    CharacterQuest?: CharacterQuestUncheckedUpdateManyWithoutCharacterVersionNestedInput
  }

  export type CharacterVersionUncheckedUpdateManyWithoutCharacterEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
    statsId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemSpellCreateManyItemInput = {
    id?: number
    spellId: number
  }

  export type ItemWeaponCreateManyAmmoItemInput = {
    id?: number
    itemId: number
    quality?: number | null
    speed?: number | null
    isHoldable?: boolean
    isTwoHanded?: boolean
    ammoCapacity?: number | null
    shotAccuracy?: number | null
    maxDamage?: number | null
    minDamage?: number | null
    avgDamage?: number | null
    stat?: $Enums.WeaponStat | null
    type?: $Enums.WeaponType | null
  }

  export type ItemSpellUpdateWithoutItemInput = {
    Spell?: SpellUpdateOneRequiredWithoutItemSpellNestedInput
  }

  export type ItemSpellUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemSpellUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemWeaponUpdateWithoutAmmoItemInput = {
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    Item?: ItemUpdateOneRequiredWithoutItemWeaponNestedInput
  }

  export type ItemWeaponUncheckedUpdateWithoutAmmoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
  }

  export type ItemWeaponUncheckedUpdateManyWithoutAmmoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: NullableIntFieldUpdateOperationsInput | number | null
    isHoldable?: BoolFieldUpdateOperationsInput | boolean
    isTwoHanded?: BoolFieldUpdateOperationsInput | boolean
    ammoCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    shotAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    maxDamage?: NullableIntFieldUpdateOperationsInput | number | null
    minDamage?: NullableIntFieldUpdateOperationsInput | number | null
    avgDamage?: NullableIntFieldUpdateOperationsInput | number | null
    stat?: NullableEnumWeaponStatFieldUpdateOperationsInput | $Enums.WeaponStat | null
    type?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
  }

  export type ItemSpellCreateManySpellInput = {
    id?: number
    itemId: number
  }

  export type ItemSpellUpdateWithoutSpellInput = {
    Item?: ItemUpdateOneRequiredWithoutItemSpellNestedInput
  }

  export type ItemSpellUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemSpellUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterQuestCreateManyQuestInput = {
    id?: number
    characterVersionId: number
  }

  export type CharacterQuestUpdateWithoutQuestInput = {
    CharacterVersion?: CharacterVersionUpdateOneRequiredWithoutCharacterQuestNestedInput
  }

  export type CharacterQuestUncheckedUpdateWithoutQuestInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterVersionId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterQuestUncheckedUpdateManyWithoutQuestInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterVersionId?: IntFieldUpdateOperationsInput | number
  }

  export type ArticleVersionCreateManyArticleInput = {
    id?: number
    modifiedDate?: Date | string
    editorId: number
    content: string
    isCurrent: boolean
    version?: string | null
  }

  export type ArticleVersionUpdateWithoutArticleInput = {
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
    Editor?: AccountUpdateOneRequiredWithoutArticleVersionNestedInput
  }

  export type ArticleVersionUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    editorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArticleVersionUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    modifiedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    editorId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppliedTagCreateManyTagInput = {
    id?: number
    typeId: $Enums.TagType
    sourceId?: number | null
  }

  export type AppliedTagUpdateWithoutTagInput = {
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    ArticleTagSource?: ArticleUpdateOneWithoutArticleTagSourceNestedInput
    ItemTagSource?: ItemUpdateOneWithoutItemTagSourceNestedInput
    MobTagSource?: MobUpdateOneWithoutMobTagSourceNestedInput
    QuestTagSource?: QuestUpdateOneWithoutQuestTagSourceNestedInput
  }

  export type AppliedTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AppliedTagUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MobCreateManyAreaInput = {
    id?: number
    mudId?: number | null
    shortDescription: string
    longDescription?: string | null
    level?: number | null
    isAggressive?: boolean
    experience?: number | null
    gold?: number | null
  }

  export type MobUpdateWithoutAreaInput = {
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
    MobTagSource?: AppliedTagUpdateOneWithoutMobTagSourceNestedInput
  }

  export type MobUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
    MobTagSource?: AppliedTagUncheckedUpdateOneWithoutMobTagSourceNestedInput
  }

  export type MobUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    mudId?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    gold?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NetworkHistoryCountOutputTypeDefaultArgs instead
     */
    export type NetworkHistoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NetworkHistoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterCountOutputTypeDefaultArgs instead
     */
    export type CharacterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterVersionCountOutputTypeDefaultArgs instead
     */
    export type CharacterVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterEquipmentCountOutputTypeDefaultArgs instead
     */
    export type CharacterEquipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterEquipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCountOutputTypeDefaultArgs instead
     */
    export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellCountOutputTypeDefaultArgs instead
     */
    export type SpellCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestCountOutputTypeDefaultArgs instead
     */
    export type QuestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleCountOutputTypeDefaultArgs instead
     */
    export type ArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaCountOutputTypeDefaultArgs instead
     */
    export type AreaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountNotificationDefaultArgs instead
     */
    export type AccountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountPasswordDefaultArgs instead
     */
    export type AccountPasswordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountPasswordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NetworkHistoryDefaultArgs instead
     */
    export type NetworkHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NetworkHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NetworkBlacklistDefaultArgs instead
     */
    export type NetworkBlacklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NetworkBlacklistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterDefaultArgs instead
     */
    export type CharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterVersionDefaultArgs instead
     */
    export type CharacterVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterStatDefaultArgs instead
     */
    export type CharacterStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterStatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterQuestDefaultArgs instead
     */
    export type CharacterQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterQuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterEquipmentDefaultArgs instead
     */
    export type CharacterEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterEquipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemWeaponDefaultArgs instead
     */
    export type ItemWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemWeaponDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemSpellDefaultArgs instead
     */
    export type ItemSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemSpellDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellDefaultArgs instead
     */
    export type SpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PotionDefaultArgs instead
     */
    export type PotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDefaultArgs instead
     */
    export type SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AbilityDefaultArgs instead
     */
    export type AbilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AbilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestDefaultArgs instead
     */
    export type QuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatModiferDefaultArgs instead
     */
    export type StatModiferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatModiferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleDefaultArgs instead
     */
    export type ArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleVersionDefaultArgs instead
     */
    export type ArticleVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppliedTagDefaultArgs instead
     */
    export type AppliedTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppliedTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobDefaultArgs instead
     */
    export type MobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaDefaultArgs instead
     */
    export type AreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeLogDefaultArgs instead
     */
    export type ChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}